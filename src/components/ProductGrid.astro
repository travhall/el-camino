---
// src/components/ProductGrid.astro - Enhanced with batch inventory optimization
import ProductCard from "./ProductCard.astro";
import ProductCardSkeleton from "./ProductCardSkeleton.astro";
import type { Product, ProductWithInventory } from "@/lib/square/types";
import { batchInventoryService } from "@/lib/square/batchInventory";

interface Props {
  products: Product[];
  allProducts?: Product[]; // All products for client-side filtering
  categoryPath?: string;
  skipInventoryCheck?: boolean;
}

const {
  products,
  allProducts,
  categoryPath = "",
  skipInventoryCheck = false,
} = Astro.props;

console.log('[ProductGrid] üìä Props analysis:', {
  productsCount: products?.length || 0,
  allProductsCount: allProducts?.length || 0,
  categoryPath,
  sampleProducts: products?.slice(0, 3).map(p => ({ id: p.id, brand: p.brand })) || []
});

// FIXED: Separate rendering products from inventory checking products
// - products: What to render (server-filtered for mobile, all for desktop)  
// - allProducts: What to use for client-side filtering data

// For rendering: always use the products prop (server-filtered)
const productsToRender = products;

// For inventory checking: check inventory for all products that might be needed
const productsToCheck = allProducts && allProducts.length > 0 ? allProducts : products;

console.log('[ProductGrid] üéØ FIXED: Rendering vs Inventory logic:', {
  productsToRender: productsToRender?.length || 0,
  productsToCheck: productsToCheck?.length || 0,
  renderingFiltered: productsToRender !== productsToCheck
});

// Batch inventory check for all products that will be displayed
let productsWithInventory: ProductWithInventory[] = productsToRender;
let allProductsWithInventory: ProductWithInventory[] = allProducts || [];

if (!skipInventoryCheck && productsToCheck.length > 0) {
  try {
    // Check inventory for all products (for efficiency)
    const variationIds = productsToCheck
      .map((p) => p.variationId)
      .filter(Boolean);
    const inventoryMap =
      await batchInventoryService.getBatchInventoryStatus(variationIds);

    // Apply inventory to products we're rendering (server-filtered)
    productsWithInventory = productsToRender.map((product) => {
      const inventoryStatus = inventoryMap.get(product.variationId) || {
        isOutOfStock: false,
        hasLimitedOptions: false,
        totalQuantity: 0,
      };

      return {
        ...product,
        inventoryStatus,
      };
    });

    // FIXED: Also apply inventory to ALL products for client-side filtering
    allProductsWithInventory = productsToCheck.map((product) => {
      const inventoryStatus = inventoryMap.get(product.variationId) || {
        isOutOfStock: false,
        hasLimitedOptions: false,
        totalQuantity: 0,
      };

      return {
        ...product,
        inventoryStatus,
      };
    });
    
    console.log('[ProductGrid] ‚úÖ Inventory applied to both sets:', {
      checkedInventoryFor: productsToCheck.length,
      appliedToRendered: productsWithInventory.length,
      appliedToAll: allProductsWithInventory.length,
      sampleWithInventory: productsWithInventory.slice(0, 2).map(p => ({ 
        id: p.id, 
        brand: p.brand, 
        isOutOfStock: p.inventoryStatus?.isOutOfStock 
      }))
    });
  } catch (error) {
    console.error("Batch inventory check failed:", error);
    // Fallback: all products assumed in stock
    productsWithInventory = productsToRender.map((product) => ({
      ...product,
      inventoryStatus: {
        isOutOfStock: false,
        hasLimitedOptions: false,
        totalQuantity: 0,
      },
    }));
    
    allProductsWithInventory = (allProducts || []).map((product) => ({
      ...product,
      inventoryStatus: {
        isOutOfStock: false,
        hasLimitedOptions: false,
        totalQuantity: 0,
      },
    }));
  }
} else {
  console.log('[ProductGrid] ‚ö™ Skipping inventory check or no products to check');
}
---

<style>
  /* Animation Configuration */
  :root {
    --card-transition-duration: 0.3s;
    --card-stagger-delay: 75ms;
    --row-stagger-delay: 150ms;
  }

  /* Responsive optimizations */
  @media (max-width: 1023px) {
    :root {
      --card-transition-duration: 0.2s; /* Faster on mobile */
      --card-stagger-delay: 50ms;
      --row-stagger-delay: 100ms;
    }
  }

  /* Respect reduced motion preferences */
  @media (prefers-reduced-motion: reduce) {
    :root {
      --card-transition-duration: 0.1s;
      --card-stagger-delay: 0ms;
      --row-stagger-delay: 0ms;
    }
  }

  /* SMOOTH FILTERING: Prevent layout shifts with opacity transitions */
  .product-card-wrapper {
    transition:
      opacity var(--card-transition-duration) ease,
      transform var(--card-transition-duration) ease;
    will-change: opacity, transform;
    transform: translate3d(0, 0, 0); /* GPU acceleration */
  }

  .product-card-wrapper.opacity-0 {
    opacity: 0;
    transform: scale(0.95) translate3d(0, 10px, 0);
  }

  .product-card-wrapper.opacity-100 {
    opacity: 1;
    transform: scale(1) translate3d(0, 0, 0);
  }

  /* Animation states for different scenarios */
  .product-card-wrapper.animating {
    will-change: opacity, transform;
  }

  .product-card-wrapper:not(.animating) {
    will-change: auto;
  }

  /* MOBILE INFINITE SCROLL: Better spacing and loading states */
  @media (max-width: 1023px) {
    #infinite-scroll-trigger {
      margin: 1rem 0;
    }
  }
</style>

<div
  id="filterable-product-grid"
  class="product-grid grid md:grid-cols-2 lg:grid-cols-3 xl:grid-cols-4 2xl:grid-cols-6 gap-2 lg:gap-1 transition-all duration-300"
  data-all-products={JSON.stringify(allProductsWithInventory)}
  data-initial-products={JSON.stringify(productsWithInventory)}
  data-category-path={categoryPath}
  data-product-count={productsWithInventory.length}
>
  {
    productsWithInventory.map((product, index) => {
      // Server-side safe responsive calculation  
      // Use a conservative estimate that works across all screen sizes
      const serverSideCardsPerRow = 4; // Safe default for SSR
      const initialRowsToShow = 4;
      const initialCardsToShow = serverSideCardsPerRow * initialRowsToShow; // 16 cards initially
      
      return (
        <div
          class="product-card-wrapper grid opacity-0"
          data-product-id={product.id}
          data-brand={product.brand || ""}
          data-initial-index={index}
          style={
            allProducts && allProducts.length > 0 && index >= initialCardsToShow
              ? "display: none;"
              : ""
          }
        >
          <ProductCard
            product={product}
            priority={index < 8}
            inventoryStatus={product.inventoryStatus}
            skipInventoryCheck={!!product.inventoryStatus}
          />
        </div>
      );
    })
  }
</div>

<!-- RESTORED: Working Infinite Scroll Trigger -->
<div
  id="infinite-scroll-trigger"
  class="col-span-full h-20 flex items-center justify-center"
  style="display: none;"
>
  <div class="flex items-center space-x-3">
    <div
      class="animate-spin rounded-full h-5 w-5 border-2 border-ui-accent border-t-transparent"
    >
    </div>
    <span class="text-(--content-body) font-medium"
      >Loading more products...</span
    >
  </div>
</div>

<!-- Enhanced Loading Overlay -->
<div
  id="filter-loading-overlay"
  class="fixed inset-0 bg-(--surface-primary)/60 backdrop-blur-sm z-40 flex items-center justify-center"
  style="display: none;"
>
  <div
    class="bg-(--surface-secondary) rounded-lg p-6 shadow-lg flex items-center space-x-3"
  >
    <div
      class="animate-spin rounded-full h-5 w-5 border-2 border-ui-accent border-t-transparent"
    >
    </div>
    <span class="text-(--content-body) font-medium">Applying filters...</span>
  </div>
</div>

<!-- Product Grid Loading Skeleton -->
<div
  id="product-grid-skeleton"
  class="hidden grid-cols-2 md:grid-cols-2 lg:grid-cols-3 xl:grid-cols-4 2xl:grid-cols-6 gap-1"
>
  {
    Array.from({ length: 12 }, (_, i) => (
      <ProductCardSkeleton priority={i < 8} />
    ))
  }
</div>

<!-- No Results State (for client-side mode only) -->
<div
  id="no-results"
  class="hidden flex-col justify-center items-center col-span-full py-16 text-center"
>
  <div class="text-center">
    <div class="text-6xl mb-4 opacity-20">üîç</div>
    <h2 class="text-2xl font-display font-bold text-(--content-heading) mb-2">
      No products found
    </h2>
    <p class="text-(--content-meta) mb-6 max-w-md mx-auto">
      Try adjusting your filters or browse all products.
    </p>
    <a
      href={categoryPath}
      class="font-sans font-semibold text-sm text-center lg:text-base py-2 px-3 lg:py-2 lg:px-4 border-2 rounded-[4px] text-(--ui-button-text) bg-(--ui-button-surface) border-(--ui-button-border) hover:bg-(--ui-button-surface)/75 outline-0 focus-visible:ring focus-visible:ring-offset-2 focus-visible:ring-(--ui-button-ring) transition-all ease-in-out duration-300"
    >
      Clear Filters
    </a>
  </div>
</div>

<script>
  // Animation configuration
  const ANIMATION_CONFIG = {
    staggerDelay:
      parseInt(
        getComputedStyle(document.documentElement).getPropertyValue(
          "--card-stagger-delay"
        )
      ) || 50,
    rowStaggerDelay:
      parseInt(
        getComputedStyle(document.documentElement).getPropertyValue(
          "--row-stagger-delay"
        )
      ) || 100,
    duration:
      parseInt(
        getComputedStyle(document.documentElement)
          .getPropertyValue("--card-transition-duration")
          .replace("s", "")
      ) * 1000 || 300,
  };

  // Enhanced page load entrance animations with combined row + individual card stagger
  function initializePageLoadAnimations() {
    const cards = document.querySelectorAll(".product-card-wrapper.opacity-0");
    if (!cards.length) return;

    // Calculate cards per row for row-based animation
    function getCardsPerRow() {
      const width = window.innerWidth;
      if (width >= 1536) return 6; // 2xl:grid-cols-6
      if (width >= 1280) return 4; // xl:grid-cols-4
      if (width >= 1024) return 3; // lg:grid-cols-3
      if (width >= 768) return 2;  // md:grid-cols-2
      return 2; // fallback
    }

    const observer = new IntersectionObserver(
      (entries) => {
        entries.forEach((entry) => {
          if (entry.isIntersecting) {
            const card = entry.target as HTMLElement;
            const index = parseInt(card.dataset.initialIndex || "0");
            const cardsPerRow = getCardsPerRow();
            const rowIndex = Math.floor(index / cardsPerRow);
            const cardInRow = index % cardsPerRow;

            // Add animating class for will-change optimization
            card.classList.add("animating");

            // Combined stagger: row delay + individual card delay
            const rowStaggerDelay = parseInt(
              getComputedStyle(document.documentElement).getPropertyValue("--row-stagger-delay")
            ) || 100;
            
            const cardStaggerDelay = parseInt(
              getComputedStyle(document.documentElement).getPropertyValue("--card-stagger-delay")
            ) || 50;

            const baseRowDelay = rowIndex * rowStaggerDelay;
            const cardDelay = cardInRow * (cardStaggerDelay / 2); // More noticeable individual stagger
            const totalDelay = baseRowDelay + cardDelay;

            setTimeout(() => {
              card.classList.remove("opacity-0");
              card.classList.add("opacity-100");

              // Remove will-change after animation completes
              setTimeout(() => {
                card.classList.remove("animating");
              }, ANIMATION_CONFIG.duration);
            }, totalDelay);

            // Stop observing this card
            observer.unobserve(card);
          }
        });
      },
      {
        threshold: 0.1,
        rootMargin: "50px",
      }
    );

    cards.forEach((card) => observer.observe(card));
  }

  // Handle filter state restoration
  document.addEventListener("astro:page-load", () => {
    const grid = document.getElementById("filterable-product-grid");
    const isFiltering = sessionStorage.getItem("filtering-in-progress");

    if (isFiltering && grid) {
      // Clear filtering state
      sessionStorage.removeItem("filtering-in-progress");

      // Ensure grid is visible
      grid.style.opacity = "1";
      grid.style.transition = "opacity 0.3s ease";
    }

    // Initialize page load animations
    initializePageLoadAnimations();

    // RESTORED: Initialize working infinite scroll
    initializeInfiniteScroll();

    // Signal ProductGrid ready for filtering coordination
    console.log(
      "[ProductGrid] üì° Emitting productGridReady on astro:page-load"
    );
    document.dispatchEvent(new CustomEvent("productGridReady"));
  });

  // Initialize on DOMContentLoaded as well
  document.addEventListener("DOMContentLoaded", () => {
    const grid = document.getElementById("filterable-product-grid");
    if (grid && sessionStorage.getItem("filtering-in-progress")) {
      grid.style.opacity = "1";
      sessionStorage.removeItem("filtering-in-progress");
    }

    // Initialize infinite scroll
    initializeInfiniteScroll();

    // Signal that ProductGrid is loaded and ready
    console.log(
      "[ProductGrid] üì° Emitting productGridReady on DOMContentLoaded"
    );
    document.dispatchEvent(new CustomEvent("productGridReady"));
  });

  // RESTORED: Simple infinite scroll without filter-awareness conflicts
  function initializeInfiniteScroll() {
    const grid = document.getElementById("filterable-product-grid");
    const trigger = document.getElementById("infinite-scroll-trigger");

    if (!grid || !trigger) return;

    // Simple: Get all product cards  
    const allCards = Array.from(grid.querySelectorAll(".product-card-wrapper"));
    
    console.log(`[ProductGrid] üîç Simple infinite scroll initialization:`, {
      totalCards: allCards.length
    });
    
    // Enhanced responsive grid calculation - consistent with server-side
    function getCardsPerRow() {
      const width = window.innerWidth;
      if (width >= 1536) return 6; // 2xl:grid-cols-6
      if (width >= 1280) return 4; // xl:grid-cols-4
      if (width >= 1024) return 3; // lg:grid-cols-3
      if (width >= 768) return 2;  // md:grid-cols-2
      return 2; // fallback
    }

    const cardsPerRow = getCardsPerRow();
    const initialRows = 4; // Show 4 rows initially
    let visibleCount = cardsPerRow * initialRows;

    console.log(`[ProductGrid] üìê Grid calculation:`, {
      cardsPerRow,
      initialRows,
      calculatedVisibleCount: visibleCount
    });

    // SIMPLIFIED: Show initial batch based on current screen size
    allCards.forEach((card, index) => {
      const htmlCard = card as HTMLElement;
      if (index < visibleCount) {
        // This card should be visible
        htmlCard.style.display = '';
        htmlCard.removeAttribute('data-infinite-scroll-hidden');
      } else {
        // This card should be hidden by infinite scroll
        htmlCard.style.display = 'none';
        htmlCard.setAttribute('data-infinite-scroll-hidden', 'true');
      }
    });

    // Check if we need infinite scroll
    if (allCards.length <= visibleCount) {
      trigger.style.display = "none";
      console.log(`[ProductGrid] ‚ö†Ô∏è Infinite scroll disabled: ${allCards.length} total cards <= ${visibleCount} initial visible count`);
      return;
    }

    // Show trigger if there are more products
    trigger.style.display = "flex";
    console.log(`[ProductGrid] ‚úÖ Infinite scroll enabled: ${allCards.length} total cards > ${visibleCount} initial visible count`);

    // SIMPLIFIED: Intersection Observer for infinite scroll
    const observer = new IntersectionObserver(
      (entries) => {
        entries.forEach((entry) => {
          if (entry.isIntersecting) {            
            if (visibleCount < allCards.length) {
              console.log(
                `[ProductGrid] Loading more products... (${visibleCount}/${allCards.length})`
              );

              // Show loading state
              trigger.innerHTML = `
              <div class="flex items-center space-x-3">
                <div class="animate-spin rounded-full h-5 w-5 border-2 border-ui-accent border-t-transparent"></div>
                <span class="text-(--content-body) font-medium">Loading more products...</span>
              </div>
            `;

              // Load next batch after short delay for smooth UX
              setTimeout(() => {
                const rowsToLoad = 2; // Load 2 rows at a time
                const cardsToShow = cardsPerRow * rowsToLoad;
                const newVisibleCount = Math.min(visibleCount + cardsToShow, allCards.length);

                console.log(
                  `[ProductGrid] Loading ${cardsToShow} cards (${cardsPerRow} per row √ó 2 rows)`
                );

                // Show the next batch with stagger animation
                for (let i = visibleCount; i < newVisibleCount; i++) {
                  if (allCards[i]) {
                    const card = allCards[i] as HTMLElement;
                    const batchIndex = i - visibleCount;
                    const rowOffset = Math.floor(batchIndex / cardsPerRow);
                    const cardInRow = batchIndex % cardsPerRow;
                    
                    // Combined delay: row delay + individual card delay
                    const baseRowDelay = rowOffset * 100; // 100ms per row
                    const cardDelay = cardInRow * 35; // 35ms per card within row
                    const totalDelay = baseRowDelay + cardDelay;
                    
                    setTimeout(() => {
                      card.style.display = '';
                      card.removeAttribute('data-infinite-scroll-hidden');
                      card.classList.remove('opacity-0');
                      card.classList.add('opacity-100');
                    }, totalDelay);
                  }
                }

                visibleCount = newVisibleCount;
                console.log(
                  `[ProductGrid] Now showing ${visibleCount}/${allCards.length} products`
                );

                // Hide trigger if all products are loaded
                if (visibleCount >= allCards.length) {
                  trigger.style.display = "none";
                  console.log(
                    "[ProductGrid] All products loaded, hiding trigger"
                  );
                } else {
                  // Reset trigger content for next batch
                  trigger.innerHTML = `
                  <div class="flex items-center space-x-3">
                    <div class="animate-spin rounded-full h-5 w-5 border-2 border-ui-accent border-t-transparent"></div>
                    <span class="text-(--content-body) font-medium">Loading more products...</span>
                  </div>
                `;
                }
              }, 500);
            }
          }
        });
      },
      {
        threshold: 0.1,
        rootMargin: "50px",
      }
    );

    observer.observe(trigger);
    console.log(
      `[ProductGrid] ‚úÖ Simple infinite scroll initialized for ${allCards.length} products (${cardsPerRow} per row)`
    );
  }
</script>
