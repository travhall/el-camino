---
// src/components/ProductGrid.astro - Enhanced with batch inventory optimization
import ProductCard from "./ProductCard.astro";
import ProductCardSkeleton from "./ProductCardSkeleton.astro";
import type { Product, ProductWithInventory } from "@/lib/square/types";
import { batchInventoryService } from "@/lib/square/batchInventory";

interface Props {
  products: Product[];
  allProducts?: Product[]; // All products for client-side filtering
  categoryPath?: string;
  skipInventoryCheck?: boolean;
}

const { products, allProducts, categoryPath = "", skipInventoryCheck = false } = Astro.props;

// Determine which products to check inventory for
const productsToCheck = allProducts && allProducts.length > 0 ? allProducts : products;

// Batch inventory check for all products that will be displayed
let productsWithInventory: ProductWithInventory[] = productsToCheck;

if (!skipInventoryCheck && productsToCheck.length > 0) {
  try {
    const variationIds = productsToCheck.map(p => p.variationId).filter(Boolean);
    const inventoryMap = await batchInventoryService.getBatchInventoryStatus(variationIds);
    
    productsWithInventory = productsToCheck.map(product => {
      const inventoryStatus = inventoryMap.get(product.variationId) || {
        isOutOfStock: false,
        hasLimitedOptions: false,
        totalQuantity: 0,
      };
      
      return {
        ...product,
        inventoryStatus
      };
    });
  } catch (error) {
    console.error('Batch inventory check failed:', error);
    // Fallback: all products assumed in stock
    productsWithInventory = productsToCheck.map(product => ({
      ...product,
      inventoryStatus: {
        isOutOfStock: false,
        hasLimitedOptions: false,
        totalQuantity: 0,
      }
    }));
  }
}
---

<style>
  /* Animation Configuration */
  :root {
    --card-transition-duration: 0.3s;
    --card-stagger-delay: 50ms;
  }
  
  /* Respect reduced motion preferences */
  @media (prefers-reduced-motion: reduce) {
    :root {
      --card-transition-duration: 0.1s;
      --card-stagger-delay: 0ms;
    }
  }

  /* SMOOTH FILTERING: Prevent layout shifts with opacity transitions */
  .product-card-wrapper {
    transition: opacity var(--card-transition-duration) ease, 
                transform var(--card-transition-duration) ease;
    will-change: opacity, transform;
  }
  
  .product-card-wrapper.opacity-0 {
    opacity: 0;
    transform: scale(0.95) translate3d(0, 10px, 0);
  }
  
  .product-card-wrapper.opacity-100 {
    opacity: 1;
    transform: scale(1) translate3d(0, 0, 0);
  }
  
  /* Animation states for different scenarios */
  .product-card-wrapper.animating {
    will-change: opacity, transform;
  }
  
  .product-card-wrapper:not(.animating) {
    will-change: auto;
  }
  
  /* MOBILE INFINITE SCROLL: Better spacing and loading states */
  @media (max-width: 1023px) {
    #infinite-scroll-trigger {
      margin: 1rem 0;
    }
  }
</style>

<div
  id="filterable-product-grid"
  class="product-grid grid md:grid-cols-2 lg:grid-cols-3 xl:grid-cols-4 2xl:grid-cols-6 gap-2 lg:gap-1 transition-all duration-300"
  data-all-products={JSON.stringify(allProducts || [])}
  data-initial-products={JSON.stringify(productsWithInventory)}
  data-category-path={categoryPath}
  data-product-count={productsWithInventory.length}
>
  {
    productsWithInventory.map((product, index) => (
      <div
        class="product-card-wrapper grid opacity-0"
        data-product-id={product.id}
        data-brand={product.brand || ""}
        data-initial-index={index}
        style={allProducts && allProducts.length > 0 && index >= 24 ? "display: none;" : ""}
      >
        <ProductCard 
          product={product} 
          priority={index < 8}
          inventoryStatus={product.inventoryStatus}
          skipInventoryCheck={!!product.inventoryStatus}
        />
      </div>
    ))
  }
</div>

<!-- DAY 1: Infinite Scroll Trigger (hidden until Day 2 activation) -->
<div 
  id="infinite-scroll-trigger" 
  class="col-span-full h-20 flex items-center justify-center"
  style="display: none;"
>
  <div class="flex items-center space-x-3">
    <div class="animate-spin rounded-full h-5 w-5 border-2 border-ui-accent border-t-transparent"></div>
    <span class="text-(--content-body) font-medium">Loading more products...</span>
  </div>
</div>

<!-- Enhanced Loading Overlay -->
<div
  id="filter-loading-overlay"
  class="fixed inset-0 bg-(--surface-primary)/60 backdrop-blur-sm z-40 flex items-center justify-center"
  style="display: none;"
>
  <div
    class="bg-(--surface-secondary) rounded-lg p-6 shadow-lg flex items-center space-x-3"
  >
    <div
      class="animate-spin rounded-full h-5 w-5 border-2 border-ui-accent border-t-transparent"
    >
    </div>
    <span class="text-(--content-body) font-medium">Applying filters...</span>
  </div>
</div>

<!-- Product Grid Loading Skeleton -->
<div
  id="product-grid-skeleton"
  class="hidden grid-cols-2 md:grid-cols-2 lg:grid-cols-3 xl:grid-cols-4 2xl:grid-cols-6 gap-1"
>
  {
    Array.from({ length: 12 }, (_, i) => (
      <ProductCardSkeleton priority={i < 8} />
    ))
  }
</div>

<!-- No Results State (for client-side mode only) -->
<div
  id="no-results"
  class="hidden flex-col justify-center items-center col-span-full py-16 text-center"
>
  <div class="text-center">
    <div class="text-6xl mb-4 opacity-20">üîç</div>
    <h2 class="text-2xl font-display font-bold text-(--content-heading) mb-2">
      No products found
    </h2>
    <p class="text-(--content-meta) mb-6 max-w-md mx-auto">
      Try adjusting your filters or browse all products.
    </p>
    <a
      href={categoryPath}
      class="font-sans font-semibold text-sm text-center lg:text-base py-2 px-3 lg:py-2 lg:px-4 border-2 rounded-[4px] text-(--ui-button-text) bg-(--ui-button-surface) border-(--ui-button-border) hover:bg-(--ui-button-surface)/75 outline-0 focus-visible:ring focus-visible:ring-offset-2 focus-visible:ring-(--ui-button-ring) transition-all ease-in-out duration-300"
    >
      Clear Filters
    </a>
  </div>
</div>

<script>
  // Animation configuration
  const ANIMATION_CONFIG = {
    staggerDelay: parseInt(getComputedStyle(document.documentElement)
      .getPropertyValue('--card-stagger-delay')) || 50,
    duration: parseInt(getComputedStyle(document.documentElement)
      .getPropertyValue('--card-transition-duration').replace('s', '')) * 1000 || 300
  };

  // Page load entrance animations with stagger
  function initializePageLoadAnimations() {
    const cards = document.querySelectorAll('.product-card-wrapper.opacity-0');
    if (!cards.length) return;

    const observer = new IntersectionObserver((entries) => {
      entries.forEach((entry) => {
        if (entry.isIntersecting) {
          const card = entry.target as HTMLElement;
          const index = parseInt(card.dataset.initialIndex || '0');
          
          // Add animating class for will-change optimization
          card.classList.add('animating');
          
          // Staggered entrance animation
          setTimeout(() => {
            card.classList.remove('opacity-0');
            card.classList.add('opacity-100');
            
            // Remove will-change after animation completes
            setTimeout(() => {
              card.classList.remove('animating');
            }, ANIMATION_CONFIG.duration);
            
          }, index * ANIMATION_CONFIG.staggerDelay);
          
          // Stop observing this card
          observer.unobserve(card);
        }
      });
    }, {
      threshold: 0.1,
      rootMargin: '50px'
    });

    cards.forEach(card => observer.observe(card));
  }

  // Handle filter state restoration
  document.addEventListener("astro:page-load", () => {
    const grid = document.getElementById("filterable-product-grid");
    const isFiltering = sessionStorage.getItem("filtering-in-progress");

    if (isFiltering && grid) {
      // Clear filtering state
      sessionStorage.removeItem("filtering-in-progress");
      
      // Ensure grid is visible
      grid.style.opacity = "1";
      grid.style.transition = "opacity 0.3s ease";
    }
    
    // Initialize page load animations
    initializePageLoadAnimations();
    
    // Initialize infinite scroll
    initializeInfiniteScroll();
    
    // CRITICAL FIX: Signal ProductGrid ready on Astro navigation
    console.log('[ProductGrid] üì° Emitting productGridReady on astro:page-load');
    document.dispatchEvent(new CustomEvent('productGridReady'));
  });

  // SOLUTION: Signal when ProductGrid is ready for filtering
  document.addEventListener("DOMContentLoaded", () => {
    const grid = document.getElementById("filterable-product-grid");
    if (grid && sessionStorage.getItem("filtering-in-progress")) {
      grid.style.opacity = "1";
      sessionStorage.removeItem("filtering-in-progress");
    }
    
    // Initialize infinite scroll
    initializeInfiniteScroll();
    
    // Signal that ProductGrid is loaded and ready
    console.log('[ProductGrid] üì° Emitting productGridReady on DOMContentLoaded');
    document.dispatchEvent(new CustomEvent('productGridReady'));
  });

  function initializeInfiniteScroll() {
    const grid = document.getElementById("filterable-product-grid");
    const trigger = document.getElementById("infinite-scroll-trigger");
    
    if (!grid || !trigger) return;
    
    // Get all product cards (including hidden ones)
    const allCards = Array.from(grid.querySelectorAll('.product-card-wrapper'));
    let visibleCount = 24; // Start with first 24 visible
    
    // Check if we have more than 24 products
    if (allCards.length <= 24) {
      trigger.style.display = 'none';
      return;
    }
    
    // Show trigger if there are more products
    trigger.style.display = 'flex';
    // ProductFilters.astro handles infinite scroll
    console.log(`[ProductGrid] Ready - ${allCards.length} products available for filtering`);
  }
</script>
