---
// src/components/ProductGrid.astro - Enhanced with batch inventory optimization
import ProductCard from "./ProductCard.astro";
import ProductCardSkeleton from "./ProductCardSkeleton.astro";
import type { Product, ProductWithInventory } from "@/lib/square/types";
import { batchInventoryService } from "@/lib/square/batchInventory";

interface Props {
  products: Product[];
  allProducts?: Product[]; // All products for client-side filtering
  categoryPath?: string;
  skipInventoryCheck?: boolean;
}

const {
  products,
  allProducts,
  categoryPath = "",
  skipInventoryCheck = false,
} = Astro.props;

console.log("[ProductGrid] üìä Props analysis:", {
  productsCount: products?.length || 0,
  allProductsCount: allProducts?.length || 0,
  categoryPath,
  sampleProducts:
    products?.slice(0, 3).map((p) => ({ id: p.id, brand: p.brand })) || [],
});

// FIXED: Separate rendering products from inventory checking products
// - products: What to render (server-filtered for mobile, all for desktop)
// - allProducts: What to use for client-side filtering data

// For rendering: always use the products prop (server-filtered)
const initialProducts = products; // Products to show immediately

// For inventory checking: check inventory for all products that might be needed
const inventoryCheckProducts =
  allProducts && allProducts.length > 0 ? allProducts : products; // Products for inventory batch check

console.log("[ProductGrid] üéØ FIXED: Rendering vs Inventory logic:", {
  initialProducts: initialProducts?.length || 0,
  inventoryCheckProducts: inventoryCheckProducts?.length || 0,
  renderingFiltered: initialProducts !== inventoryCheckProducts,
});

// Batch inventory check for all products that will be displayed
let productsWithInventory: ProductWithInventory[] = initialProducts;
let allProductsWithInventory: ProductWithInventory[] = allProducts || [];

if (!skipInventoryCheck && inventoryCheckProducts.length > 0) {
  try {
    // Check inventory for all products (for efficiency)
    const variationIds = inventoryCheckProducts
      .map((p) => p.variationId)
      .filter(Boolean);
    const inventoryMap =
      await batchInventoryService.getBatchInventoryStatus(variationIds);

    // Apply inventory to products we're rendering (server-filtered)
    productsWithInventory = initialProducts.map((product) => {
      const inventoryStatus = inventoryMap.get(product.variationId) || {
        isOutOfStock: false,
        hasLimitedOptions: false,
        totalQuantity: 0,
      };

      return {
        ...product,
        inventoryStatus,
      };
    });

    // FIXED: Also apply inventory to ALL products for client-side filtering
    allProductsWithInventory = inventoryCheckProducts.map((product) => {
      const inventoryStatus = inventoryMap.get(product.variationId) || {
        isOutOfStock: false,
        hasLimitedOptions: false,
        totalQuantity: 0,
      };

      return {
        ...product,
        inventoryStatus,
      };
    });

    console.log("[ProductGrid] ‚úÖ Inventory applied to both sets:", {
      checkedInventoryFor: inventoryCheckProducts.length,
      appliedToRendered: productsWithInventory.length,
      appliedToAll: allProductsWithInventory.length,
      sampleWithInventory: productsWithInventory.slice(0, 2).map((p) => ({
        id: p.id,
        brand: p.brand,
        isOutOfStock: p.inventoryStatus?.isOutOfStock,
      })),
    });
  } catch (error) {
    console.error("Batch inventory check failed:", error);
    // Fallback: all products assumed in stock
    productsWithInventory = initialProducts.map((product) => ({
      ...product,
      inventoryStatus: {
        isOutOfStock: false,
        hasLimitedOptions: false,
        totalQuantity: 0,
      },
    }));

    allProductsWithInventory = (allProducts || []).map((product) => ({
      ...product,
      inventoryStatus: {
        isOutOfStock: false,
        hasLimitedOptions: false,
        totalQuantity: 0,
      },
    }));
  }
} else {
  console.log(
    "[ProductGrid] ‚ö™ Skipping inventory check or no products to check"
  );
}
---

<style>
  /* Animation Configuration */
  :root {
    --card-transition-duration: 0.3s;
    --card-stagger-delay: 75ms;
    --row-stagger-delay: 150ms;
  }

  /* Responsive optimizations */
  @media (max-width: 1023px) {
    :root {
      --card-transition-duration: 0.2s; /* Faster on mobile */
      --card-stagger-delay: 50ms;
      --row-stagger-delay: 100ms;
    }
  }

  /* Respect reduced motion preferences */
  @media (prefers-reduced-motion: reduce) {
    :root {
      --card-transition-duration: 0.1s;
      --card-stagger-delay: 0ms;
      --row-stagger-delay: 0ms;
    }
  }

  /* SMOOTH FILTERING: Prevent layout shifts with transitions */
  .product-card-wrapper {
    min-height: 280px; /* Minimum card height */
    transform: translate3d(0, 0, 0); /* GPU acceleration */
    
    /* Bidirectional transitions for entry AND exit */
    transition: 
      opacity var(--card-transition-duration) ease,
      transform var(--card-transition-duration) ease;
    
    /* Stagger delay only applies when entering (via --animation-order) */
    transition-delay: 
      calc(var(--animation-order, 0) * var(--card-stagger-delay)),
      calc(var(--animation-order, 0) * var(--card-stagger-delay));
  }

  /* Exit state */
  .product-card-wrapper.opacity-0 {
    opacity: 0;
    transform: scale(0.95) translate3d(0, 10px, 0);
    /* Remove delay on exit for immediate response */
    transition-delay: 0s, 0s;
  }

  /* Entry state */
  .product-card-wrapper.opacity-100 {
    opacity: 1;
    transform: scale(1) translate3d(0, 0, 0);
    /* Delay is inherited from base rule for staggered entrance */
  }

  /* Temporary will-change during animation only */
  .product-card-wrapper.animating {
    will-change: opacity, transform;
  }

  .product-card-wrapper:not(.animating) {
    will-change: auto;
  }

  /* MOBILE INFINITE SCROLL: Better spacing and loading states */
  @media (max-width: 1023px) {
    #infinite-scroll-trigger {
      margin: 1rem 0;
    }
  }

  /* PHASE 5: Stable loading states to prevent layout shifts */
  #filter-loading-overlay {
    contain: layout style paint; /* Full containment for overlay */
  }

  #no-results {
    contain: layout; /* Prevent shifts in no-results state */
  }

  #infinite-scroll-trigger {
    contain: layout; /* Prevent shifts during scroll loading */
  }
</style>

<div
  id="filterable-product-grid"
  role="feed"
  aria-label="Product listings"
  aria-busy="false"
  class="product-grid grid md:grid-cols-2 lg:grid-cols-3 xl:grid-cols-4 2xl:grid-cols-6 gap-2 lg:gap-1 transition-all duration-300"
  data-all-products={JSON.stringify(allProductsWithInventory)}
  data-initial-products={JSON.stringify(productsWithInventory)}
  data-category-path={categoryPath}
  data-product-count={productsWithInventory.length}
>
  {
    productsWithInventory.map((product, index) => {
      // Server-side safe responsive calculation
      // Use a conservative estimate that works across all screen sizes
      const serverSideCardsPerRow = 4; // Safe default for SSR
      const initialRowsToShow = 4;
      const initialCardsToShow = serverSideCardsPerRow * initialRowsToShow; // 16 cards initially

      return (
        <article
          role="article"
          class="product-card-wrapper grid opacity-0"
          aria-labelledby={`product-title-${product.id}`}
          aria-describedby={`product-price-${product.id}`}
          aria-posinset={index + 1}
          aria-setsize={productsWithInventory.length}
          tabindex="-1"
          data-product-id={product.id}
          data-brand={product.brand || ""}
          data-initial-index={index}
          style={
            allProducts && allProducts.length > 0 && index >= initialCardsToShow
              ? "display: none;"
              : ""
          }
        >
          <ProductCard
            product={product}
            priority={index < 8}
            inventoryStatus={product.inventoryStatus}
            skipInventoryCheck={!!product.inventoryStatus}
          />
        </article>
      );
    })
  }

  <!-- Infinite Scroll Trigger -->
  <div
    id="infinite-scroll-trigger"
    class="col-span-full h-20 flex items-center justify-center"
    style="display: none;"
  >
    <div class="flex items-center space-x-3">
      <div
        class="animate-spin rounded-full h-5 w-5 border-2 border-ui-accent border-t-transparent"
      >
      </div>
      <span class="text-(--content-body) font-medium"
        >Loading more products...</span
      >
    </div>
  </div>

  <!-- Load More Button (Progressive Enhancement Fallback) -->
  <div
    id="load-more-container"
    class="col-span-full flex items-center justify-center py-8"
    style="display: none;"
  >
    <button
      id="load-more-button"
      type="button"
      class="font-sans font-semibold text-sm text-center lg:text-base py-3 px-6 lg:py-3 lg:px-8 border-2 rounded-[4px] text-(--ui-button-text) bg-(--ui-button-surface) border-(--ui-button-border) hover:bg-(--ui-button-surface)/75 outline-0 focus-visible:ring focus-visible:ring-offset-2 focus-visible:ring-(--ui-button-ring) transition-all ease-in-out duration-300"
      aria-label="Load more products"
    >
      Load More Products
    </button>
  </div>
</div>

<!-- Enhanced Loading Overlay -->
<div
  id="filter-loading-overlay"
  class="fixed inset-0 bg-(--surface-primary)/60 z-40 flex items-center justify-center"
  style="display: none;"
>
  <div
    class="bg-(--surface-secondary) rounded-lg p-6 shadow-lg flex items-center space-x-3"
  >
    <div
      class="animate-spin rounded-full h-5 w-5 border-2 border-ui-accent border-t-transparent"
    >
    </div>
    <span class="text-(--content-body) font-medium">Applying filters...</span>
  </div>
</div>

<!-- Product Grid Loading Skeleton -->
<div
  id="product-grid-skeleton"
  class="hidden grid-cols-2 md:grid-cols-2 lg:grid-cols-3 xl:grid-cols-4 2xl:grid-cols-6 gap-1"
>
  {
    Array.from({ length: 12 }, (_, i) => (
      <ProductCardSkeleton priority={i < 8} />
    ))
  }
</div>

<!-- No Results State (for client-side mode only) -->
<div
  id="no-results"
  class="hidden flex-col justify-center items-center col-span-full py-16 text-center"
>
  <div class="text-center">
    <div class="text-6xl mb-4 opacity-20">üîç</div>
    <h2 class="text-2xl font-display font-bold text-(--content-heading) mb-2">
      No products found
    </h2>
    <p class="text-(--content-meta) mb-6 max-w-md mx-auto">
      Try adjusting your filters or browse all products.
    </p>
    <a
      href={categoryPath}
      class="font-sans font-semibold text-sm text-center lg:text-base py-2 px-3 lg:py-2 lg:px-4 border-2 rounded-[4px] text-(--ui-button-text) bg-(--ui-button-surface) border-(--ui-button-border) hover:bg-(--ui-button-surface)/75 outline-0 focus-visible:ring focus-visible:ring-offset-2 focus-visible:ring-(--ui-button-ring) transition-all ease-in-out duration-300"
    >
      Clear Filters
    </a>
  </div>
</div>

<script>
  // Check for reduced motion preference
  const prefersReducedMotion = window.matchMedia(
    "(prefers-reduced-motion: reduce)"
  ).matches;

  // PHASE 5: Properly parse animation timing from CSS custom properties
  function getAnimationTiming() {
    const style = getComputedStyle(document.documentElement);

    // Parse duration (handles "0.3s", "300ms", etc.)
    const durationStr = style
      .getPropertyValue("--card-transition-duration")
      .trim();
    let duration = 300; // default
    if (durationStr.includes("ms")) {
      duration = parseInt(durationStr.replace("ms", ""));
    } else if (durationStr.includes("s")) {
      duration = parseFloat(durationStr.replace("s", "")) * 1000;
    }

    // Parse stagger delay (handles "50ms", "0ms", etc.)
    const staggerStr = style.getPropertyValue("--card-stagger-delay").trim();
    const staggerDelay = parseInt(staggerStr.replace("ms", "")) || 0;

    // Parse row stagger delay
    const rowStaggerStr = style.getPropertyValue("--row-stagger-delay").trim();
    const rowStaggerDelay = parseInt(rowStaggerStr.replace("ms", "")) || 0;

    return {
      duration: duration || 300,
      staggerDelay: staggerDelay,
      rowStaggerDelay: rowStaggerDelay,
    };
  }

  // Animation configuration
  const ANIMATION_CONFIG = getAnimationTiming();

  // Simplified page load entrance animations using CSS
  function initializePageLoadAnimations() {
    // FIXED: Only animate cards that are initially visible (no display: none style)
    const cards = document.querySelectorAll(".product-card-wrapper.opacity-0");
    const visibleCards = Array.from(cards).filter((card) => {
      const htmlCard = card as HTMLElement;
      return htmlCard.style.display !== "none";
    });

    if (!visibleCards.length) return;

    // Skip animations if reduced motion preferred
    if (prefersReducedMotion) {
      visibleCards.forEach((card) => {
        const htmlCard = card as HTMLElement;
        htmlCard.classList.remove("opacity-0");
        htmlCard.classList.add("opacity-100");
      });
      return;
    }

    // Calculate cards per row for row-based animation order
    function getCardsPerRow() {
      const width = window.innerWidth;
      if (width >= 1536) return 6; // 2xl:grid-cols-6
      if (width >= 1280) return 4; // xl:grid-cols-4
      if (width >= 1024) return 3; // lg:grid-cols-3
      if (width >= 768) return 2; // md:grid-cols-2
      return 2; // fallback
    }

    const cardsPerRow = getCardsPerRow();

    const observer = new IntersectionObserver(
      (entries) => {
        entries.forEach((entry) => {
          if (entry.isIntersecting) {
            const card = entry.target as HTMLElement;
            const index = parseInt(card.dataset.initialIndex || "0");
            const rowIndex = Math.floor(index / cardsPerRow);
            const cardInRow = index % cardsPerRow;

            // Calculate animation order combining row and card position
            // Row stagger is more significant (2x multiplier)
            const animationOrder = rowIndex * 2 + cardInRow * 0.5;

            // Set CSS custom property for animation delay
            card.style.setProperty(
              "--animation-order",
              animationOrder.toString()
            );

            // Add animating class for temporary will-change
            card.classList.add("animating");

            // Trigger CSS animation
            card.classList.remove("opacity-0");
            card.classList.add("opacity-100");

            // Remove will-change after animation completes
            const duration = ANIMATION_CONFIG.duration;
            const totalAnimationTime =
              duration + animationOrder * ANIMATION_CONFIG.staggerDelay;

            const timeout = setTimeout(() => {
              card.classList.remove("animating");
            }, totalAnimationTime);
            animationTimeouts.push(timeout);

            // Stop observing this card
            observer.unobserve(card);
          }
        });
      },
      {
        threshold: 0.1,
        rootMargin: "200px", // PHASE 5: Increased from 50px for better scroll performance
      }
    );

    // Store observer globally for cleanup
    pageLoadObserver = observer;
    visibleCards.forEach((card) => observer.observe(card));
  }

  // SIMPLE: Initialize on page load (prevent dual initialization)
  document.addEventListener("astro:page-load", () => {
    if (isInitialized) return;
    isInitialized = true;

    const grid = document.getElementById("filterable-product-grid");
    if (grid) {
      grid.style.opacity = "1";
    }

    // Initialize animations FIRST, then infinite scroll
    // This creates the pageLoadObserver that infinite scroll will use
    initializePageLoadAnimations();
    initializeInfiniteScroll(); // Will add newly revealed cards to observer

    console.log("[ProductGrid] üì° Simple initialization complete");
    document.dispatchEvent(new CustomEvent("productGridReady"));
  });

  // Initialize on DOMContentLoaded as fallback
  document.addEventListener("DOMContentLoaded", () => {
    if (isInitialized) return;
    isInitialized = true;

    // Initialize animations FIRST, then infinite scroll
    initializePageLoadAnimations();
    initializeInfiniteScroll(); // Will add newly revealed cards to observer
    
    console.log("[ProductGrid] üì° DOMContentLoaded initialization complete");
    document.dispatchEvent(new CustomEvent("productGridReady"));
  });

  // BACK TO BASICS: Simple infinite scroll without complex logic
  function initializeInfiniteScroll() {
    const grid = document.getElementById("filterable-product-grid");
    const trigger = document.getElementById("infinite-scroll-trigger");

    if (!grid || !trigger) {
      console.log("[ProductGrid] ‚ùå Missing grid or trigger element");
      return;
    }

    // Create ARIA live region for screen reader announcements
    liveRegion = document.createElement("div");
    liveRegion.setAttribute("role", "status");
    liveRegion.setAttribute("aria-live", "polite");
    liveRegion.setAttribute("aria-atomic", "true");
    liveRegion.className = "sr-only";
    liveRegion.style.position = "absolute";
    liveRegion.style.left = "-10000px";
    liveRegion.style.width = "1px";
    liveRegion.style.height = "1px";
    liveRegion.style.overflow = "hidden";
    document.body.appendChild(liveRegion);

    function announceToScreenReader(message: string) {
      if (liveRegion) {
        liveRegion.textContent = message;
        // Clear after announcement
        setTimeout(() => {
          if (liveRegion) liveRegion.textContent = "";
        }, 1000);
      }
    }

    const allCards = Array.from(grid.querySelectorAll(".product-card-wrapper"));
    console.log(
      `[ProductGrid] üîç Simple infinite scroll for ${allCards.length} products`
    );

    // Progressive enhancement check
    const supportsIntersectionObserver = "IntersectionObserver" in window;
    const loadMoreContainer = document.getElementById("load-more-container");
    const loadMoreButton = document.getElementById("load-more-button");

    // Check if we should use accessible mode (no IntersectionObserver)
    // DEV ONLY: Support ?test-button=1 for testing button mode
    const urlParams = new URLSearchParams(window.location.search);
    const forceButtonMode = urlParams.has("test-button") && import.meta.env.DEV;
    const useAccessibleMode = !supportsIntersectionObserver || forceButtonMode;

    if (forceButtonMode) {
      console.log(
        "[ProductGrid] üß™ Button mode forced via URL parameter (DEV ONLY)"
      );
    }

    // Simple grid calculation - match server-side
    function getCardsPerRow() {
      const width = window.innerWidth;
      if (width >= 1536) return 6; // 2xl
      if (width >= 1280) return 4; // xl
      if (width >= 1024) return 3; // lg
      if (width >= 768) return 2; // md
      return 2; // base
    }

    // Adaptive batch size calculation based on viewport
    function calculateAdaptiveBatchSize() {
      const viewportHeight = window.innerHeight;
      const viewportWidth = window.innerWidth;
      const minCardHeight = 280; // From CSS min-height
      const cardsPerRow = getCardsPerRow();

      // Calculate how many rows fit in viewport
      const visibleRows = Math.ceil(viewportHeight / minCardHeight);

      // Buffer: 1.5x viewport for smooth scrolling
      const bufferRows = Math.ceil(visibleRows * 1.5);
      const totalRows = visibleRows + bufferRows;

      // Calculate total items
      let batchSize = totalRows * cardsPerRow;

      // Apply device-specific constraints
      if (viewportWidth < 768) {
        // Mobile: smaller batches for memory
        batchSize = Math.max(Math.min(batchSize, 12), 8);
      } else if (viewportWidth < 1440) {
        // Desktop: balanced approach
        batchSize = Math.max(Math.min(batchSize, 36), 18);
      } else {
        // Ultra-wide/4K: ensure scrollability cSpell:ignore scrollability
        batchSize = Math.max(Math.min(batchSize, 60), 30);
      }

      console.log("[ProductGrid] üìê Adaptive batch:", {
        viewport: `${viewportWidth}x${viewportHeight}`,
        cardsPerRow,
        visibleRows,
        bufferRows,
        batchSize,
      });

      return batchSize;
    }

    const cardsPerRow = getCardsPerRow();
    const initialBatchSize = calculateAdaptiveBatchSize();
    let visibleCount = initialBatchSize;

    // Show initial cards, hide the rest
    const cardsToAnimate: HTMLElement[] = [];
    allCards.forEach((card, index) => {
      const htmlCard = card as HTMLElement;
      if (index < visibleCount) {
        htmlCard.style.display = "";
        // If this card has opacity-0, it needs to be animated
        if (htmlCard.classList.contains("opacity-0")) {
          cardsToAnimate.push(htmlCard);
        }
      } else {
        htmlCard.style.display = "none";
      }
    });

    // Add newly revealed cards to the page load observer
    if (pageLoadObserver && cardsToAnimate.length > 0) {
      console.log(`[ProductGrid] üé¨ Adding ${cardsToAnimate.length} cards to animation observer`);
      cardsToAnimate.forEach(card => {
        pageLoadObserver?.observe(card);
      });
    }

    // Check if infinite scroll is needed
    if (allCards.length <= visibleCount) {
      trigger.style.display = "none";
      if (loadMoreContainer) loadMoreContainer.style.display = "none";
      console.log("[ProductGrid] ‚úÖ All products fit on screen");
      return;
    }

    // Function to load more cards
    function loadMoreCards() {
      // Use fixed increment for infinite scroll (not adaptive)
      // Adaptive sizing is only for initial load
      const cardsToAdd = cardsPerRow * 2;
      const newVisibleCount = Math.min(
        visibleCount + cardsToAdd,
        allCards.length
      );

      // Track the starting index for this batch for proper animation timing
      const batchStartIndex = visibleCount;

      // Show the new cards
      for (let i = visibleCount; i < newVisibleCount; i++) {
        if (allCards[i]) {
          const card = allCards[i] as HTMLElement;
          card.style.display = "";
          card.classList.remove("opacity-100");
          card.classList.add("opacity-0");

          // Store batch-relative index for animation timing
          card.dataset.batchIndex = String(i - batchStartIndex);

          // Add to animation observer for smooth animations (both modes)
          if (cardAnimationObserver) {
            cardAnimationObserver.observe(card);
          } else {
            // Fallback immediate display
            card.classList.remove("opacity-0");
            card.classList.add("opacity-100");
          }
        }
      }

      visibleCount = newVisibleCount;
      console.log(
        `[ProductGrid] Now showing ${visibleCount}/${allCards.length}`
      );

      // Announce to screen readers
      announceToScreenReader(
        `Loaded ${cardsToAdd} more products. ${visibleCount} of ${allCards.length} total products shown.`
      );

      // Update grid aria-busy state
      if (grid) grid.setAttribute("aria-busy", "false");

      // Hide controls when done
      if (visibleCount >= allCards.length) {
        if (trigger) trigger.style.display = "none";
        if (loadMoreContainer) loadMoreContainer.style.display = "none";
        console.log("[ProductGrid] ‚úÖ All products loaded");
        announceToScreenReader(`All ${allCards.length} products loaded.`);
      }
    }

    // Create animation observer for both modes (infinite scroll and button)
    // MUST be created before mode branching
    cardAnimationObserver = new IntersectionObserver(
      (entries) => {
        entries.forEach((entry) => {
          if (entry.isIntersecting) {
            const card = entry.target as HTMLElement;

            // Skip animations if reduced motion preferred
            if (prefersReducedMotion) {
              card.classList.remove("opacity-0");
              card.classList.add("opacity-100");
              if (cardAnimationObserver) cardAnimationObserver.unobserve(card);
              return;
            }

            // Use batch-relative index if available (for newly loaded cards via button/infinite scroll)
            // Otherwise calculate from batch (for initial page load)
            let cardIndexForAnimation;
            if (card.dataset.batchIndex !== undefined) {
              cardIndexForAnimation = parseInt(card.dataset.batchIndex);
            } else {
              const index = parseInt(card.dataset.initialIndex || "0");
              const cardsPerRow = getCardsPerRow();
              const batchStartIndex =
                Math.floor(index / (cardsPerRow * 2)) * (cardsPerRow * 2);
              cardIndexForAnimation = index - batchStartIndex;
            }

            const cardsPerRow = getCardsPerRow();
            const rowIndex = Math.floor(cardIndexForAnimation / cardsPerRow);
            const cardInRow = cardIndexForAnimation % cardsPerRow;

            // Calculate animation order combining row and card position
            // Row stagger is more significant (2x multiplier)
            const animationOrder = rowIndex * 2 + cardInRow * 0.5;

            // Set CSS custom property for animation delay
            card.style.setProperty(
              "--animation-order",
              animationOrder.toString()
            );

            // Add animating class for temporary will-change
            card.classList.add("animating");

            // Trigger CSS animation
            card.classList.remove("opacity-0");
            card.classList.add("opacity-100");

            // Remove will-change after animation completes
            const duration = ANIMATION_CONFIG.duration;
            const totalAnimationTime =
              duration + animationOrder * ANIMATION_CONFIG.staggerDelay;

            const timeout = setTimeout(() => {
              card.classList.remove("animating");
            }, totalAnimationTime);
            animationTimeouts.push(timeout);

            // Stop observing this card
            if (cardAnimationObserver) cardAnimationObserver.unobserve(card);
          }
        });
      },
      {
        threshold: 0.1,
        rootMargin: "200px", // PHASE 5: Increased from 50px for better scroll performance
      }
    );

    // Use Load More button for accessible mode
    if (useAccessibleMode) {
      if (loadMoreContainer && loadMoreButton) {
        loadMoreContainer.style.display = "flex";
        trigger.style.display = "none";

        loadMoreButton.addEventListener("click", () => {
          if (grid) grid.setAttribute("aria-busy", "true");
          loadMoreButton.textContent = "Loading...";
          loadMoreButton.setAttribute("disabled", "true");

          // Small delay to show loading state (track timeout)
          const buttonTimeout = setTimeout(() => {
            loadMoreCards();
            loadMoreButton.textContent = "Load More Products";
            loadMoreButton.removeAttribute("disabled");
          }, 100);
          animationTimeouts.push(buttonTimeout);
        });

        console.log(
          "[ProductGrid] ‚úÖ Load More button initialized (accessible mode)"
        );
      }
      return;
    }

    // Standard infinite scroll mode
    trigger.style.display = "flex";
    if (loadMoreContainer) loadMoreContainer.style.display = "none";
    console.log(
      `[ProductGrid] ‚úÖ Showing ${visibleCount}/${allCards.length} initially`
    );

    // PHASE 5: Debounced load more to prevent rapid-fire loading
    let isLoading = false;
    let loadTimeout: ReturnType<typeof setTimeout> | null = null;

    // SIMPLE: Basic intersection observer for loading more cards
    loadMoreObserver = new IntersectionObserver(
      (entries) => {
        entries.forEach((entry) => {
          if (
            entry.isIntersecting &&
            visibleCount < allCards.length &&
            !isLoading
          ) {
            // Debounce to prevent rapid loading
            if (loadTimeout) {
              clearTimeout(loadTimeout);
              const index = animationTimeouts.indexOf(loadTimeout);
              if (index > -1) animationTimeouts.splice(index, 1);
            }

            loadTimeout = setTimeout(() => {
              isLoading = true;
              if (grid) grid.setAttribute("aria-busy", "true");
              console.log("[ProductGrid] Loading more...");

              loadMoreCards();
              isLoading = false;
            }, 100); // PHASE 5: 100ms debounce delay
            animationTimeouts.push(loadTimeout);
          }
        });
      },
      { threshold: 0.1, rootMargin: "200px" } // PHASE 5: Increased from 100px
    );

    if (loadMoreObserver && trigger) loadMoreObserver.observe(trigger);
    console.log("[ProductGrid] ‚úÖ Simple infinite scroll initialized");

    // Dispatch event to signal grid is ready (eliminates polling in ProductFilters)
    window.dispatchEvent(
      new CustomEvent("product-grid-ready", {
        detail: { productCount: allCards.length },
      })
    );
    console.log("[ProductGrid] üéØ Grid ready event dispatched");
  }

  // Debounced resize handler for responsive animations
  let resizeTimeout: ReturnType<typeof setTimeout>;
  function handleResize() {
    clearTimeout(resizeTimeout);
    resizeTimeout = setTimeout(() => {
      // PHASE 5: Recalculate animation config on resize using proper parsing
      const newConfig = getAnimationTiming();
      ANIMATION_CONFIG.staggerDelay = newConfig.staggerDelay;
      ANIMATION_CONFIG.rowStaggerDelay = newConfig.rowStaggerDelay;
      ANIMATION_CONFIG.duration = newConfig.duration;

      console.log("[ProductGrid] üìê Animation config updated for new viewport");
    }, 250); // Debounce 250ms
  }

  window.addEventListener("resize", handleResize);

  // Store observers for cleanup
  let cardAnimationObserver: IntersectionObserver | null = null;
  let loadMoreObserver: IntersectionObserver | null = null;
  let liveRegion: HTMLElement | null = null;
  let pageLoadObserver: IntersectionObserver | null = null; // NEW: Store page load observer
  let animationTimeouts: ReturnType<typeof setTimeout>[] = []; // NEW: Track timeouts
  let isInitialized = false; // NEW: Prevent dual initialization

  // Cleanup on navigation
  document.addEventListener("astro:before-swap", () => {
    window.removeEventListener("resize", handleResize);
    clearTimeout(resizeTimeout);

    // Clean up observers to prevent memory leaks
    if (cardAnimationObserver) {
      cardAnimationObserver.disconnect();
      cardAnimationObserver = null;
    }
    if (loadMoreObserver) {
      loadMoreObserver.disconnect();
      loadMoreObserver = null;
    }
    if (pageLoadObserver) {
      pageLoadObserver.disconnect();
      pageLoadObserver = null;
    }

    // Clean up live region
    if (liveRegion && liveRegion.parentNode) {
      liveRegion.parentNode.removeChild(liveRegion);
      liveRegion = null;
    }

    // Clear all pending timeouts
    animationTimeouts.forEach((timeout) => clearTimeout(timeout));
    animationTimeouts = [];

    // Reset initialization flag
    isInitialized = false;
  });
</script>
