---
// src/components/ProductGrid.astro - Enhanced with batch inventory optimization
import ProductCard from "./ProductCard.astro";
import ProductCardSkeleton from "./ProductCardSkeleton.astro";
import type { Product, ProductWithInventory } from "@/lib/square/types";
import { batchInventoryService } from "@/lib/square/batchInventory";

interface Props {
  products: Product[];
  allProducts?: Product[]; // All products for client-side filtering
  categoryPath?: string;
  skipInventoryCheck?: boolean;
}

const {
  products,
  allProducts,
  categoryPath = "",
  skipInventoryCheck = false,
} = Astro.props;

console.log("[ProductGrid] üìä Props analysis:", {
  productsCount: products?.length || 0,
  allProductsCount: allProducts?.length || 0,
  categoryPath,
  sampleProducts:
    products?.slice(0, 3).map((p) => ({ id: p.id, brand: p.brand })) || [],
});

// FIXED: Separate rendering products from inventory checking products
// - products: What to render (server-filtered for mobile, all for desktop)
// - allProducts: What to use for client-side filtering data

// For rendering: always use the products prop (server-filtered)
const initialProducts = products; // Products to show immediately

// For inventory checking: check inventory for all products that might be needed
const inventoryCheckProducts =
  allProducts && allProducts.length > 0 ? allProducts : products; // Products for inventory batch check

console.log("[ProductGrid] üéØ FIXED: Rendering vs Inventory logic:", {
  initialProducts: initialProducts?.length || 0,
  inventoryCheckProducts: inventoryCheckProducts?.length || 0,
  renderingFiltered: initialProducts !== inventoryCheckProducts,
});

// Batch inventory check for all products that will be displayed
let productsWithInventory: ProductWithInventory[] = initialProducts;
let allProductsWithInventory: ProductWithInventory[] = allProducts || [];

if (!skipInventoryCheck && inventoryCheckProducts.length > 0) {
  try {
    // Check inventory for all products (for efficiency)
    const variationIds = inventoryCheckProducts
      .map((p) => p.variationId)
      .filter(Boolean);
    const inventoryMap =
      await batchInventoryService.getBatchInventoryStatus(variationIds);

    // Apply inventory to products we're rendering (server-filtered)
    productsWithInventory = initialProducts.map((product) => {
      const inventoryStatus = inventoryMap.get(product.variationId) || {
        isOutOfStock: false,
        hasLimitedOptions: false,
        totalQuantity: 0,
      };

      return {
        ...product,
        inventoryStatus,
      };
    });

    // FIXED: Also apply inventory to ALL products for client-side filtering
    allProductsWithInventory = inventoryCheckProducts.map((product) => {
      const inventoryStatus = inventoryMap.get(product.variationId) || {
        isOutOfStock: false,
        hasLimitedOptions: false,
        totalQuantity: 0,
      };

      return {
        ...product,
        inventoryStatus,
      };
    });

    console.log("[ProductGrid] ‚úÖ Inventory applied to both sets:", {
      checkedInventoryFor: inventoryCheckProducts.length,
      appliedToRendered: productsWithInventory.length,
      appliedToAll: allProductsWithInventory.length,
      sampleWithInventory: productsWithInventory.slice(0, 2).map((p) => ({
        id: p.id,
        brand: p.brand,
        isOutOfStock: p.inventoryStatus?.isOutOfStock,
      })),
    });
  } catch (error) {
    console.error("Batch inventory check failed:", error);
    // Fallback: all products assumed in stock
    productsWithInventory = initialProducts.map((product) => ({
      ...product,
      inventoryStatus: {
        isOutOfStock: false,
        hasLimitedOptions: false,
        totalQuantity: 0,
      },
    }));

    allProductsWithInventory = (allProducts || []).map((product) => ({
      ...product,
      inventoryStatus: {
        isOutOfStock: false,
        hasLimitedOptions: false,
        totalQuantity: 0,
      },
    }));
  }
} else {
  console.log(
    "[ProductGrid] ‚ö™ Skipping inventory check or no products to check"
  );
}
---

<style>
  /* Animation Configuration */
  :root {
    --card-transition-duration: 0.3s;
    --card-stagger-delay: 75ms;
    --row-stagger-delay: 150ms;
  }

  /* Responsive optimizations */
  @media (max-width: 1023px) {
    :root {
      --card-transition-duration: 0.2s; /* Faster on mobile */
      --card-stagger-delay: 50ms;
      --row-stagger-delay: 100ms;
    }
  }

  /* Respect reduced motion preferences */
  @media (prefers-reduced-motion: reduce) {
    :root {
      --card-transition-duration: 0.1s;
      --card-stagger-delay: 0ms;
      --row-stagger-delay: 0ms;
    }
  }

  /* PHASE 5: Layout Shift Prevention */
  .product-grid {
    contain: layout; /* Prevent external layout shifts */
    min-height: 400px; /* Reserve space during filtering */
  }

  /* SMOOTH FILTERING: Prevent layout shifts with opacity transitions */
  .product-card-wrapper {
    transition:
      opacity var(--card-transition-duration) ease,
      transform var(--card-transition-duration) ease;
    will-change: opacity, transform;
    transform: translate3d(0, 0, 0); /* GPU acceleration */
    min-height: 280px; /* Minimum card height */
  }

  .product-card-wrapper.opacity-0 {
    opacity: 0;
    transform: scale(0.95) translate3d(0, 10px, 0);
  }

  .product-card-wrapper.opacity-100 {
    opacity: 1;
    transform: scale(1) translate3d(0, 0, 0);
  }

  /* Animation states for different scenarios */
  .product-card-wrapper.animating {
    will-change: opacity, transform;
  }

  .product-card-wrapper:not(.animating) {
    will-change: auto;
  }

  /* MOBILE INFINITE SCROLL: Better spacing and loading states */
  @media (max-width: 1023px) {
    #infinite-scroll-trigger {
      margin: 1rem 0;
    }
  }

  /* PHASE 5: Stable loading states to prevent layout shifts */
  #filter-loading-overlay {
    contain: layout style paint; /* Full containment for overlay */
  }

  #product-grid-skeleton {
    contain: layout; /* Prevent shifts when skeleton shows */
    min-height: 400px;
  }

  #no-results {
    contain: layout; /* Prevent shifts in no-results state */
    min-height: 400px;
  }

  #infinite-scroll-trigger {
    contain: layout; /* Prevent shifts during scroll loading */
  }
</style>

<div
  id="filterable-product-grid"
  role="feed"
  aria-label="Product listings"
  aria-busy="false"
  class="product-grid grid md:grid-cols-2 lg:grid-cols-3 xl:grid-cols-4 2xl:grid-cols-6 gap-2 lg:gap-1 transition-all duration-300"
  data-all-products={JSON.stringify(allProductsWithInventory)}
  data-initial-products={JSON.stringify(productsWithInventory)}
  data-category-path={categoryPath}
  data-product-count={productsWithInventory.length}
>
  {
    productsWithInventory.map((product, index) => {
      // Server-side safe responsive calculation
      // Use a conservative estimate that works across all screen sizes
      const serverSideCardsPerRow = 4; // Safe default for SSR
      const initialRowsToShow = 4;
      const initialCardsToShow = serverSideCardsPerRow * initialRowsToShow; // 16 cards initially

      return (
        <article
          role="article"
          class="product-card-wrapper grid opacity-0"
          aria-labelledby={`product-title-${product.id}`}
          aria-describedby={`product-price-${product.id}`}
          aria-posinset={index + 1}
          aria-setsize={productsWithInventory.length}
          tabindex="-1"
          data-product-id={product.id}
          data-brand={product.brand || ""}
          data-initial-index={index}
          style={
            allProducts && allProducts.length > 0 && index >= initialCardsToShow
              ? "display: none;"
              : ""
          }
        >
          <ProductCard
            product={product}
            priority={index < 8}
            inventoryStatus={product.inventoryStatus}
            skipInventoryCheck={!!product.inventoryStatus}
          />
        </article>
      );
    })
  }

  <!-- Infinite Scroll Trigger -->
  <div
    id="infinite-scroll-trigger"
    class="col-span-full h-20 flex items-center justify-center"
    style="display: none;"
  >
    <div class="flex items-center space-x-3">
      <div
        class="animate-spin rounded-full h-5 w-5 border-2 border-ui-accent border-t-transparent"
      >
      </div>
      <span class="text-(--content-body) font-medium"
        >Loading more products...</span
      >
    </div>
  </div>
</div>

<!-- Enhanced Loading Overlay -->
<div
  id="filter-loading-overlay"
  class="fixed inset-0 bg-(--surface-primary)/60 backdrop-blur-sm z-40 flex items-center justify-center"
  style="display: none;"
>
  <div
    class="bg-(--surface-secondary) rounded-lg p-6 shadow-lg flex items-center space-x-3"
  >
    <div
      class="animate-spin rounded-full h-5 w-5 border-2 border-ui-accent border-t-transparent"
    >
    </div>
    <span class="text-(--content-body) font-medium">Applying filters...</span>
  </div>
</div>

<!-- Product Grid Loading Skeleton -->
<div
  id="product-grid-skeleton"
  class="hidden grid-cols-2 md:grid-cols-2 lg:grid-cols-3 xl:grid-cols-4 2xl:grid-cols-6 gap-1"
>
  {
    Array.from({ length: 12 }, (_, i) => (
      <ProductCardSkeleton priority={i < 8} />
    ))
  }
</div>

<!-- No Results State (for client-side mode only) -->
<div
  id="no-results"
  class="hidden flex-col justify-center items-center col-span-full py-16 text-center"
>
  <div class="text-center">
    <div class="text-6xl mb-4 opacity-20">üîç</div>
    <h2 class="text-2xl font-display font-bold text-(--content-heading) mb-2">
      No products found
    </h2>
    <p class="text-(--content-meta) mb-6 max-w-md mx-auto">
      Try adjusting your filters or browse all products.
    </p>
    <a
      href={categoryPath}
      class="font-sans font-semibold text-sm text-center lg:text-base py-2 px-3 lg:py-2 lg:px-4 border-2 rounded-[4px] text-(--ui-button-text) bg-(--ui-button-surface) border-(--ui-button-border) hover:bg-(--ui-button-surface)/75 outline-0 focus-visible:ring focus-visible:ring-offset-2 focus-visible:ring-(--ui-button-ring) transition-all ease-in-out duration-300"
    >
      Clear Filters
    </a>
  </div>
</div>

<script>
  // Check for reduced motion preference
  const prefersReducedMotion = window.matchMedia(
    "(prefers-reduced-motion: reduce)"
  ).matches;

  // Animation state management
  // NOTE: This animation queue handles PRODUCT CARD animations only
  // Navigation animations are handled by mobileOptimization.ts
  const animationQueue = {
    running: false,
    pending: [] as (() => void)[],

    async run(animationFn: () => void) {
      if (prefersReducedMotion) {
        // Skip animations entirely for reduced motion
        animationFn();
        return;
      }

      this.pending.push(animationFn);

      if (!this.running) {
        this.running = true;
        while (this.pending.length > 0) {
          const fn = this.pending.shift();
          if (fn)
            await new Promise((resolve) => {
              fn();
              // Small delay between queued animations
              setTimeout(resolve, 50);
            });
        }
        this.running = false;
      }
    },
  };

  // PHASE 5: Properly parse animation timing from CSS custom properties
  function getAnimationTiming() {
    const style = getComputedStyle(document.documentElement);
    
    // Parse duration (handles "0.3s", "300ms", etc.)
    const durationStr = style.getPropertyValue('--card-transition-duration').trim();
    let duration = 300; // default
    if (durationStr.includes('ms')) {
      duration = parseInt(durationStr.replace('ms', ''));
    } else if (durationStr.includes('s')) {
      duration = parseFloat(durationStr.replace('s', '')) * 1000;
    }
    
    // Parse stagger delay (handles "50ms", "0ms", etc.)
    const staggerStr = style.getPropertyValue('--card-stagger-delay').trim();
    const staggerDelay = parseInt(staggerStr.replace('ms', '')) || 0;
    
    // Parse row stagger delay
    const rowStaggerStr = style.getPropertyValue('--row-stagger-delay').trim();
    const rowStaggerDelay = parseInt(rowStaggerStr.replace('ms', '')) || 0;
    
    return {
      duration: duration || 300,
      staggerDelay: staggerDelay,
      rowStaggerDelay: rowStaggerDelay
    };
  }

  // Animation configuration
  const ANIMATION_CONFIG = getAnimationTiming();

  // Enhanced page load entrance animations with combined row + individual card stagger
  function initializePageLoadAnimations() {
    // FIXED: Only animate cards that are initially visible (no display: none style)
    const cards = document.querySelectorAll(".product-card-wrapper.opacity-0");
    const visibleCards = Array.from(cards).filter((card) => {
      const htmlCard = card as HTMLElement;
      return htmlCard.style.display !== "none";
    });

    if (!visibleCards.length) return;

    // Skip animations if reduced motion preferred
    if (prefersReducedMotion) {
      visibleCards.forEach((card) => {
        const htmlCard = card as HTMLElement;
        htmlCard.classList.remove("opacity-0");
        htmlCard.classList.add("opacity-100");
      });
      return;
    }

    // Calculate cards per row for row-based animation
    function getCardsPerRow() {
      const width = window.innerWidth;
      if (width >= 1536) return 6; // 2xl:grid-cols-6
      if (width >= 1280) return 4; // xl:grid-cols-4
      if (width >= 1024) return 3; // lg:grid-cols-3
      if (width >= 768) return 2; // md:grid-cols-2
      return 2; // fallback
    }

    const observer = new IntersectionObserver(
      (entries) => {
        entries.forEach((entry) => {
          if (entry.isIntersecting) {
            animationQueue.run(() => {
              const card = entry.target as HTMLElement;
              const index = parseInt(card.dataset.initialIndex || "0");
              const cardsPerRow = getCardsPerRow();
              const rowIndex = Math.floor(index / cardsPerRow);
              const cardInRow = index % cardsPerRow;

              // Add animating class for will-change optimization
              card.classList.add("animating");

              // Combined stagger: row delay + individual card delay
              const rowStaggerDelay = ANIMATION_CONFIG.rowStaggerDelay;
              const cardStaggerDelay = ANIMATION_CONFIG.staggerDelay;

              const baseRowDelay = rowIndex * rowStaggerDelay;
              const cardDelay = cardInRow * (cardStaggerDelay / 2);
              const totalDelay = baseRowDelay + cardDelay;

              setTimeout(() => {
                card.classList.remove("opacity-0");
                card.classList.add("opacity-100");

                // Remove will-change after animation completes
                setTimeout(() => {
                  card.classList.remove("animating");
                }, ANIMATION_CONFIG.duration);
              }, totalDelay);

              // Stop observing this card
              observer.unobserve(card);
            });
          }
        });
      },
      {
        threshold: 0.1,
        rootMargin: "200px", // PHASE 5: Increased from 50px for better scroll performance
      }
    );

    visibleCards.forEach((card) => observer.observe(card));
  }

  // SIMPLE: Initialize on page load
  document.addEventListener("astro:page-load", () => {
    const grid = document.getElementById("filterable-product-grid");
    if (grid) {
      grid.style.opacity = "1";
    }

    // Initialize animations and infinite scroll
    initializePageLoadAnimations();
    initializeInfiniteScroll();

    console.log("[ProductGrid] üì° Simple initialization complete");
    document.dispatchEvent(new CustomEvent("productGridReady"));
  });

  // Initialize on DOMContentLoaded as well
  document.addEventListener("DOMContentLoaded", () => {
    initializePageLoadAnimations();
    initializeInfiniteScroll();
    console.log("[ProductGrid] üì° DOMContentLoaded initialization complete");
    document.dispatchEvent(new CustomEvent("productGridReady"));
  });

  // BACK TO BASICS: Simple infinite scroll without complex logic
  function initializeInfiniteScroll() {
    const grid = document.getElementById("filterable-product-grid");
    const trigger = document.getElementById("infinite-scroll-trigger");

    if (!grid || !trigger) {
      console.log("[ProductGrid] ‚ùå Missing grid or trigger element");
      return;
    }

    const allCards = Array.from(grid.querySelectorAll(".product-card-wrapper"));
    console.log(
      `[ProductGrid] üîç Simple infinite scroll for ${allCards.length} products`
    );

    // Simple grid calculation - match server-side
    function getCardsPerRow() {
      const width = window.innerWidth;
      if (width >= 1536) return 6; // 2xl
      if (width >= 1280) return 4; // xl
      if (width >= 1024) return 3; // lg
      if (width >= 768) return 2; // md
      return 2; // base
    }

    const cardsPerRow = getCardsPerRow();
    const initialRows = 4;
    let visibleCount = cardsPerRow * initialRows;

    // Show initial cards, hide the rest
    allCards.forEach((card, index) => {
      const htmlCard = card as HTMLElement;
      if (index < visibleCount) {
        htmlCard.style.display = "";
      } else {
        htmlCard.style.display = "none";
      }
    });

    // Check if infinite scroll is needed
    if (allCards.length <= visibleCount) {
      trigger.style.display = "none";
      console.log("[ProductGrid] ‚úÖ All products fit on screen");
      return;
    }

    trigger.style.display = "flex";
    console.log(
      `[ProductGrid] ‚úÖ Showing ${visibleCount}/${allCards.length} initially`
    );

    // Create an IntersectionObserver for infinite scroll card animations
    const cardAnimationObserver = new IntersectionObserver(
      (entries) => {
        entries.forEach((entry) => {
          if (entry.isIntersecting) {
            const card = entry.target as HTMLElement;

            // Skip animations if reduced motion preferred
            if (prefersReducedMotion) {
              card.classList.remove("opacity-0");
              card.classList.add("opacity-100");
              cardAnimationObserver.unobserve(card);
              return;
            }

            animationQueue.run(() => {
              const index = parseInt(card.dataset.initialIndex || "0");
              const cardsPerRow = getCardsPerRow();

              // Calculate animation timing based on the card's position in the newly loaded batch
              // Find the index within the current batch (relative to when it was loaded)
              const batchStartIndex =
                Math.floor(index / (cardsPerRow * 2)) * (cardsPerRow * 2);
              const cardIndexInBatch = index - batchStartIndex;
              const rowIndex = Math.floor(cardIndexInBatch / cardsPerRow);
              const cardInRow = cardIndexInBatch % cardsPerRow;

              // Add animating class for will-change optimization
              card.classList.add("animating");

              // Combined stagger: row delay + individual card delay (same as initial load)
              const rowStaggerDelay = ANIMATION_CONFIG.rowStaggerDelay;
              const cardStaggerDelay = ANIMATION_CONFIG.staggerDelay;

              const baseRowDelay = rowIndex * rowStaggerDelay;
              const cardDelay = cardInRow * (cardStaggerDelay / 2);
              const totalDelay = baseRowDelay + cardDelay;

              setTimeout(() => {
                card.classList.remove("opacity-0");
                card.classList.add("opacity-100");

                // Remove will-change after animation completes
                setTimeout(() => {
                  card.classList.remove("animating");
                }, ANIMATION_CONFIG.duration);
              }, totalDelay);

              // Stop observing this card
              cardAnimationObserver.unobserve(card);
            });
          }
        });
      },
      {
        threshold: 0.1,
        rootMargin: "200px", // PHASE 5: Increased from 50px for better scroll performance
      }
    );

    // PHASE 5: Debounced load more to prevent rapid-fire loading
    let isLoading = false;
    let loadTimeout: ReturnType<typeof setTimeout>;
    
    // SIMPLE: Basic intersection observer for loading more cards
    const loadMoreObserver = new IntersectionObserver(
      (entries) => {
        entries.forEach((entry) => {
          if (entry.isIntersecting && visibleCount < allCards.length && !isLoading) {
            // Debounce to prevent rapid loading
            clearTimeout(loadTimeout);
            loadTimeout = setTimeout(() => {
              isLoading = true;
              console.log("[ProductGrid] Loading more...");

              // Load 2 more rows
              const cardsToAdd = cardsPerRow * 2;
            const newVisibleCount = Math.min(
              visibleCount + cardsToAdd,
              allCards.length
            );

            // Show the new cards but DON'T animate them immediately
            // Let the cardAnimationObserver handle the animation when they come into view
            for (let i = visibleCount; i < newVisibleCount; i++) {
              if (allCards[i]) {
                const card = allCards[i] as HTMLElement;

                // Show the card but keep it in opacity-0 state for animation
                card.style.display = "";
                card.classList.remove("opacity-100");
                card.classList.add("opacity-0");

                // Add to animation observer so it animates when it comes into view
                cardAnimationObserver.observe(card);
              }
            }

            visibleCount = newVisibleCount;
            console.log(
              `[ProductGrid] Now showing ${visibleCount}/${allCards.length}`
            );

            // Hide trigger when done
            if (visibleCount >= allCards.length) {
              trigger.style.display = "none";
              console.log("[ProductGrid] ‚úÖ All products loaded");
            }
            
            isLoading = false;
            }, 100); // PHASE 5: 100ms debounce delay
          }
        });
      },
      { threshold: 0.1, rootMargin: "200px" } // PHASE 5: Increased from 100px
    );

    loadMoreObserver.observe(trigger);
    console.log("[ProductGrid] ‚úÖ Simple infinite scroll initialized");

    // Dispatch event to signal grid is ready (eliminates polling in ProductFilters)
    window.dispatchEvent(
      new CustomEvent("product-grid-ready", {
        detail: { productCount: allCards.length },
      })
    );
    console.log("[ProductGrid] üéØ Grid ready event dispatched");
  }

  // Debounced resize handler for responsive animations
  let resizeTimeout: ReturnType<typeof setTimeout>;
  function handleResize() {
    clearTimeout(resizeTimeout);
    resizeTimeout = setTimeout(() => {
      // PHASE 5: Recalculate animation config on resize using proper parsing
      const newConfig = getAnimationTiming();
      ANIMATION_CONFIG.staggerDelay = newConfig.staggerDelay;
      ANIMATION_CONFIG.rowStaggerDelay = newConfig.rowStaggerDelay;
      ANIMATION_CONFIG.duration = newConfig.duration;

      console.log("[ProductGrid] üìê Animation config updated for new viewport");
    }, 250); // Debounce 250ms
  }

  window.addEventListener("resize", handleResize);

  // Cleanup on navigation
  document.addEventListener("astro:before-swap", () => {
    window.removeEventListener("resize", handleResize);
    clearTimeout(resizeTimeout);
  });
</script>
