---
// src/components/ProductFilters.astro
import type { FilterOptions } from "@/lib/square/types";
import { FilterCoordinator } from "@/lib/filterCoordinator";

interface Props {
  filterOptions: FilterOptions;
  totalProducts: number;
  filteredCount: number;
  categoryPath: string;
}

const {
  filterOptions,
  totalProducts,
  filteredCount,
  categoryPath: _categoryPath,
} = Astro.props;

// Parse current filters from URL for server-side rendering
const currentParams = new URLSearchParams(Astro.url.search);
const currentBrands = currentParams.getAll("brands") || [];
const currentAvailability = currentParams.get("availability") === "true";

// Configuration for show more/less functionality
const DEFAULT_VISIBLE_BRANDS = 6;
const shouldShowToggle = filterOptions.brands.length > DEFAULT_VISIBLE_BRANDS;

// FOUC Fix: Determine initial expanded state server-side
// Check if there are any selected brands beyond the default visible count
const hasSelectedBrandsBelow = currentBrands.some((brand) => {
  const brandIndex = filterOptions.brands.findIndex((b) => b.name === brand);
  return brandIndex >= DEFAULT_VISIBLE_BRANDS;
});

// Start expanded if user has selected brands that would be hidden
const shouldStartExpanded = hasSelectedBrandsBelow;
---

<style is:inline>
  /* Simple transitions only */
  .brand-filter-list {
    transition: none;
  }

  .product-card-wrapper[style*="display: none"] {
    display: none !important;
  }

  /* Disabled state styling for phantom click prevention */
  /* ENHANCED: Phantom click prevention without visual flicker during View Transitions */
  :disabled {
    cursor: not-allowed;
    pointer-events: none;
  }

  /* Only show opacity reduction when not during filtering process */
  body:not(.filtering-in-progress) :disabled {
    opacity: 0.6;
  }

  /* Smooth transition for opacity changes */
  input[type="checkbox"],
  button {
    transition: opacity 0.15s ease;
  }

  /* Disabled button styling - consistent with general disabled styling */
  body:not(.filtering-in-progress) button:disabled {
    opacity: 0.5;
    cursor: not-allowed;
  }

  button:disabled {
    cursor: not-allowed;
    pointer-events: none;
  }

  /* Respect reduced motion for View Transitions */
  @media (prefers-reduced-motion: reduce) {
    html::view-transition-old(root),
    html::view-transition-new(root) {
      animation: none !important;
    }
  }

  /* Screen reader only content */
  .sr-only {
    position: absolute;
    width: 1px;
    height: 1px;
    padding: 0;
    margin: -1px;
    overflow: hidden;
    clip: rect(0, 0, 0, 0);
    white-space: nowrap;
    border: 0;
  }
</style>

<!-- Single Responsive Form Container -->
<div class="relative lg:block bg-(--surface-primary)">
  <!-- Mobile Filter Button -->
  <button
    id="mobile-filter-toggle"
    class="lg:hidden fixed bottom-4 right-4 bg-(--surface-tertiary) text-(--content-body) border border-(--border-tertiary) rounded-md flex flex-row gap-2 p-4 shadow-lg z-250"
    aria-label="Open Filters"
  >
    Filters
    <svg class="w-5 h-5" fill="none" stroke="currentColor" viewBox="0 0 24 24">
      <path
        stroke-linecap="round"
        stroke-linejoin="round"
        stroke-width="2"
        d="M3 4a1 1 0 011-1h16a1 1 0 011 1v2.586a1 1 0 01-.293.707l-6.414 6.414a1 1 0 00-.293.707V17l-4 4v-6.586a1 1 0 00-.293-.707L3.293 7.707A1 1 0 013 7V4z"
      ></path>
    </svg>
    {
      currentBrands.length > 0 && (
        <span class="absolute -top-1 -right-1 bg-(--ui-button-surface) text-(--ui-button-text) font-bold text-sm rounded-full min-w-5 h-5 flex items-center justify-center px-1">
          {currentBrands.length}
        </span>
      )
    }
  </button>

  <!-- Mobile Overlay -->
  <div
    id="mobile-filter-overlay"
    class="lg:hidden fixed inset-0 bg-(--ui-modal-overlay)/90 z-40 opacity-0 pointer-events-none transition-opacity duration-300"
  >
  </div>

  <!-- Single Form - Desktop Static, Mobile Drawer -->
  <div
    id="filter-container"
    class="lg:static lg:transform-none lg:max-h-none fixed bottom-0 left-0 right-0 md:left-auto md:w-md lg:w-auto bg-(--surface-secondary) lg:bg-(--surface-secondary)/0 border-4 border-(--border-tertiary) z-500 max-h-[80vh] overflow-y-auto transform translate-y-full lg:translate-y-0 opacity-0 lg:opacity-100 pointer-events-none lg:pointer-events-auto transition-all duration-300 lg:transition-none"
  >
    <form class="px-4 lg:p-2" id="filter-form">
      <!-- Mobile Header -->
      <div
        class="flex items-center justify-between mb-4 p-6 -mx-4 bg-(--surface-secondary) border-b-4 border-(--border-tertiary) sticky top-0 z-50 lg:hidden"
      >
        <h2 class="text-lg font-semibold text-(--content-heading)">
          Filter Products
        </h2>
        <button
          type="button"
          id="mobile-filter-close"
          class="p-1 text-(--content-meta) hover:text-(--content-emphasis)"
          aria-label="Close Filters"
        >
          <svg
            class="w-6 h-6"
            fill="none"
            stroke="currentColor"
            viewBox="0 0 24 24"
          >
            <path
              stroke-linecap="round"
              stroke-linejoin="round"
              stroke-width="2"
              d="M6 18L18 6M6 6l12 12"></path>
          </svg>
        </button>
      </div>

      <!-- Results Count with Live Region for Screen Reader Announcements -->
      <div class="min-w-fit mt-2 mb-4">
        <div class="lg:hidden p-3 bg-(--surface-tertiary) rounded-sm">
          <p class="text-sm text-(--content-meta)" data-result-count>
            {filteredCount} of {totalProducts} products
          </p>
        </div>
        <div class="hidden lg:block">
          <p
            class="text-sm lg:text-base text-(--content-meta) font-medium"
            data-result-count
          >
            {
              filteredCount === totalProducts
                ? `${totalProducts} products`
                : `${filteredCount} of ${totalProducts} products`
            }
          </p>
        </div>

        <!-- Screen Reader Live Region for Filter Updates -->
        <div
          id="filter-results-live-region"
          aria-live="polite"
          aria-atomic="true"
          class="sr-only"
        >
          {
            filteredCount === totalProducts
              ? `Showing all ${totalProducts} products`
              : `Filtered to ${filteredCount} of ${totalProducts} products`
          }
        </div>
      </div>

      <!-- Brand Filter Section -->
      {
        filterOptions.brands.length > 0 && (
          <div class="mb-6 lg:mb-4">
            <div class="flex items-center justify-between mb-3">
              <h3 class="text-2xl font-medium font-display text-(--content-heading)">
                Brand
              </h3>
              {currentBrands.length > 0 && (
                <button
                  type="button"
                  id="clear-brands-button"
                  data-clear-filters
                  class="text-sm text-(--content-meta) hover:text-(--content-emphasis) transition-colors lg:mr-2"
                >
                  Clear ({currentBrands.length})
                </button>
              )}
            </div>

            <div
              class="space-y-3 lg:space-y-1 max-h-64 lg:max-h-none overflow-y-auto lg:overflow-visible brand-filter-list"
              data-brand-list
            >
              {filterOptions.brands.map((brand, index) => {
                const isHidden = index >= DEFAULT_VISIBLE_BRANDS;
                // FOUC Fix: Apply server-side visibility logic
                const serverHiddenClass =
                  isHidden && !shouldStartExpanded ? "lg:hidden" : "";

                return (
                  <label
                    class={`flex items-center justify-between group cursor-pointer p-3 lg:p-1 rounded-sm hover:bg-(--surface-tertiary) lg:hover:bg-(--surface-secondary) transition-colors ${isHidden ? `brand-extra-item ${serverHiddenClass}` : ""}`}
                  >
                    <div class="flex items-center">
                      <input
                        type="checkbox"
                        name="brands"
                        value={brand.name}
                        checked={currentBrands.includes(brand.name)}
                        class="elco-checkbox mr-3 lg:mr-2 w-5 h-5 lg:w-4 lg:h-4 rounded-sm border-2 border-(--ui-input-border) text-ui-accent focus:ring-2 focus:ring-ui-accent focus:ring-offset-0"
                      />
                      <span class="text-(--content-body) group-hover:text-(--content-emphasis)">
                        {brand.name}
                      </span>
                    </div>
                    <span class="text-sm text-(--content-meta) lg:mr-2">
                      ({brand.count})
                    </span>
                  </label>
                );
              })}

              {shouldShowToggle && (
                <button
                  type="button"
                  id="show-more-toggle"
                  class="hidden lg:block w-full text-left text-sm text-ui-accent hover:text-ui-accent-hover transition-colors p-1 font-medium"
                  data-collapsed-text={`+ Show ${filterOptions.brands.length - DEFAULT_VISIBLE_BRANDS} more`}
                  data-expanded-text="- Show less"
                  data-initial-expanded={shouldStartExpanded.toString()}
                >
                  {shouldStartExpanded
                    ? "- Show less"
                    : `+ Show ${filterOptions.brands.length - DEFAULT_VISIBLE_BRANDS} more`}
                </button>
              )}
            </div>
          </div>
        )
      }

      <!-- Availability Filter Section -->
      <div class="mb-6 lg:mb-4">
        <h3
          class="text-xl font-medium font-display text-(--content-heading) mb-3"
        >
          Availability
        </h3>

        <label
          class="flex items-center group cursor-pointer p-3 lg:p-1 rounded-sm hover:bg-(--surface-tertiary) lg:hover:bg-(--surface-secondary) transition-colors"
        >
          <input
            type="checkbox"
            name="availability"
            value="true"
            checked={currentAvailability}
            class="elco-checkbox mr-3 lg:mr-2 w-5 h-5 lg:w-4 lg:h-4 rounded-sm border-2 border-(--ui-input-border) text-ui-accent focus:ring-2 focus:ring-ui-accent focus:ring-offset-0"
          />
          <span
            class="text-(--content-body) group-hover:text-(--content-emphasis)"
          >
            In stock only
          </span>
        </label>
      </div>

      <!-- Mobile Actions -->
      <div
        class="flex gap-3 p-6 -mx-4 bg-(--surface-secondary) border-t-4 border-(--border-tertiary) sticky bottom-0 lg:hidden"
      >
        {
          (currentBrands.length > 0 || currentAvailability) && (
            <button
              type="button"
              data-clear-filters-mobile
              class="flex-1 py-3 px-4 border border-(--ui-button-border) text-ui-button-border rounded-sm hover:bg-ui-button-hover transition-colors text-center"
            >
              Clear Filters
            </button>
          )
        }
        <button
          type="submit"
          class="flex-1 py-3 px-4 bg-(--ui-button-surface) text-(--ui-button-text) rounded-sm hover:bg-ui-button-primary-hover transition-colors font-medium"
        >
          Apply Filters
        </button>
      </div>
    </form>
  </div>
</div>

<script>
  import { FilterCoordinator } from "@/lib/filterCoordinator";

  class ProductFilters {
    private form: HTMLFormElement | null = null;
    private container: HTMLElement | null = null;
    private overlay: HTMLElement | null = null;
    private showMoreToggle: HTMLButtonElement | null = null;
    private isExpanded: boolean = false;
    private isInitialized: boolean = false;

    constructor() {
      this.initializeElements();
      if (this.form) {
        this.setupEventListeners();
        this.initializeMenuState();
        this.setupViewTransitionsCoordination();
        this.isInitialized = true;
      }
    }

    private initializeElements(): void {
      this.form = document.getElementById("filter-form") as HTMLFormElement;
      this.container = document.getElementById("filter-container");
      this.overlay = document.getElementById("mobile-filter-overlay");
      this.showMoreToggle = document.getElementById(
        "show-more-toggle"
      ) as HTMLButtonElement;

      if (!this.form) {
        console.warn(
          "[ProductFilters] Form element not found. Filters may not work correctly."
        );
        return;
      }
    }

    private setupEventListeners(): void {
      this.setupMobileDrawer();
      this.setupHybridFiltering();
      this.setupShowMoreToggle();
      this.setupClearButtons();
    }

    private setupMobileDrawer(): void {
      const toggle = document.getElementById("mobile-filter-toggle");
      const close = document.getElementById("mobile-filter-close");

      toggle?.addEventListener("click", () => this.openMobileDrawer());
      close?.addEventListener("click", () => this.closeMobileDrawer());
      this.overlay?.addEventListener("click", () => this.closeMobileDrawer());
    }

    private openMobileDrawer(): void {
      this.overlay?.classList.remove("pointer-events-none", "opacity-0");
      this.container?.classList.remove(
        "translate-y-full",
        "opacity-0",
        "pointer-events-none"
      );
      document.body.style.overflow = "hidden";
    }

    private closeMobileDrawer(): void {
      this.overlay?.classList.add("opacity-0");
      this.container?.classList.add("translate-y-full", "opacity-0");

      // Use transitionend event with proper cleanup to prevent race condition
      let hasCompleted = false;
      const handleTransitionEnd = () => {
        if (hasCompleted) return; // Prevent duplicate calls
        hasCompleted = true;

        this.overlay?.classList.add("pointer-events-none");
        this.container?.classList.add("pointer-events-none");
        this.container?.removeEventListener(
          "transitionend",
          handleTransitionEnd
        );
      };

      this.container?.addEventListener("transitionend", handleTransitionEnd, {
        once: true,
      });

      // Fallback timeout in case transitionend doesn't fire
      setTimeout(handleTransitionEnd, 350);

      document.body.style.overflow = "";
    }

    private setupHybridFiltering(): void {
      if (!this.form) return;

      // Use matchMedia to stay in sync with Tailwind's lg breakpoint
      const isDesktop = () => window.matchMedia("(min-width: 1024px)").matches;

      // Simple form-based approach with View Transitions
      this.form.addEventListener("submit", (event) => {
        event.preventDefault();

        if (!isDesktop()) {
          this.closeMobileDrawer();
          setTimeout(() => this.submitForm(), 300);
        } else {
          this.submitForm();
        }
      });

      // Desktop: immediate filtering on checkbox change
      const checkboxes = this.form.querySelectorAll('input[type="checkbox"]');
      checkboxes.forEach((checkbox) => {
        checkbox.addEventListener("change", () => {
          if (isDesktop()) {
            this.submitForm();
          }
        });
      });
    }

    private submitForm(): void {
      try {
        const formData = new FormData(this.form!);
        const params = new URLSearchParams();

        const brands = formData.getAll("brands") as string[];
        const availability = formData.get("availability") === "true";

        brands.forEach((brand) => params.append("brands", brand));
        if (availability) params.set("availability", "true");

        const queryString = params.toString();
        const basePath = window.location.pathname;
        const newUrl = `${basePath}${queryString ? "?" + queryString : ""}`;

        // Use coordinated exit animation with Astro's navigate() API
        FilterCoordinator.coordinateExit(async () => {
          sessionStorage.setItem(
            FilterCoordinator.getStorageKeys().filterMenuExpanded,
            this.isExpanded.toString()
          );

          // Use Astro's navigate() instead of window.location.href
          // This preserves transition:persist elements and avoids full page reload
          const { navigate } = await import('astro:transitions/client');
          navigate(newUrl);
        }, newUrl);
      } catch (error) {
        console.error("[ProductFilters] Error submitting form:", error);
        // Fallback to Astro navigation
        import('astro:transitions/client').then(({ navigate }) => {
          navigate(window.location.pathname);
        }).catch(() => {
          // Last resort: full page reload
          window.location.href = window.location.pathname;
        });
      }
    }

    private setupShowMoreToggle(): void {
      if (!this.showMoreToggle) return;

      this.showMoreToggle.addEventListener("click", (e) => {
        e.preventDefault();
        this.isExpanded ? this.collapseFilters() : this.expandFilters();
        sessionStorage.setItem(
          "filter-menu-expanded",
          this.isExpanded.toString()
        );
      });
    }

    private initializeMenuState(): void {
      const initialExpanded =
        this.showMoreToggle?.dataset.initialExpanded === "true";
      const wasExpanded =
        sessionStorage.getItem("filter-menu-expanded") === "true";
      const shouldExpand =
        sessionStorage.getItem("filter-menu-expanded") !== null
          ? wasExpanded
          : initialExpanded;

      this.isExpanded = shouldExpand;

      setTimeout(() => {
        const filterList = document.querySelector(
          ".brand-filter-list"
        ) as HTMLElement;
        if (filterList) {
          filterList.style.transition = "";
        }
      }, 100);
    }

    private collapseFilters(): void {
      const extraItems = document.querySelectorAll(".brand-extra-item");
      const collapsedText =
        this.showMoreToggle?.dataset.collapsedText || "+ Show more";

      extraItems.forEach((item) => {
        const element = item as HTMLElement;
        element.classList.add("lg:hidden");
      });

      if (this.showMoreToggle) this.showMoreToggle.textContent = collapsedText;
      this.isExpanded = false;
    }

    private expandFilters(): void {
      const extraItems = document.querySelectorAll(".brand-extra-item");
      const expandedText =
        this.showMoreToggle?.dataset.expandedText || "- Show less";

      extraItems.forEach((item) => {
        const element = item as HTMLElement;
        element.classList.remove("lg:hidden");
      });

      if (this.showMoreToggle) this.showMoreToggle.textContent = expandedText;
      this.isExpanded = true;
    }

    private setupClearButtons(): void {
      const clearBtn = document.querySelector("[data-clear-filters]");
      const clearBtnMobile = document.querySelector(
        "[data-clear-filters-mobile]"
      );

      clearBtn?.addEventListener("click", () => {
        this.clearAllFilters();
      });

      clearBtnMobile?.addEventListener("click", () => {
        // Close mobile drawer first, then clear
        this.closeMobileDrawer();
        setTimeout(() => this.clearAllFilters(), 100);
      });
    }

    private setupViewTransitionsCoordination(): void {
      document.addEventListener("astro:before-preparation", () => {
        // Close mobile drawer before navigation
        if (this.container && this.overlay) {
          this.container.classList.add(
            "translate-y-full",
            "opacity-0",
            "pointer-events-none"
          );
          this.overlay.classList.add("pointer-events-none", "opacity-0");
          document.body.style.overflow = "";
        }

        // Clean up clearing messages
        const existingMessage = document.getElementById("clearing-message");
        existingMessage?.remove();
        sessionStorage.removeItem("filtering-in-progress");
      });

      document.addEventListener("astro:after-swap", () => {
        // Ensure product cards start in correct state for animations
        const cards = document.querySelectorAll(".product-card-wrapper");
        cards.forEach((card) => {
          const htmlCard = card as HTMLElement;
          if (!htmlCard.classList.contains("opacity-100")) {
            htmlCard.classList.add("opacity-0");
          }
        });
      });

      document.addEventListener("astro:page-load", () => {
        const grid = document.getElementById("filterable-product-grid");
        if (grid) {
          grid.style.visibility = "visible";
          grid.style.opacity = "1";
        }

        document.body.classList.remove("filtering-in-progress");
        updateFilterResultsLiveRegion();
      });
    }

    public clearAllFilters(): void {
      const basePath = window.location.pathname;
      const isMobile = !window.matchMedia("(min-width: 1024px)").matches;

      if (isMobile) {
        this.closeMobileDrawer();
      }

      // Use coordinated exit with Astro navigation
      FilterCoordinator.coordinateExit(async () => {
        sessionStorage.setItem(
          FilterCoordinator.getStorageKeys().filterMenuExpanded,
          this.isExpanded.toString()
        );

        // Use Astro's navigate() to preserve transition:persist elements
        const { navigate } = await import('astro:transitions/client');
        navigate(basePath);
      }, basePath);
    }

    public destroy(): void {
      document.body.style.overflow = "";

      // Reset mobile drawer to closed state
      if (this.container) {
        this.container.classList.add(
          "translate-y-full",
          "opacity-0",
          "pointer-events-none"
        );
        this.container.classList.add(
          "lg:translate-y-0",
          "lg:opacity-100",
          "lg:pointer-events-auto"
        );
      }

      if (this.overlay) {
        this.overlay.classList.add("pointer-events-none", "opacity-0");
      }

      sessionStorage.removeItem("filtering-in-progress");
    }
  }

  // Function to update filter results live region for screen readers
  function updateFilterResultsLiveRegion() {
    const liveRegion = document.getElementById("filter-results-live-region");
    const resultCountElement = document.querySelector("[data-result-count]");

    if (liveRegion && resultCountElement) {
      // Extract count from the visible result text
      const resultText = resultCountElement.textContent || "";
      const message = resultText.includes("of")
        ? `Filtered to ${resultText}`
        : `Showing ${resultText}`;

      // Update live region with slight delay to ensure it's announced
      setTimeout(() => {
        liveRegion.textContent = message;
      }, 100);
    }
  }

  let currentInstance: ProductFilters | null = null;

  function initializeFilters() {
    if (currentInstance) {
      currentInstance.destroy();
    }
    currentInstance = new ProductFilters();
  }

  function cleanupFilters() {
    if (currentInstance) {
      currentInstance.destroy();
      currentInstance = null;
    }
    FilterCoordinator.reset();
  }

  // Initialize the unified filter system
  FilterCoordinator.initialize();

  // Handle Astro navigation
  document.addEventListener("astro:page-load", initializeFilters);
  document.addEventListener("astro:before-preparation", cleanupFilters);

  // Initialize if DOM is ready
  if (document.readyState !== "loading") {
    initializeFilters();
  }
</script>
