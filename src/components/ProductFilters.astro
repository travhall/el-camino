---
// src/components/ProductFilters.astro - Cleaned with restored pageSize input
import type { FilterOptions } from "@/lib/square/types";

interface Props {
  filterOptions: FilterOptions;
  totalProducts: number;
  filteredCount: number;
  categoryPath?: string;
}

const { filterOptions, totalProducts, filteredCount, categoryPath = "" } = Astro.props;

// Parse current filters from URL for server-side rendering
const currentParams = new URLSearchParams(Astro.url.search);
const currentBrands = currentParams.getAll("brands") || [];
const currentAvailability = currentParams.get("availability") === "true";

// Configuration for show more/less functionality
const DEFAULT_VISIBLE_BRANDS = 6;
const shouldShowToggle = filterOptions.brands.length > DEFAULT_VISIBLE_BRANDS;

// FOUC Fix: Determine initial expanded state server-side
// Check if there are any selected brands beyond the default visible count
const hasSelectedBrandsBelow = currentBrands.some(brand => {
  const brandIndex = filterOptions.brands.findIndex(b => b.name === brand);
  return brandIndex >= DEFAULT_VISIBLE_BRANDS;
});

// Start expanded if user has selected brands that would be hidden
const shouldStartExpanded = hasSelectedBrandsBelow;
---

<style is:inline>
  /* Simple transitions only */
  .brand-filter-list {
    transition: none;
  }
  
  .product-card-wrapper[style*="display: none"] {
    display: none !important;
  }
  
  /* Disabled state styling for phantom click prevention */
  :disabled {
    opacity: 0.6;
    cursor: not-allowed;
    pointer-events: none;
  }
  
  /* Disabled button styling */
  button:disabled {
    opacity: 0.6;
    cursor: not-allowed;
    pointer-events: none;
  }
  
  /* Simple disabled container state */
  .filters-disabled {
    opacity: 0.6;
    pointer-events: none;
  }
  
  /* PHASE 2: Enhanced mobile loading states */
  .mobile-filter-loading {
    position: fixed;
    inset: 0;
    background: rgba(0, 0, 0, 0.3);
    backdrop-filter: blur(4px);
    z-index: 60;
    display: flex;
    align-items: center;
    justify-content: center;
  }
  
  /* Enhanced View Transitions coordination */
  @media (max-width: 1023px) {
    /* Smooth drawer transitions for mobile */
    #filter-container {
      transform-origin: bottom;
      backface-visibility: hidden;
    }
    
    /* Optimize mobile View Transitions */
    html::view-transition-old(root),
    html::view-transition-new(root) {
      animation-duration: 0.2s;
    }
  }
  
  /* Respect reduced motion for View Transitions */
  @media (prefers-reduced-motion: reduce) {
    html::view-transition-old(root),
    html::view-transition-new(root) {
      animation: none !important;
    }
  }
</style>

<!-- Single Responsive Form Container -->
<div class="relative lg:block bg-(--surface-primary)">
  <!-- Mobile Filter Button -->
  <button
    id="mobile-filter-toggle"
    class="lg:hidden fixed bottom-4 right-4 bg-(--surface-tertiary) text-(--content-body) border border-(--border-tertiary) rounded-md flex flex-row gap-2 p-4 shadow-lg z-250"
    aria-label="Open Filters"
  >
    Filters
    <svg class="w-5 h-5" fill="none" stroke="currentColor" viewBox="0 0 24 24">
      <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M3 4a1 1 0 011-1h16a1 1 0 011 1v2.586a1 1 0 01-.293.707l-6.414 6.414a1 1 0 00-.293.707V17l-4 4v-6.586a1 1 0 00-.293-.707L3.293 7.707A1 1 0 013 7V4z"></path>
    </svg>
    {currentBrands.length > 0 && (
      <span class="absolute -top-1 -right-1 bg-(--ui-button-surface) text-(--ui-button-text) font-bold text-sm rounded-full min-w-5 h-5 flex items-center justify-center px-1">
        {currentBrands.length}
      </span>
    )}
  </button>

  <!-- Mobile Overlay -->
  <div
    id="mobile-filter-overlay"
    class="lg:hidden fixed inset-0 bg-(--ui-modal-overlay)/80 backdrop-blur-sm z-40 opacity-0 pointer-events-none transition-opacity duration-300"
  ></div>

  <!-- Single Form - Desktop Static, Mobile Drawer -->
  <div
    id="filter-container"
    class="lg:static lg:transform-none lg:max-h-none fixed bottom-0 left-0 right-0 md:left-auto md:w-[28rem] lg:w-auto bg-(--surface-secondary) z-500 max-h-[80vh] overflow-y-auto transform translate-y-full lg:translate-y-0 opacity-0 lg:opacity-100 pointer-events-none lg:pointer-events-auto transition-all duration-300 lg:transition-none"
  >
    <form class="px-4 lg:p-2" id="filter-form">
      <!-- Mobile Header -->
      <div class="flex items-center justify-between mb-4 p-6 -mx-4 bg-(--surface-secondary) border border-b-(--border-tertiary) sticky top-0 z-50 lg:hidden">
        <h2 class="text-lg font-semibold text-(--content-heading)">Filter Products</h2>
        <button type="button" id="mobile-filter-close" class="p-1 text-(--content-meta) hover:text-(--content-emphasis)" aria-label="Close Filters">
          <svg class="w-6 h-6" fill="none" stroke="currentColor" viewBox="0 0 24 24">
            <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M6 18L18 6M6 6l12 12"></path>
          </svg>
        </button>
      </div>

      <!-- Results Count -->
      <div class="min-w-fit mt-2 mb-4">
        <div class="lg:hidden p-3 bg-(--surface-tertiary) rounded-sm">
          <p class="text-sm text-(--content-meta)" data-result-count>
            {filteredCount} of {totalProducts} products
          </p>
        </div>
        <div class="hidden lg:block">
          <p class="text-sm lg:text-base text-(--content-meta) font-medium" data-result-count>
            {filteredCount === totalProducts
              ? `${totalProducts} products`
              : `${filteredCount} of ${totalProducts} products`
            }
          </p>
        </div>
      </div>

      <!-- Brand Filter Section -->
      {filterOptions.brands.length > 0 && (
        <div class="mb-6 lg:mb-4">
          <div class="flex items-center justify-between mb-3">
            <h3 class="text-xl font-medium font-display text-(--content-heading)">Brand</h3>
            <button
              type="button"
              id="clear-brands-button"
              data-clear-filters
              class="text-sm text-(--content-meta) hover:text-(--content-emphasis) transition-colors lg:mr-2"
              style={currentBrands.length === 0 ? "display: none;" : ""}
            >
              Clear ({currentBrands.length})
            </button>
          </div>

          <!-- Brand List with FOUC Fix -->
          <div class="space-y-3 lg:space-y-1 max-h-64 lg:max-h-none overflow-y-auto lg:overflow-visible brand-filter-list" data-brand-list>
            {filterOptions.brands.map((brand, index) => {
              const isHidden = index >= DEFAULT_VISIBLE_BRANDS;
              // FOUC Fix: Apply server-side visibility logic
              const serverHiddenClass = isHidden && !shouldStartExpanded ? "lg:hidden" : "";

              return (
                <label
                  class={`flex items-center justify-between group cursor-pointer p-3 lg:p-1 rounded-sm hover:bg-(--surface-tertiary) lg:hover:bg-(--surface-secondary) transition-colors ${isHidden ? `brand-extra-item ${serverHiddenClass}` : ""}`}
                >
                  <div class="flex items-center">
                    <input
                      type="checkbox"
                      name="brands"
                      value={brand.name}
                      checked={currentBrands.includes(brand.name)}
                      class="elco-checkbox mr-3 lg:mr-2 w-5 h-5 lg:w-4 lg:h-4 rounded-sm border-2 border-(--ui-input-border) text-ui-accent focus:ring-2 focus:ring-ui-accent focus:ring-offset-0"
                    />
                    <span class="text-(--content-body) group-hover:text-(--content-emphasis)">
                      {brand.name}
                    </span>
                  </div>
                  <span class="text-sm text-(--content-meta) lg:mr-2">({brand.count})</span>
                </label>
              );
            })}

            {shouldShowToggle && (
              <button
                type="button"
                id="show-more-toggle"
                class="hidden lg:block w-full text-left text-sm text-ui-accent hover:text-ui-accent-hover transition-colors p-1 font-medium"
                data-collapsed-text={`+ Show ${filterOptions.brands.length - DEFAULT_VISIBLE_BRANDS} more`}
                data-expanded-text="- Show less"
                data-initial-expanded={shouldStartExpanded.toString()}
              >
                {shouldStartExpanded 
                  ? "- Show less"
                  : `+ Show ${filterOptions.brands.length - DEFAULT_VISIBLE_BRANDS} more`
                }
              </button>
            )}
          </div>
        </div>
      )}

      <!-- Availability Filter Section -->
      <div class="mb-6 lg:mb-4">
        <h3 class="text-xl font-medium font-display text-(--content-heading) mb-3">Availability</h3>

        <label class="flex items-center group cursor-pointer p-3 lg:p-1 rounded-sm hover:bg-(--surface-tertiary) lg:hover:bg-(--surface-secondary) transition-colors">
          <input
            type="checkbox"
            name="availability"
            value="true"
            checked={currentAvailability}
            class="elco-checkbox mr-3 lg:mr-2 w-5 h-5 lg:w-4 lg:h-4 rounded-sm border-2 border-(--ui-input-border) text-ui-accent focus:ring-2 focus:ring-ui-accent focus:ring-offset-0"
          />
          <span class="text-(--content-body) group-hover:text-(--content-emphasis)">
            In stock only
          </span>
        </label>
      </div>

      <!-- Mobile Actions -->
      <div class="flex gap-3 p-6 -mx-4 bg-(--surface-secondary) border-t-(--border-tertiary) sticky bottom-0 lg:hidden">
        {(currentBrands.length > 0 || currentAvailability) && (
          <button
            type="button"
            data-clear-filters-mobile
            class="flex-1 py-3 px-4 border border-(--ui-button-border) text-ui-button-border rounded-sm hover:bg-ui-button-hover transition-colors text-center"
          >
            Clear Filters
          </button>
        )}
        <button
          type="submit"
          class="flex-1 py-3 px-4 bg-(--ui-button-surface) text-(--ui-button-text) rounded-sm hover:bg-ui-button-primary-hover transition-colors font-medium"
        >
          Apply Filters
        </button>
      </div>
    </form>
  </div>
</div>

<script>
  // SIMPLIFIED: Filter Engine WITHOUT infinite scroll responsibility
  class StreamlinedFilterEngine {
  private products: any[] = [];
  private filteredProducts: any[] = [];
  
  constructor() {
    this.initializeProducts();
  }
    
  private initializeProducts(): void {
    const grid = document.getElementById("filterable-product-grid");
    
    // Use the correct data attributes set by ProductGrid
    const allProductsData = grid?.dataset.allProducts;
    const initialProductsData = grid?.dataset.initialProducts;
    
    if (!allProductsData && !initialProductsData) {
      console.warn("[StreamlinedFilterEngine] No product data found");
      return;
    }
    
    try {
      // Prefer allProducts for client-side filtering, fallback to initial products
      const productData = allProductsData || initialProductsData;
      if (!productData) {
        console.error("[StreamlinedFilterEngine] No valid product data available");
        return;
      }
      this.products = JSON.parse(productData);
      this.filteredProducts = [...this.products];
      
      console.log(`[StreamlinedFilterEngine] Initialized with ${this.products.length} products`);
    } catch (error) {
      console.error("[StreamlinedFilterEngine] Failed to parse product data:", error);
    }
  }
    
  public applyFilters(criteria: any): void {
    console.log('[StreamlinedFilterEngine] üîç Applying filters:', criteria);
    console.log('[StreamlinedFilterEngine] üìä Total products to filter:', this.products.length);
    
    // Simple, reliable filtering - NO infinite scroll logic
    this.filteredProducts = this.products.filter(product => 
      this.matchesCriteria(product, criteria)
    );
    
    console.log('[StreamlinedFilterEngine] ‚úÖ Filtered products:', this.filteredProducts.length);
    console.log('[StreamlinedFilterEngine] üìã Sample filtered products:', this.filteredProducts.slice(0, 3).map(p => ({ id: p.id, brand: p.brand, name: p.name })));
    
    // Simple DOM updates - ProductGrid handles its own infinite scroll
    this.updateProductGrid();
    this.updateResultCount();
    this.updateAppliedFilters(criteria);
    this.updateClearButtonVisibility(criteria);
    this.updateNoResultsState();
  }
  
  private matchesCriteria(product: any, criteria: any): boolean {
    // Debug first few products
    const productIndex = this.products.indexOf(product);
    if (productIndex < 3) {
      console.log(`[StreamlinedFilterEngine] üîç Filtering product ${productIndex}:`, {
        id: product.id,
        brand: product.brand,
        criteriaBrands: criteria.brands,
        criteriaAvailability: criteria.availability,
        isOutOfStock: product.inventoryStatus?.isOutOfStock
      });
    }
    
    // Brand filtering
    if (criteria.brands.length > 0 && !criteria.brands.includes(product.brand)) {
      if (productIndex < 3) console.log(`[StreamlinedFilterEngine] ‚ùå Product ${productIndex} filtered out by brand`);
      return false;
    }
    
    // Availability filtering
    if (criteria.availability && product.inventoryStatus?.isOutOfStock) {
      if (productIndex < 3) console.log(`[StreamlinedFilterEngine] ‚ùå Product ${productIndex} filtered out by availability`);
      return false;
    }
    
    if (productIndex < 3) console.log(`[StreamlinedFilterEngine] ‚úÖ Product ${productIndex} matches criteria`);
    return true;
  }
    
  private updateProductGrid(): void {
    const grid = document.getElementById("filterable-product-grid");
    if (!grid) {
      console.error('[StreamlinedFilterEngine] ‚ùå Product grid not found');
      return;
    }
    
    const allWrappers = Array.from(grid.querySelectorAll('.product-card-wrapper'));
    const visibleProductIds = new Set(this.filteredProducts.map(p => String(p.id))); // Ensure string comparison
    
    console.log('[StreamlinedFilterEngine] üéØ DOM Update - Total cards:', allWrappers.length);
    console.log('[StreamlinedFilterEngine] üéØ DOM Update - Should be visible:', visibleProductIds.size);
    console.log('[StreamlinedFilterEngine] üéØ Visible product IDs:', Array.from(visibleProductIds).slice(0, 5));

    // Get animation timing with row-based calculations
    const { duration, staggerDelay, rowStaggerDelay } = this.getAnimationTiming();

    // Helper function to calculate responsive grid
    function getCardsPerRow() {
      const width = window.innerWidth;
      if (width >= 1536) return 6; // 2xl:grid-cols-6
      if (width >= 1280) return 4; // xl:grid-cols-4
      if (width >= 1024) return 3; // lg:grid-cols-3
      if (width >= 768) return 2;  // md:grid-cols-2
      return 2; // fallback
    }

    // Step 1: Exit all cards
    allWrappers.forEach((wrapper) => {
      wrapper.classList.remove('opacity-100');
      wrapper.classList.add('opacity-0');
    });

    // Step 2: Show/hide and animate visible cards with row-based stagger
    setTimeout(() => {
      let visibleIndex = 0;
      const cardsPerRow = getCardsPerRow();
      
      allWrappers.forEach((wrapper) => {
        const productId = wrapper.getAttribute('data-product-id');
        const isVisible = productId ? visibleProductIds.has(productId) : false;
        
        // Debug first few iterations
        if (visibleIndex < 3) {
          console.log(`[StreamlinedFilterEngine] üîç Card ${visibleIndex}: DOM ID="${productId}", visible=${isVisible}`);
        }

        if (isVisible) {
          // Show card and animate in with combined row + individual card stagger
          (wrapper as HTMLElement).style.display = '';
          (wrapper as HTMLElement).removeAttribute('data-filter-hidden');
          
          // Calculate both row index and individual stagger
          const rowIndex = Math.floor(visibleIndex / cardsPerRow);
          const cardInRow = visibleIndex % cardsPerRow;
          
          // Combined delay: row delay + individual card delay within row
          const baseRowDelay = rowIndex * rowStaggerDelay;
          const cardDelay = cardInRow * (staggerDelay / 1.2); // More pronounced individual stagger
          const totalDelay = baseRowDelay + cardDelay;
          
          setTimeout(() => {
            wrapper.classList.remove('opacity-0');
            wrapper.classList.add('opacity-100');
          }, totalDelay);
          
          visibleIndex++;
        } else {
          // Hide card completely and mark as filtered
          (wrapper as HTMLElement).style.display = 'none';
          (wrapper as HTMLElement).setAttribute('data-filter-hidden', 'true');
        }
      });
      
      // FIXED: Notify ProductGrid AFTER DOM updates are complete
      console.log('[StreamlinedFilterEngine] üì° DOM updates complete, notifying ProductGrid');
      document.dispatchEvent(new CustomEvent("filtersApplied"));
      
    }, duration);
  }
  
  private updateResultCount(): void {
    const resultElements = document.querySelectorAll('[data-result-count]');
    resultElements.forEach(element => {
      const totalProducts = this.products.length;
      const filteredCount = this.filteredProducts.length;
      
      if (filteredCount === totalProducts) {
        element.textContent = `${totalProducts} products`;
      } else {
        element.textContent = `${filteredCount} of ${totalProducts} products`;
      }
    });
  }
  
  private updateNoResultsState(): void {
    const noResults = document.getElementById("no-results");
    const grid = document.getElementById("filterable-product-grid");
    
    if (this.filteredProducts.length === 0) {
      noResults?.classList.remove("hidden");
      grid?.classList.add("hidden");
    } else {
      noResults?.classList.add("hidden");
      grid?.classList.remove("hidden");
    }
  }

  // Enhanced CSS parsing for animation timing with row-based calculations
  private getAnimationTiming() {
    const style = getComputedStyle(document.documentElement);
    
    // Properly parse duration (handles "0.3s", "300ms", etc.)
    const durationStr = style.getPropertyValue('--card-transition-duration').trim();
    console.log(`[StreamlinedFilterEngine] CSS duration value: "${durationStr}"`);
    const duration = durationStr.includes('ms') 
      ? parseInt(durationStr.replace('ms', ''))
      : parseFloat(durationStr.replace('s', '')) * 1000;
    
    // Properly parse stagger delay (handles "50ms", "0ms", etc.)
    const staggerStr = style.getPropertyValue('--card-stagger-delay').trim();
    console.log(`[StreamlinedFilterEngine] CSS stagger value: "${staggerStr}"`);
    const staggerDelay = parseInt(staggerStr.replace('ms', '')) || 0;

    // Parse row stagger delay for row-based animations
    const rowStaggerStr = style.getPropertyValue('--row-stagger-delay').trim();
    console.log(`[StreamlinedFilterEngine] CSS row stagger value: "${rowStaggerStr}"`);
    const rowStaggerDelay = parseInt(rowStaggerStr.replace('ms', '')) || 100;
    
    console.log(`[StreamlinedFilterEngine] Parsed timing - Duration: ${duration}ms, Stagger: ${staggerDelay}ms, Row Stagger: ${rowStaggerDelay}ms`);
    
    return {
      duration: duration || 300,
      staggerDelay: staggerDelay,
      rowStaggerDelay: rowStaggerDelay
    };
  }
    
    private updateAppliedFilters(criteria: any): void {
      // Update AppliedFilters component for client-side filtering
      const appliedFiltersContainer = document.getElementById('applied-filters-container') as HTMLElement;
      const appliedFiltersContent = document.getElementById('applied-filters-content') as HTMLElement;
      
      if (!appliedFiltersContainer || !appliedFiltersContent) return;
      
      const hasFilters = criteria.brands.length > 0 || criteria.availability;
      
      if (!hasFilters) {
        // Use CSS Grid animation to hide
        appliedFiltersContainer.classList.remove('filters-open');
        // Clear content after animation completes
        setTimeout(() => {
          if (!appliedFiltersContainer.classList.contains('filters-open')) {
            appliedFiltersContent.innerHTML = '';
          }
        }, 300);
        return;
      }
      
      // Show container using CSS Grid animation and populate content
      appliedFiltersContent.innerHTML = '';
      appliedFiltersContainer.classList.add('filters-open');
      
      // Create filters wrapper
      const filtersWrapper = document.createElement('div');
      filtersWrapper.className = 'flex flex-wrap gap-2';
      
      // Add brand filters
      criteria.brands.forEach((brand: string) => {
        const filterTag = document.createElement('button');
        filterTag.className = 'inline-flex items-center px-2.5 py-1.5 text-sm border rounded-full bg-(--surface-primary) hover:bg-(--surface-tertiary) transition-colors text-(--ui-input-text) border-(--ui-input-border)/50 group';
        filterTag.innerHTML = `
          <span>${brand}</span>
          <svg class="w-3 h-3 ml-1 text-(--content-meta) group-hover:text-(--content-body)" fill="none" stroke="currentColor" viewBox="0 0 24 24">
            <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M6 18L18 6M6 6l12 12"></path>
          </svg>
        `;
        filterTag.addEventListener('click', () => {
          // Remove this brand and reapply filters
          const checkbox = document.querySelector(`input[name="brands"][value="${brand}"]`) as HTMLInputElement;
          if (checkbox) {
            checkbox.checked = false;
            checkbox.dispatchEvent(new Event('change', { bubbles: true }));
          }
        });
        filtersWrapper.appendChild(filterTag);
      });
      
      // Add availability filter
      if (criteria.availability) {
        const filterTag = document.createElement('button');
        filterTag.className = 'inline-flex items-center px-2.5 py-1.5 text-sm border rounded-full bg-(--state-success-surface) hover:bg-(--state-success-surface)/75 transition-colors text-(--state-success-text) border-(--state-success-text)/50 group';
        filterTag.innerHTML = `
          <span>In stock only</span>
          <svg class="w-3 h-3 ml-1 text-(--state-success-text)/70 group-hover:text-(--state-success-text)" fill="none" stroke="currentColor" viewBox="0 0 24 24">
            <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M6 18L18 6M6 6l12 12"></path>
          </svg>
        `;
        filterTag.addEventListener('click', () => {
          // Remove availability filter and reapply
          const checkbox = document.querySelector('input[name="availability"]') as HTMLInputElement;
          if (checkbox) {
            checkbox.checked = false;
            checkbox.dispatchEvent(new Event('change', { bubbles: true }));
          }
        });
        filtersWrapper.appendChild(filterTag);
      }
      
      // Add clear all button - SAME LOGIC AS ProductFilters Clear
      const clearAllButton = document.createElement('button');
      clearAllButton.className = 'text-sm text-(--content-meta) hover:text-(--content-emphasis) transition-colors text-nowrap';
      clearAllButton.textContent = 'Clear All';
      clearAllButton.addEventListener('click', () => {
        // Use exact same method as ProductFilters Clear button
        const responsiveFilters = (window as any).currentFilterInstance;
        if (responsiveFilters && responsiveFilters.clearAllFilters) {
          responsiveFilters.clearAllFilters();
        }
      });
      
      appliedFiltersContent.appendChild(filtersWrapper);
      appliedFiltersContent.appendChild(clearAllButton);
    }
    
    private updateClearButtonVisibility(criteria: any): void {
      const clearButton = document.getElementById('clear-brands-button') as HTMLElement;
      if (clearButton) {
        const hasFilters = criteria.brands.length > 0 || criteria.availability;
        const filterCount = criteria.brands.length + (criteria.availability ? 1 : 0);
        
        // Update both visibility and text content
        clearButton.style.display = hasFilters ? 'block' : 'none';
        clearButton.textContent = `Clear All`; // Simplified text
        
        // Alternative: Show count if preferred
        // clearButton.textContent = filterCount > 0 ? `Clear (${filterCount})` : 'Clear All';
      }
    }
    
    public destroy(): void {
      // No infinite scroll observer to clean up
    }
    
    // Method for validation
    public getProductsCount(): number {
      return this.products ? this.products.length : 0;
    }
  }

  class ResponsiveFilters {
    private form: HTMLFormElement | null = null;
    private container: HTMLElement | null = null;
    private overlay: HTMLElement | null = null;
    private showMoreToggle: HTMLButtonElement | null = null;
    private isExpanded: boolean = false;
    private filterEngine: StreamlinedFilterEngine | null = null;

    constructor() {
      // Direct element assignment
      this.form = document.getElementById("filter-form") as HTMLFormElement;
      this.container = document.getElementById("filter-container");
      this.overlay = document.getElementById("mobile-filter-overlay");
      this.showMoreToggle = document.getElementById("show-more-toggle") as HTMLButtonElement;
      
      if (!this.form) {
        console.warn("[ResponsiveFilters] Form element not found. Filters may not work correctly.");
        return;
      }
      
      // Initialize immediately with progressive enhancement
      this.setupEventListeners();
      this.initializeMenuState();
      
      // Initialize filter engine when ProductGrid is ready (with fallback)
      this.initializeWithGridReady();
    }
    
    private initializeWithGridReady(): void {
      let gridReady = false;
      
      const enableFiltering = () => {
        if (!gridReady) {
          gridReady = true;
          this.enableFilterControls();
          this.initializeFilterEngine();
        }
      };
      
      // Listen for ProductGrid ready event
      document.addEventListener('productGridReady', enableFiltering);
      
      // Fallback timeout for reliability
      setTimeout(() => {
        if (!gridReady) {
          console.log('[ResponsiveFilters] ‚è∞ Grid ready timeout - enabling filters anyway');
          enableFiltering();
        }
      }, 2000); // Reduced from 3 seconds
    }
    
    private enableFilterControls(): void {
      // Progressive enhancement: Controls start enabled, just log readiness
      console.log('[ResponsiveFilters] ‚úÖ Filter controls ready (progressive enhancement)');
    }
    
    private initializeFilterEngine(): void {
      // Enable streamlined client-side filtering - NO infinite scroll
      try {
        this.filterEngine = new StreamlinedFilterEngine();
        console.log('[ResponsiveFilters] ‚úÖ Streamlined filtering enabled (infinite scroll handled by ProductGrid)');
        
      } catch (error) {
        console.error('[ResponsiveFilters] ‚ùå Filter engine initialization failed:', error);
        this.filterEngine = null;
      }
    }

    private setupEventListeners(): void {
      this.setupMobileDrawer();
      this.setupDesktopFiltering();
      this.setupShowMoreToggle();
      this.setupClearButtons();
    }

    private setupMobileDrawer(): void {
      const toggle = document.getElementById("mobile-filter-toggle");
      const close = document.getElementById("mobile-filter-close");

      toggle?.addEventListener("click", () => this.openMobileDrawer());
      close?.addEventListener("click", () => this.closeMobileDrawer());
      this.overlay?.addEventListener("click", () => this.closeMobileDrawer());
    }

    private openMobileDrawer(): void {
      this.overlay?.classList.remove("pointer-events-none", "opacity-0");
      this.container?.classList.remove("translate-y-full", "opacity-0", "pointer-events-none");
      document.body.style.overflow = "hidden";
    }

    private closeMobileDrawer(): void {
      this.overlay?.classList.add("opacity-0");
      this.container?.classList.add("translate-y-full", "opacity-0");
      
      // Use transitionend event instead of fixed timeout
      const handleTransitionEnd = () => {
        this.overlay?.classList.add("pointer-events-none");
        this.container?.classList.add("pointer-events-none");
        this.container?.removeEventListener('transitionend', handleTransitionEnd);
      };
      
      this.container?.addEventListener('transitionend', handleTransitionEnd);
      
      // Fallback timeout in case transitionend doesn't fire
      setTimeout(handleTransitionEnd, 350);
      
      document.body.style.overflow = "";
    }

    // SIMPLIFIED: Desktop filtering without infinite scroll complexity
    private setupDesktopFiltering(): void {
      if (!this.form) return;

      const checkboxes = this.form.querySelectorAll('input[type="checkbox"]');
      
      checkboxes.forEach((checkbox) => {
        // Remove all existing event listeners by cloning the element
        const newCheckbox = checkbox.cloneNode(true) as HTMLInputElement;
        checkbox.parentNode?.replaceChild(newCheckbox, checkbox);
        
        newCheckbox.addEventListener("change", (event) => {
          console.log(`[ResponsiveFilters] Checkbox changed: ${(event.target as HTMLInputElement).name}=${(event.target as HTMLInputElement).value}, checked=${(event.target as HTMLInputElement).checked}`);
          
          // UNIFIED: Use client-side filtering for ALL devices
          if (this.filterEngine) {
            console.log('[ResponsiveFilters] üöÄ Using CLIENT-SIDE filtering for all devices');
            
            // PREVENT any form submission
            event.preventDefault();
            event.stopPropagation();
            event.stopImmediatePropagation();
            
            // Get current filter criteria and apply immediately
            const criteria = this.buildFilterCriteria();
            this.filterEngine.applyFilters(criteria);
            
            // Save menu state
            sessionStorage.setItem("filter-menu-expanded", this.isExpanded.toString());
            
            return false;
            
          } else {
            console.error('[ResponsiveFilters] ‚ùå Filter engine not available');
            // Only if client-side fails completely
            sessionStorage.setItem("filter-menu-expanded", this.isExpanded.toString());
            sessionStorage.setItem("filtering-in-progress", "true");
          }
        });
      });
      
      // CORRECTED: Unified client-side filtering for all devices
      this.form.addEventListener('submit', (event) => {
        console.log('[ResponsiveFilters] üìù FORM SUBMISSION INTERCEPTED');
        console.log('[ResponsiveFilters] üìù Event details:', {
          type: event.type,
          target: event.target,
          screenWidth: window.innerWidth,
          filterEngineAvailable: !!this.filterEngine
        });
        
        // ALWAYS prevent form submission - use client-side filtering on all devices
        event.preventDefault();
        event.stopPropagation();
        
        if (this.filterEngine) {
          console.log('[ResponsiveFilters] üéØ Using CLIENT-SIDE filtering for all devices');
          
          // Mobile: Close drawer first, then apply filters
          if (window.innerWidth < 1024) {
            this.closeMobileDrawer();
          }
          
          // Get current filter criteria and apply immediately
          const criteria = this.buildFilterCriteria();
          console.log('[ResponsiveFilters] üîç Filter criteria:', criteria);
          this.filterEngine.applyFilters(criteria);
          
          // Save menu state
          sessionStorage.setItem("filter-menu-expanded", this.isExpanded.toString());
          
          console.log('[ResponsiveFilters] ‚úÖ Client-side filtering complete');
          
          // DEBUGGING: Monitor for delayed actions
          let urlBefore = window.location.href;
          setTimeout(() => {
            if (window.location.href !== urlBefore) {
              console.log('[ResponsiveFilters] üö® DELAYED URL CHANGE DETECTED!', {
                before: urlBefore,
                after: window.location.href,
                timeDelta: '1 second after filtering'
              });
            }
          }, 1000);
          
          setTimeout(() => {
            if (window.location.href !== urlBefore) {
              console.log('[ResponsiveFilters] üö® DELAYED URL CHANGE DETECTED!', {
                before: urlBefore,
                after: window.location.href,
                timeDelta: '3 seconds after filtering'
              });
            }
          }, 3000);
        } else {
          console.error('[ResponsiveFilters] ‚ùå Filter engine not available');
        }
        
        return false;
      });
    }
    
    // Build filter criteria for client-side engine  
    private buildFilterCriteria(): any {
      if (!this.form) return { brands: [], availability: false };
      
      // Re-query form to get current checkboxes (in case they were cloned)
      const formData = new FormData(this.form);
      const brands = formData.getAll('brands') as string[];
      const availability = formData.get('availability') === 'true';
      
      return { brands, availability };
    }

    private setupShowMoreToggle(): void {
      if (!this.showMoreToggle) return;

      this.showMoreToggle.addEventListener("click", (e) => {
        e.preventDefault();
        this.isExpanded ? this.collapseFilters() : this.expandFilters();
        sessionStorage.setItem("filter-menu-expanded", this.isExpanded.toString());
      });
    }

    private initializeMenuState(): void {
      const initialExpanded = this.showMoreToggle?.dataset.initialExpanded === "true";
      const wasExpanded = sessionStorage.getItem("filter-menu-expanded") === "true";
      const shouldExpand = sessionStorage.getItem("filter-menu-expanded") !== null ? wasExpanded : initialExpanded;

      this.isExpanded = shouldExpand;

      setTimeout(() => {
        const filterList = document.querySelector('.brand-filter-list') as HTMLElement;
        if (filterList) {
          filterList.style.transition = '';
        }
      }, 100);
    }

    private collapseFilters(): void {
      const extraItems = document.querySelectorAll(".brand-extra-item");
      const collapsedText = this.showMoreToggle?.dataset.collapsedText || "+ Show more";

      extraItems.forEach((item) => {
        const element = item as HTMLElement;
        element.classList.add("lg:hidden");
      });

      if (this.showMoreToggle) this.showMoreToggle.textContent = collapsedText;
      this.isExpanded = false;
    }

    private expandFilters(): void {
      const extraItems = document.querySelectorAll(".brand-extra-item");
      const expandedText = this.showMoreToggle?.dataset.expandedText || "- Show less";

      extraItems.forEach((item) => {
        const element = item as HTMLElement;
        element.classList.remove("lg:hidden");
      });

      if (this.showMoreToggle) this.showMoreToggle.textContent = expandedText;
      this.isExpanded = true;
    }

    private setupClearButtons(): void {
      const clearBtn = document.querySelector("[data-clear-filters]");
      const clearBtnMobile = document.querySelector("[data-clear-filters-mobile]");

      // UNIFIED: Both desktop and mobile clear buttons use same logic as AppliedFilters
      clearBtn?.addEventListener("click", () => {
      const filterInstance = (window as any).currentFilterInstance;
      if (filterInstance?.clearAllFilters) {
        filterInstance.clearAllFilters();
      }
    });
      clearBtnMobile?.addEventListener("click", () => {
        // Close mobile drawer first, then clear
        this.closeMobileDrawer();
        const filterInstance = (window as any).currentFilterInstance;
        if (filterInstance?.clearAllFilters) {
          filterInstance.clearAllFilters();
        }
      });
    }

    public clearAllFilters(): void {
      console.log('[ResponsiveFilters] üßπ Clearing all filters');
      
      if (this.filterEngine) {
        // Clear checkboxes
        const checkboxes = this.form?.querySelectorAll('input[type="checkbox"]') as NodeListOf<HTMLInputElement>;
        checkboxes?.forEach(checkbox => checkbox.checked = false);
        
        // Apply empty filter criteria immediately
        const criteria = this.buildFilterCriteria();
        this.filterEngine.applyFilters(criteria);
        
        console.log('[ResponsiveFilters] ‚úÖ Filters cleared using client-side filtering');
      } else {
        console.error('[ResponsiveFilters] ‚ùå Filter engine not available');
        // Fallback: navigate to base URL without filters
        const basePath = window.location.pathname;
        window.location.href = basePath;
      }
    }

    // FIXED: Proper cleanup that restores initial drawer state
    destroy(): void {
      console.log('[ResponsiveFilters] üßπ Cleaning up');
      
      // Clean up DOM state
      document.body.style.overflow = "";
      
      // Clean up filter engine
      if (this.filterEngine) {
        this.filterEngine.destroy();
        this.filterEngine = null;
      }
      
      // FIXED: Reset mobile drawer to CLOSED state (not open)
      if (this.container) {
        // Ensure drawer is closed on mobile, visible on desktop
        this.container.classList.add("translate-y-full", "opacity-0", "pointer-events-none");
        this.container.classList.add("lg:translate-y-0", "lg:opacity-100", "lg:pointer-events-auto");
      }
      
      if (this.overlay) {
        // Ensure overlay is hidden
        this.overlay.classList.add("pointer-events-none", "opacity-0");
      }
      
      // Clean up session storage
      sessionStorage.removeItem("filtering-in-progress");
      
      console.log('[ResponsiveFilters] ‚úÖ Cleanup complete');
    }
  }

  // Store instance for cleanup on navigation
  let currentInstance: ResponsiveFilters | null = null;

  // Clean initialization that works with Astro navigation
  function initializeFilters() {
    // Clean up previous instance
    if (currentInstance) {
      currentInstance.destroy();
    }
    
    // Create new instance
    currentInstance = new ResponsiveFilters();
    
    // Expose instance globally for AppliedFilters access
    (window as any).currentFilterInstance = currentInstance;
    
    // DEBUGGING: Monitor all form submissions globally
    document.addEventListener('submit', (e) => {
      const target = e.target as HTMLElement;
      if (target?.id === 'filter-form') {
        console.log('[GLOBAL] üö® Form submission detected outside our handler!', {
          timestamp: Date.now(),
          target: e.target,
          defaultPrevented: e.defaultPrevented
        });
      }
    }, true); // Use capture to catch early
  }

  // Handle both initial load and Astro navigation
  document.addEventListener("astro:page-load", initializeFilters);
  
  // Enhanced Astro navigation cleanup with View Transitions support
  document.addEventListener("astro:before-preparation", () => {
    console.log('[ResponsiveFilters] üöÄ Enhanced Astro navigation cleanup');
    if (currentInstance) {
      currentInstance.destroy();
      currentInstance = null;
    }
    
    // Clean up any ongoing View Transitions
    sessionStorage.removeItem("filtering-in-progress");
  });

  // Initialize immediately if DOM is already ready
  if (document.readyState !== 'loading') {
    initializeFilters();
  }
</script>