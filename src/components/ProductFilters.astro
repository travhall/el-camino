---
// src/components/ProductFilters.astro - Enhanced with Phantom Click Prevention
import type { FilterOptions } from "@/lib/square/types";

interface Props {
  filterOptions: FilterOptions;
  totalProducts: number;
  filteredCount: number;
  categoryPath?: string;
}

const { filterOptions, totalProducts, filteredCount, categoryPath = "" } = Astro.props;

// Parse current filters from URL for server-side rendering
const currentParams = new URLSearchParams(Astro.url.search);
const currentBrands = currentParams.getAll("brands") || [];
const currentAvailability = currentParams.get("availability") === "true";
const currentPageSize = currentParams.get("pageSize") || "24";

// Configuration for show more/less functionality
const DEFAULT_VISIBLE_BRANDS = 6;
const shouldShowToggle = filterOptions.brands.length > DEFAULT_VISIBLE_BRANDS;

// FOUC Fix: Determine initial expanded state server-side
// Check if there are any selected brands beyond the default visible count
const hasSelectedBrandsBelow = currentBrands.some(brand => {
  const brandIndex = filterOptions.brands.findIndex(b => b.name === brand);
  return brandIndex >= DEFAULT_VISIBLE_BRANDS;
});

// Start expanded if user has selected brands that would be hidden
const shouldStartExpanded = hasSelectedBrandsBelow;
---

<!-- FOUC Prevention: Inline critical CSS -->
<style is:inline>
  /* Prevent flickering during initial load */
  .brand-filter-list {
    transition: none;
  }
  
  /* Phase 1: Phantom Click Prevention */
  .filters-processing {
    pointer-events: none;
    opacity: 0.6;
    transition: opacity 0.2s ease;
  }

  .filters-processing .filter-checkbox,
  .filters-processing .applied-filter-tag,
  .filters-processing .clear-button {
    cursor: not-allowed;
  }
  
  /* Processing indicator */
  .filter-processing-indicator {
    position: relative;
  }
  
  .filter-processing-indicator::after {
    content: "Processing...";
    position: absolute;
    top: 50%;
    left: 50%;
    transform: translate(-50%, -50%);
    background: var(--surface-secondary);
    padding: 0.5rem 1rem;
    border-radius: 0.25rem;
    font-size: 0.875rem;
    color: var(--content-meta);
    z-index: 10;
    box-shadow: 0 2px 8px rgba(0, 0, 0, 0.1);
  }
</style>

<!-- Single Responsive Form Container -->
<div class="relative lg:block bg-(--surface-primary)">
  <!-- Mobile Filter Button -->
  <button
    id="mobile-filter-toggle"
    class="lg:hidden fixed bottom-4 right-4 bg-(--surface-tertiary) text-(--content-body) border border-(--border-tertiary) rounded-md flex flex-row gap-2 p-4 shadow-lg z-250"
    aria-label="Open Filters"
  >
    Filters
    <svg class="w-5 h-5" fill="none" stroke="currentColor" viewBox="0 0 24 24">
      <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M3 4a1 1 0 011-1h16a1 1 0 011 1v2.586a1 1 0 01-.293.707l-6.414 6.414a1 1 0 00-.293.707V17l-4 4v-6.586a1 1 0 00-.293-.707L3.293 7.707A1 1 0 013 7V4z"></path>
    </svg>
    {currentBrands.length > 0 && (
      <span class="absolute -top-1 -right-1 bg-(--ui-button-surface) text-(--ui-button-text) font-bold text-sm rounded-full min-w-5 h-5 flex items-center justify-center px-1">
        {currentBrands.length}
      </span>
    )}
  </button>

  <!-- Mobile Overlay -->
  <div
    id="mobile-filter-overlay"
    class="lg:hidden fixed inset-0 bg-(--ui-modal-overlay)/80 backdrop-blur-sm z-40 opacity-0 pointer-events-none transition-opacity duration-300"
  ></div>

  <!-- Single Form - Desktop Static, Mobile Drawer -->
  <div
    id="filter-container"
    class="lg:static lg:transform-none lg:max-h-none fixed bottom-0 left-0 right-0 md:left-auto md:w-[28rem] lg:w-auto bg-(--surface-secondary) z-500 max-h-[80vh] overflow-y-auto transform translate-y-full lg:translate-y-0 opacity-0 lg:opacity-100 pointer-events-none lg:pointer-events-auto transition-all duration-300 lg:transition-none"
  >
    <form method="GET" action={categoryPath || ""} class="px-4 lg:p-2" id="filter-form">
      <input type="hidden" name="pageSize" value={currentPageSize} />

      <!-- Mobile Header -->
      <div class="flex items-center justify-between mb-4 p-6 -mx-4 bg-(--surface-secondary) border border-b-(--border-tertiary) sticky top-0 z-50 lg:hidden">
        <h2 class="text-lg font-semibold text-(--content-heading)">Filter Products</h2>
        <button type="button" id="mobile-filter-close" class="p-1 text-(--content-meta) hover:text-(--content-emphasis)" aria-label="Close Filters">
          <svg class="w-6 h-6" fill="none" stroke="currentColor" viewBox="0 0 24 24">
            <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M6 18L18 6M6 6l12 12"></path>
          </svg>
        </button>
      </div>

      <!-- Results Count - DAY 2: Enhanced for client-side updates -->
      <div class="min-w-fit mt-2 mb-4">
        <div class="lg:hidden p-3 bg-(--surface-tertiary) rounded-sm">
          <p class="text-sm text-(--content-meta)" data-result-count>
            {filteredCount} of {totalProducts} products
          </p>
        </div>
        <div class="hidden lg:block">
          <p class="text-sm lg:text-base text-(--content-meta) font-medium" data-result-count>
            {filteredCount === totalProducts
              ? `${totalProducts} products`
              : `${filteredCount} of ${totalProducts} products`
            }
          </p>
        </div>
      </div>

      <!-- Brand Filter Section -->
      {filterOptions.brands.length > 0 && (
        <div class="mb-6 lg:mb-4">
          <div class="flex items-center justify-between mb-3">
            <h3 class="text-xl font-medium font-display text-(--content-heading)">Brand</h3>
            <button
              type="button"
              id="clear-brands-button"
              data-clear-filters
              class="text-sm text-(--content-meta) hover:text-(--content-emphasis) transition-colors lg:mr-2"
              style={currentBrands.length === 0 ? "display: none;" : ""}
            >
              Clear ({currentBrands.length})
            </button>
          </div>

          <!-- Brand List with FOUC Fix -->
          <div class="space-y-3 lg:space-y-1 max-h-64 lg:max-h-none overflow-y-auto lg:overflow-visible brand-filter-list" data-brand-list>
            {filterOptions.brands.map((brand, index) => {
              const isHidden = index >= DEFAULT_VISIBLE_BRANDS;
              // FOUC Fix: Apply server-side visibility logic
              const serverHiddenClass = isHidden && !shouldStartExpanded ? "lg:hidden" : "";

              return (
                <label
                  class={`flex items-center justify-between group cursor-pointer p-3 lg:p-1 rounded-sm hover:bg-(--surface-tertiary) lg:hover:bg-(--surface-secondary) transition-colors ${isHidden ? `brand-extra-item ${serverHiddenClass}` : ""}`}
                >
                  <div class="flex items-center">
                    <input
                      type="checkbox"
                      name="brands"
                      value={brand.name}
                      checked={currentBrands.includes(brand.name)}
                      class="elco-checkbox mr-3 lg:mr-2 w-5 h-5 lg:w-4 lg:h-4 rounded-sm border-2 border-(--ui-input-border) text-ui-accent focus:ring-2 focus:ring-ui-accent focus:ring-offset-0"
                    />
                    <span class="text-(--content-body) group-hover:text-(--content-emphasis)">
                      {brand.name}
                    </span>
                  </div>
                  <span class="text-sm text-(--content-meta) lg:mr-2">({brand.count})</span>
                </label>
              );
            })}

            {shouldShowToggle && (
              <button
                type="button"
                id="show-more-toggle"
                class="hidden lg:block w-full text-left text-sm text-ui-accent hover:text-ui-accent-hover transition-colors p-1 font-medium"
                data-collapsed-text={`+ Show ${filterOptions.brands.length - DEFAULT_VISIBLE_BRANDS} more`}
                data-expanded-text="- Show less"
                data-initial-expanded={shouldStartExpanded.toString()}
              >
                {shouldStartExpanded 
                  ? "- Show less"
                  : `+ Show ${filterOptions.brands.length - DEFAULT_VISIBLE_BRANDS} more`
                }
              </button>
            )}
          </div>
        </div>
      )}

      <!-- Availability Filter Section -->
      <div class="mb-6 lg:mb-4">
        <h3 class="text-xl font-medium font-display text-(--content-heading) mb-3">Availability</h3>

        <label class="flex items-center group cursor-pointer p-3 lg:p-1 rounded-sm hover:bg-(--surface-tertiary) lg:hover:bg-(--surface-secondary) transition-colors">
          <input
            type="checkbox"
            name="availability"
            value="true"
            checked={currentAvailability}
            class="elco-checkbox mr-3 lg:mr-2 w-5 h-5 lg:w-4 lg:h-4 rounded-sm border-2 border-(--ui-input-border) text-ui-accent focus:ring-2 focus:ring-ui-accent focus:ring-offset-0"
          />
          <span class="text-(--content-body) group-hover:text-(--content-emphasis)">
            In stock only
          </span>
        </label>
      </div>

      <!-- Mobile Actions -->
      <div class="flex gap-3 p-6 -mx-4 bg-(--surface-secondary) border-t-(--border-tertiary) sticky bottom-0 lg:hidden">
        {(currentBrands.length > 0 || currentAvailability) && (
          <button
            type="button"
            data-clear-filters-mobile
            class="flex-1 py-3 px-4 border border-(--ui-button-border) text-ui-button-border rounded-sm hover:bg-ui-button-hover transition-colors text-center"
          >
            Clear Filters
          </button>
        )}
        <button
          type="submit"
          class="flex-1 py-3 px-4 bg-(--ui-button-surface) text-(--ui-button-text) rounded-sm hover:bg-ui-button-primary-hover transition-colors font-medium"
        >
          Apply Filters
        </button>
      </div>
    </form>
  </div>
</div>

<script>
  // DAY 2: Ultimate Filter Engine - Eliminates FOUT and Phantom Clicks 
  // cSpell:ignore FOUT
  class UltimateFilterEngine {
    private allProducts: any[] = [];
    private filteredProducts: any[] = [];
    private visibleProducts: any[] = [];
    private visibleCount: number = 24;
    private infiniteScrollObserver: IntersectionObserver | null = null;
    
    constructor() {
      this.initializeData();
      // ALWAYS setup infinite scroll to maintain smooth UX
      this.setupInfiniteScroll();
    }
    
    private initializeData(): void {
      const grid = document.getElementById("filterable-product-grid");
      if (!grid) {
        console.error("[UltimateFilterEngine] ‚ùå Could not find filterable-product-grid element");
        return;
      }
      
      try {
        const allProductsData = grid.dataset.allProducts;
        if (!allProductsData) {
          console.error("[UltimateFilterEngine] ‚ùå No allProducts data found in grid dataset");
          this.fallbackToServerSide();
          return;
        }
        
        this.allProducts = JSON.parse(allProductsData);
        this.filteredProducts = [...this.allProducts];
        this.visibleProducts = this.filteredProducts.slice(0, this.visibleCount);
        
        console.log(`[UltimateFilterEngine] ‚úÖ Initialized with ${this.allProducts.length} products`);
        
        // Show infinite scroll trigger if more products available
        if (this.hasMoreProducts()) {
          const trigger = document.getElementById("infinite-scroll-trigger");
          if (trigger) {
            trigger.style.display = "flex";
          }
        }
      } catch (error) {
        console.error("[UltimateFilterEngine] ‚ùå Failed to parse allProducts data:", error);
        this.fallbackToServerSide();
      }
    }
    
    // INSTANT client-side filtering - ELIMINATES FOUT
    public applyFilters(criteria: any): void {
      const startTime = performance.now();
      
      console.log(`[UltimateFilterEngine] STARTING CLIENT-SIDE FILTER: brands=${criteria.brands.join(',')}, availability=${criteria.availability}`);
      
      // IMMEDIATE: Block all interactions to prevent phantom clicks
      this.blockAllInteractions();
      
      // CRITICAL: Ensure pagination stays hidden during filtering
      this.forceHidePagination();
      
      // Filter products instantly using embedded data
      this.filteredProducts = this.allProducts.filter(product => {
        // Brand filtering
        if (criteria.brands.length > 0) {
          if (!criteria.brands.includes(product.brand)) {
            return false;
          }
        }
        
        // Availability filtering
        if (criteria.availability) {
          if (product.inventoryStatus?.isOutOfStock) {
            return false;
          }
        }
        
        return true;
      });
      
      // Reset visible count and update products
      this.visibleCount = Math.min(24, this.filteredProducts.length);
      this.visibleProducts = this.filteredProducts.slice(0, this.visibleCount);
      
      // Update DOM instantly
      this.updateProductGrid();
      this.updateResultCount();
      this.updateInfiniteScrollTrigger();
      this.updateAppliedFilters(criteria);
      this.updateClearButtonVisibility(criteria);
      
      // Unblock interactions after update
      this.unblockInteractions();
      
      const duration = performance.now() - startTime;
      console.log(`[UltimateFilterEngine] ‚úÖ COMPLETED: Filtered ${this.allProducts.length} ‚Üí ${this.filteredProducts.length} products in ${duration.toFixed(1)}ms`);
    }
    
    // CRITICAL: Aggressively hide pagination to prevent flashing
    private forceHidePagination(): void {
      const pagination = document.getElementById('server-side-pagination') as HTMLElement;
      if (pagination) {
        pagination.style.display = 'none !important';
        pagination.style.visibility = 'hidden';
        pagination.setAttribute('aria-hidden', 'true');
      }
      
      // Also hide any other pagination elements that might exist
      const allPagination = document.querySelectorAll('[data-pagination], .pagination, nav[aria-label*="pagination"]');
      allPagination.forEach(el => {
        (el as HTMLElement).style.display = 'none';
        (el as HTMLElement).style.visibility = 'hidden';
      });
    }
    
    private updateAppliedFilters(criteria: any): void {
      // Update AppliedFilters component for client-side filtering
      const appliedFiltersContainer = document.getElementById('applied-filters-container') as HTMLElement;
      const appliedFiltersContent = document.getElementById('applied-filters-content') as HTMLElement;
      
      if (!appliedFiltersContainer || !appliedFiltersContent) return;
      
      const hasFilters = criteria.brands.length > 0 || criteria.availability;
      
      if (!hasFilters) {
        // Hide container when no filters
        appliedFiltersContainer.style.display = 'none';
        return;
      }
      
      // Show container and clear existing content
      appliedFiltersContainer.style.display = 'block';
      appliedFiltersContent.innerHTML = '';
      
      // Create filters wrapper
      const filtersWrapper = document.createElement('div');
      filtersWrapper.className = 'flex flex-wrap gap-2';
      
      // Add brand filters
      criteria.brands.forEach((brand: string) => {
        const filterTag = document.createElement('button');
        filterTag.className = 'inline-flex items-center px-2.5 py-1.5 text-sm border rounded-full bg-(--surface-primary) hover:bg-(--surface-tertiary) transition-colors text-(--ui-input-text) border-(--ui-input-border)/50 group';
        filterTag.innerHTML = `
          <span>${brand}</span>
          <svg class="w-3 h-3 ml-1 text-(--content-meta) group-hover:text-(--content-body)" fill="none" stroke="currentColor" viewBox="0 0 24 24">
            <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M6 18L18 6M6 6l12 12"></path>
          </svg>
        `;
        filterTag.addEventListener('click', () => {
          // Remove this brand and reapply filters
          const checkbox = document.querySelector(`input[name="brands"][value="${brand}"]`) as HTMLInputElement;
          if (checkbox) {
            checkbox.checked = false;
            checkbox.dispatchEvent(new Event('change', { bubbles: true }));
          }
        });
        filtersWrapper.appendChild(filterTag);
      });
      
      // Add availability filter
      if (criteria.availability) {
        const filterTag = document.createElement('button');
        filterTag.className = 'inline-flex items-center px-2.5 py-1.5 text-sm border rounded-full bg-(--state-success-surface) hover:bg-(--state-success-surface)/75 transition-colors text-(--state-success-text) border-(--state-success-text)/50 group';
        filterTag.innerHTML = `
          <span>In stock only</span>
          <svg class="w-3 h-3 ml-1 text-(--state-success-text)/70 group-hover:text-(--state-success-text)" fill="none" stroke="currentColor" viewBox="0 0 24 24">
            <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M6 18L18 6M6 6l12 12"></path>
          </svg>
        `;
        filterTag.addEventListener('click', () => {
          // Remove availability filter and reapply
          const checkbox = document.querySelector('input[name="availability"]') as HTMLInputElement;
          if (checkbox) {
            checkbox.checked = false;
            checkbox.dispatchEvent(new Event('change', { bubbles: true }));
          }
        });
        filtersWrapper.appendChild(filterTag);
      }
      
      // Add clear all button - SAME LOGIC AS ProductFilters Clear
      const clearAllButton = document.createElement('button');
      clearAllButton.className = 'text-sm text-(--content-meta) hover:text-(--content-emphasis) transition-colors text-nowrap';
      clearAllButton.textContent = 'Clear All';
      clearAllButton.addEventListener('click', () => {
        // Use exact same method as ProductFilters Clear button
        const responsiveFilters = (window as any).currentFilterInstance;
        if (responsiveFilters && responsiveFilters.clearAllFilters) {
          responsiveFilters.clearAllFilters();
        }
      });
      
      appliedFiltersContent.appendChild(filtersWrapper);
      appliedFiltersContent.appendChild(clearAllButton);
    }
    
    private updateClearButtonVisibility(criteria: any): void {
      const clearButton = document.getElementById('clear-brands-button') as HTMLElement;
      if (clearButton) {
        const hasFilters = criteria.brands.length > 0 || criteria.availability;
        clearButton.style.display = hasFilters ? 'block' : 'none';
      }
    }
    
    private updateProductGrid(): void {
      const grid = document.getElementById("filterable-product-grid");
      if (!grid) return;
      
      console.log(`[UltimateFilterEngine] Updating to show ${this.visibleProducts.length} products`);
      
      // Get all existing product wrappers
      const allWrappers = Array.from(grid.querySelectorAll('.product-card-wrapper'));
      
      // Create Set of visible product IDs
      const visibleProductIds = new Set(this.visibleProducts.map(p => p.id));
      
      // Show/hide products using display (not opacity/visibility)
      allWrappers.forEach((wrapper, index) => {
        const productId = wrapper.getAttribute('data-product-id');
        const isVisible = visibleProductIds.has(productId);
        
        if (isVisible) {
          // Show product
          (wrapper as HTMLElement).style.display = '';
          wrapper.classList.add('opacity-100', 'scale-100');
          wrapper.classList.remove('opacity-0', 'scale-95');
        } else {
          // Hide product
          (wrapper as HTMLElement).style.display = 'none';
        }
      });
      
      this.updateNoResultsState();
      console.log(`[UltimateFilterEngine] ‚úÖ Now showing ${this.visibleProducts.length} products`);
    }
    
    private updateResultCount(): void {
      const resultElements = document.querySelectorAll('[data-result-count]');
      resultElements.forEach(element => {
        const totalProducts = this.allProducts.length;
        const filteredCount = this.filteredProducts.length;
        
        if (filteredCount === totalProducts) {
          element.textContent = `${totalProducts} products`;
        } else {
          element.textContent = `${filteredCount} of ${totalProducts} products`;
        }
      });
    }
    
    private updateNoResultsState(): void {
      const noResults = document.getElementById("no-results");
      const grid = document.getElementById("filterable-product-grid");
      
      if (this.filteredProducts.length === 0) {
        noResults?.classList.remove("hidden");
        grid?.classList.add("hidden");
      } else {
        noResults?.classList.add("hidden");
        grid?.classList.remove("hidden");
      }
    }
    
    private setupInfiniteScroll(): void {
      const trigger = document.getElementById("infinite-scroll-trigger");
      if (!trigger) return;
      
      let isLoading = false;
      
      this.infiniteScrollObserver = new IntersectionObserver((entries) => {
        entries.forEach(entry => {
          if (entry.isIntersecting && this.hasMoreProducts() && !isLoading) {
            isLoading = true;
            console.log(`[UltimateFilterEngine] üìú Loading more products...`);
            
            // Use QuickView loading pattern for consistency
            trigger.innerHTML = `
              <div class="col-span-full text-center py-8 flex flex-row gap-2 justify-center items-center my-4">
                <div class="inline-block animate-spin rounded-full h-4 w-4 border-b-2 border-(--content-heading)">
                </div>
                <p class="text-(--content-meta)">Loading more products...</p>
              </div>
            `;
            
            // Load more products with timeout to ensure completion
            setTimeout(() => {
              try {
                this.loadMoreProducts();
                isLoading = false;
                console.log(`[UltimateFilterEngine] ‚úÖ Products loaded successfully`);
              } catch (error) {
                console.error(`[UltimateFilterEngine] ‚ùå Loading failed:`, error);
                isLoading = false;
                this.updateInfiniteScrollTrigger(); // Reset trigger on error
              }
            }, 600);
          }
        });
      }, { 
        threshold: 0.1,
        rootMargin: "50px"
      });
      
      this.infiniteScrollObserver.observe(trigger);
    }
    
    private hasMoreProducts(): boolean {
      const hasMore = this.visibleCount < this.filteredProducts.length;
      console.log(`[UltimateFilterEngine] hasMoreProducts: ${hasMore} (${this.visibleCount} < ${this.filteredProducts.length})`);
      return hasMore;
    }
    
    private loadMoreProducts(): void {
      // CRITICAL: Ensure pagination stays hidden during scroll loading
      this.forceHidePagination();
      
      const nextBatch = 24;
      const previousVisibleCount = this.visibleCount;
      const newVisibleCount = Math.min(
        this.visibleCount + nextBatch, 
        this.filteredProducts.length
      );
      
      console.log(`[UltimateFilterEngine] Loading batch: ${previousVisibleCount} ‚Üí ${newVisibleCount} of ${this.filteredProducts.length}`);
      
      if (newVisibleCount === this.visibleCount) {
        console.log(`[UltimateFilterEngine] ‚ö†Ô∏è No more products to load`);
        return;
      }
      
      // Update visible products array
      this.visibleCount = newVisibleCount;
      this.visibleProducts = this.filteredProducts.slice(0, this.visibleCount);
      
      // CRITICAL: Update the grid to show more products
      this.updateProductGrid();
      
      // CRITICAL: Update infinite scroll trigger state
      this.updateInfiniteScrollTrigger();
      
      console.log(`[UltimateFilterEngine] ‚úÖ Successfully loaded: now showing ${this.visibleCount}/${this.filteredProducts.length}`);
    }
    
    private updateInfiniteScrollTrigger(): void {
      const trigger = document.getElementById("infinite-scroll-trigger") as HTMLElement;
      if (!trigger) return;
      
      const hasMore = this.hasMoreProducts();
      console.log(`[UltimateFilterEngine] Trigger update: hasMore=${hasMore}, visible=${this.visibleCount}/${this.filteredProducts.length}`);
      
      if (hasMore) {
        // CRITICAL: Clear loading content and set to invisible trigger state
        trigger.innerHTML = '';
        trigger.style.display = "flex";
        trigger.style.visibility = "visible";
        trigger.style.height = "20px"; // Small invisible trigger
        
        console.log(`[UltimateFilterEngine] üìú Trigger cleared and ready for intersection`);
      } else {
        // All products loaded - hide trigger completely
        trigger.style.display = "none";
        trigger.style.visibility = "hidden";
        trigger.innerHTML = "";
        console.log(`[UltimateFilterEngine] ‚úÖ All products loaded - trigger hidden`);
      }
    }
    
    // CRITICAL: Immediate interaction blocking prevents phantom clicks
    private blockAllInteractions(): void {
      const filterContainer = document.getElementById("filter-container");
      filterContainer?.classList.add("filters-processing");
      
      // Visual feedback during processing
      const processingIndicator = document.createElement('div');
      processingIndicator.id = 'filter-processing-indicator';
      processingIndicator.className = 'fixed top-4 right-4 bg-(--surface-secondary) border border-(--border-tertiary) rounded-md px-3 py-2 shadow-lg z-50';
      processingIndicator.innerHTML = `
        <div class="flex items-center space-x-2">
          <div class="animate-spin rounded-full h-4 w-4 border-2 border-ui-accent border-t-transparent"></div>
          <span class="text-sm text-(--content-body)">Filtering...</span>
        </div>
      `;
      document.body.appendChild(processingIndicator);
    }
    
    private unblockInteractions(): void {
      const filterContainer = document.getElementById("filter-container");
      filterContainer?.classList.remove("filters-processing");
      
      // Remove processing indicator
      const indicator = document.getElementById('filter-processing-indicator');
      if (indicator) {
        indicator.remove();
      }
    }
    
    private fallbackToServerSide(): void {
      console.warn("[FilterEngine] Falling back to server-side filtering");
      const form = document.getElementById("filter-form") as HTMLFormElement;
      if (form) form.submit();
    }
    
    public destroy(): void {
      if (this.infiniteScrollObserver) {
        this.infiniteScrollObserver.disconnect();
      }
    }
    
    // Method for validation
    public getAllProductsCount(): number {
      return this.allProducts ? this.allProducts.length : 0;
    }
  }

  class ResponsiveFilters {
    private form: HTMLFormElement | null = null;
    private container: HTMLElement | null = null;
    private overlay: HTMLElement | null = null;
    private showMoreToggle: HTMLButtonElement | null = null;
    private isExpanded: boolean = false;
    private filterEngine: UltimateFilterEngine | null = null; // DAY 2: Add filter engine
    private _isClearing: boolean = false; // Prevent infinite recursion in clearAllFilters
    private debounceTimer: number | null = null; // Debounce filter operations

    constructor() {
      // Direct element assignment - no setTimeout delays
      this.form = document.getElementById("filter-form") as HTMLFormElement;
      this.container = document.getElementById("filter-container");
      this.overlay = document.getElementById("mobile-filter-overlay");
      this.showMoreToggle = document.getElementById("show-more-toggle") as HTMLButtonElement;
      
      if (!this.form) {
        console.warn("ProductFilters: Form element not found. Filters may not work correctly.");
        return;
      }
      
      // SOLUTION: Wait for ProductGrid with timeout fallback for slow networks
      let gridReadyFired = false;
      
      document.addEventListener('productGridReady', () => {
        if (!gridReadyFired) {
          gridReadyFired = true;
          this.initializeFilterEngine();
        }
      });
      
      // Fallback timeout for slow networks (3 seconds)
      setTimeout(() => {
        if (!gridReadyFired) {
          console.log('[ResponsiveFilters] ‚è∞ Grid ready timeout - initializing filter engine anyway');
          gridReadyFired = true;
          this.initializeFilterEngine();
        }
      }, 3000);
      
      this.setupEventListeners();
      this.initializeMenuState();
    }
    
    private initializeFilterEngine(): void {
      // ALWAYS enable client-side filtering to prevent FOUT and phantom clicks
      try {
        this.filterEngine = new UltimateFilterEngine();
        console.log('[ResponsiveFilters] ‚úÖ Client-side filtering enabled for all devices');
        
        // Always hide pagination when client-side filtering is active
        const pagination = document.getElementById('server-side-pagination') as HTMLElement;
        if (pagination) {
          pagination.style.display = 'none';
          console.log('[ResponsiveFilters] üö´ Server-side pagination hidden');
        }
        
        // Validate engine has data
        const productCount = this.filterEngine && this.filterEngine.getAllProductsCount ? this.filterEngine.getAllProductsCount() : 0;
        if (productCount === 0) {
          console.warn('[ResponsiveFilters] ‚ö†Ô∏è Filter engine has no products - fallback may be needed');
        }
        
      } catch (error) {
        console.error('[ResponsiveFilters] ‚ùå Filter engine initialization failed:', error);
        this.filterEngine = null;
        
        // Still hide pagination to prevent FOUT
        const pagination = document.getElementById('server-side-pagination') as HTMLElement;
        if (pagination) {
          pagination.style.display = 'none';
        }
      }
    }

    private setupEventListeners(): void {
      this.setupMobileDrawer();
      this.setupDesktopFiltering();
      this.setupShowMoreToggle();
      this.setupClearButtons();
    }

    private setupMobileDrawer(): void {
      const toggle = document.getElementById("mobile-filter-toggle");
      const close = document.getElementById("mobile-filter-close");

      toggle?.addEventListener("click", () => this.openMobileDrawer());
      close?.addEventListener("click", () => this.closeMobileDrawer());
      this.overlay?.addEventListener("click", () => this.closeMobileDrawer());
    }

    private openMobileDrawer(): void {
      this.overlay?.classList.remove("pointer-events-none", "opacity-0");
      this.container?.classList.remove("translate-y-full", "opacity-0", "pointer-events-none");
      document.body.style.overflow = "hidden";
    }

    private closeMobileDrawer(): void {
      this.overlay?.classList.add("opacity-0");
      this.container?.classList.add("translate-y-full", "opacity-0");
      
      // Use transitionend event instead of fixed timeout
      const handleTransitionEnd = () => {
        this.overlay?.classList.add("pointer-events-none");
        this.container?.classList.add("pointer-events-none");
        this.container?.removeEventListener('transitionend', handleTransitionEnd);
      };
      
      this.container?.addEventListener('transitionend', handleTransitionEnd);
      
      // Fallback timeout in case transitionend doesn't fire
      setTimeout(handleTransitionEnd, 350);
      
      document.body.style.overflow = "";
    }

    // DAY 2: Enhanced Desktop Filtering with INSTANT client-side filtering
    // ELIMINATES FOUT: No page reloads ever  
    // ELIMINATES PHANTOM CLICKS: Immediate interaction blocking
    private setupDesktopFiltering(): void {
      if (!this.form) return;

      const checkboxes = this.form.querySelectorAll('input[type="checkbox"]');
      
      checkboxes.forEach((checkbox) => {
        // CRITICAL: Remove all existing event listeners by cloning the element
        const newCheckbox = checkbox.cloneNode(true) as HTMLInputElement;
        checkbox.parentNode?.replaceChild(newCheckbox, checkbox);
        
        newCheckbox.addEventListener("change", (event) => {
          console.log(`[ResponsiveFilters] Checkbox changed: ${(event.target as HTMLInputElement).name}=${(event.target as HTMLInputElement).value}, checked=${(event.target as HTMLInputElement).checked}`);
          
          if (window.innerWidth >= 1024 && this.filterEngine) {
            console.log('[ResponsiveFilters] üöÄ Using CLIENT-SIDE filtering');
            
            // PREVENT page reload completely
            event.preventDefault();
            event.stopPropagation();
            event.stopImmediatePropagation();
            
            // Get current filter criteria
            const criteria = this.buildFilterCriteria();
            
            // Apply filters with debouncing (150ms) for smooth UX
            this.debouncedApplyFilters(criteria);
            
            // Save menu state
            sessionStorage.setItem("filter-menu-expanded", this.isExpanded.toString());
            
            return false; // Extra prevention
            
          } else {
            console.log('[ResponsiveFilters] üì± Using SERVER-SIDE filtering');
            // Mobile: use existing server-side approach
            sessionStorage.setItem("filter-menu-expanded", this.isExpanded.toString());
            sessionStorage.setItem("filtering-in-progress", "true");
            this.form?.submit();
          }
        });
      });
      
      // ALSO prevent form submission at form level
      this.form.addEventListener('submit', (event) => {
        if (window.innerWidth >= 1024 && this.filterEngine) {
          event.preventDefault();
          event.stopPropagation();
          console.log('[ResponsiveFilters] Prevented form submission - using client-side filtering');
          return false;
        }
      });
    }
    
    // DAY 2: Build filter criteria for client-side engine
    private buildFilterCriteria(): any {
      // CRITICAL: Prevent infinite recursion during clearAllFilters
      if (this._isClearing) {
        return { brands: [], availability: false };
      }
      
      if (!this.form) return { brands: [], availability: false };
      
      // Re-query form to get current checkboxes (in case they were cloned)
      const formData = new FormData(this.form);
      const brands = formData.getAll('brands') as string[];
      const availability = formData.get('availability') === 'true';
      
      console.log(`[ResponsiveFilters] Building criteria: brands=${brands.join(',')}, availability=${availability}`);
      
      return { brands, availability };
    }

    // Add debouncing to prevent excessive filter operations
    private debouncedApplyFilters(criteria: any): void {
      if (this.debounceTimer) {
        clearTimeout(this.debounceTimer);
      }
      
      this.debounceTimer = setTimeout(() => {
        this.filterEngine?.applyFilters(criteria);
        this.debounceTimer = null;
      }, 150); // 150ms debounce
    }

    // Phase 1: Block all filter interactions immediately
    private blockAllFilterInteractions(): void {
      // Block filter container interactions
      const filterContainer = document.getElementById("filter-container");
      const appliedFilters = document.querySelector(".applied-filters");
      
      filterContainer?.classList.add("filters-processing");
      appliedFilters?.classList.add("filters-processing");
      
      // Activate existing skeleton system
      this.activateExistingSkeletons();
      
      // Show processing indicator
      this.showProcessingFeedback();
    }

    // Phase 1: Leverage existing skeleton infrastructure
    private activateExistingSkeletons(): void {
      const productGrid = document.getElementById("filterable-product-grid");
      const skeleton = document.getElementById("product-grid-skeleton");
      
      if (productGrid && skeleton) {
        // Use existing pattern from ProductGrid
        productGrid.style.transition = "opacity 0.3s ease";
        productGrid.style.opacity = "0.5";
        
        // Activate skeleton (follows existing pattern)
        skeleton.style.display = "grid";
        skeleton.classList.remove("hidden");
        skeleton.classList.add("grid");
      }
    }

    // Phase 1: Visual processing feedback
    private showProcessingFeedback(): void {
      const filterContainer = document.getElementById("filter-container");
      if (filterContainer) {
        filterContainer.classList.add("filter-processing-indicator");
      }
    }

    private setupShowMoreToggle(): void {
      if (!this.showMoreToggle) return;

      this.showMoreToggle.addEventListener("click", (e) => {
        e.preventDefault();
        this.isExpanded ? this.collapseFilters() : this.expandFilters();
        sessionStorage.setItem("filter-menu-expanded", this.isExpanded.toString());
      });
    }

    private initializeMenuState(): void {
      const initialExpanded = this.showMoreToggle?.dataset.initialExpanded === "true";
      const wasExpanded = sessionStorage.getItem("filter-menu-expanded") === "true";
      const shouldExpand = sessionStorage.getItem("filter-menu-expanded") !== null ? wasExpanded : initialExpanded;

      this.isExpanded = shouldExpand;

      setTimeout(() => {
        const filterList = document.querySelector('.brand-filter-list') as HTMLElement;
        if (filterList) {
          filterList.style.transition = '';
        }
      }, 100);
    }

    private collapseFilters(): void {
      const extraItems = document.querySelectorAll(".brand-extra-item");
      const collapsedText = this.showMoreToggle?.dataset.collapsedText || "+ Show more";

      extraItems.forEach((item) => {
        const element = item as HTMLElement;
        element.classList.add("lg:hidden");
      });

      if (this.showMoreToggle) this.showMoreToggle.textContent = collapsedText;
      this.isExpanded = false;
    }

    private expandFilters(): void {
      const extraItems = document.querySelectorAll(".brand-extra-item");
      const expandedText = this.showMoreToggle?.dataset.expandedText || "- Show less";

      extraItems.forEach((item) => {
        const element = item as HTMLElement;
        element.classList.remove("lg:hidden");
      });

      if (this.showMoreToggle) this.showMoreToggle.textContent = expandedText;
      this.isExpanded = true;
    }

    private setupClearButtons(): void {
      const clearBtn = document.querySelector("[data-clear-filters]");
      const clearBtnMobile = document.querySelector("[data-clear-filters-mobile]");

      clearBtn?.addEventListener("click", () => this.clearBrandFilters());
      clearBtnMobile?.addEventListener("click", () => this.clearAllFilters());
    }

    private clearBrandFilters(): void {
      if (window.innerWidth >= 1024 && this.filterEngine) {
        // DAY 2: Clear brand filters instantly with client-side filtering
        const checkboxes = this.form?.querySelectorAll('input[name="brands"]') as NodeListOf<HTMLInputElement>;
        checkboxes?.forEach(checkbox => {
          if (checkbox.checked) {
            checkbox.checked = false;
          }
        });
        
        // Apply filters instantly
        const criteria = this.buildFilterCriteria();
        this.filterEngine.applyFilters(criteria);
        
      } else {
        // Mobile: use existing server-side approach
        sessionStorage.removeItem("filter-menu-expanded");
        
        const currentParams = new URLSearchParams(window.location.search);
        const currentPageSize = currentParams.get("pageSize") || "24";
        const currentAvailability = currentParams.get("availability");
        
        const params = new URLSearchParams();
        if (currentPageSize !== "24") params.set("pageSize", currentPageSize);
        if (currentAvailability) params.set("availability", currentAvailability);

        this.navigateWithParams(params);
      }
    }

    public clearAllFilters(): void {
      if (window.innerWidth >= 1024 && this.filterEngine) {
        // CRITICAL: Prevent infinite recursion
        this._isClearing = true;
        
        const checkboxes = this.form?.querySelectorAll('input[type="checkbox"]') as NodeListOf<HTMLInputElement>;
        let hasChanges = false;
        
        checkboxes?.forEach(checkbox => {
          if (checkbox.checked) {
            checkbox.checked = false;
            hasChanges = true;
          }
        });
        
        // Clear flag before applying filters
        this._isClearing = false;
        
        // Only apply filters if there were actually changes
        if (hasChanges) {
          const criteria = this.buildFilterCriteria();
          this.filterEngine.applyFilters(criteria);
        }
        
      } else {
        // Mobile: use existing server-side approach
        sessionStorage.removeItem("filter-menu-expanded");

        const currentParams = new URLSearchParams(window.location.search);
        const currentPageSize = currentParams.get("pageSize") || "24";
        
        const params = new URLSearchParams();
        if (currentPageSize !== "24") params.set("pageSize", currentPageSize);

        this.navigateWithParams(params);
      }
    }

    private navigateWithParams(params: URLSearchParams): void {
      // Phase 1: Apply phantom click prevention for navigation too
      this.blockAllFilterInteractions();
      
      const queryString = params.toString();
      const basePath = window.location.pathname;
      const newUrl = `${basePath}${queryString ? "?" + queryString : ""}`;

      sessionStorage.setItem("filtering-in-progress", "true");
      window.location.href = newUrl;
    }

    // Cleanup method for navigation
    destroy(): void {
      document.body.style.overflow = "";
      
      // DAY 2: Clean up filter engine
      if (this.filterEngine) {
        this.filterEngine.destroy();
        this.filterEngine = null;
      }
      
      // Clean up any processing states
      const filterContainer = document.getElementById("filter-container");
      filterContainer?.classList.remove("filters-processing", "filter-processing-indicator");
      
      // Remove any processing indicators
      const indicator = document.getElementById('filter-processing-indicator');
      if (indicator) {
        indicator.remove();
      }
    }
  }

  // Store instance for cleanup on navigation
  let currentInstance: ResponsiveFilters | null = null;

  // Clean initialization that works with Astro navigation
  function initializeFilters() {
    // Clean up previous instance
    if (currentInstance) {
      currentInstance.destroy();
    }
    
    // Create new instance
    currentInstance = new ResponsiveFilters();
    
    // Expose instance globally for AppliedFilters access
    (window as any).currentFilterInstance = currentInstance;
  }

  // Handle both initial load and Astro navigation
  document.addEventListener("astro:page-load", initializeFilters);
  
  // Cleanup on navigation away
  document.addEventListener("astro:before-preparation", () => {
    if (currentInstance) {
      currentInstance.destroy();
      currentInstance = null;
    }
  });

  // Initialize immediately if DOM is already ready
  if (document.readyState !== 'loading') {
    initializeFilters();
  }
</script>
