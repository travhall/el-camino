---
// src/components/ProductFilters.astro - True AJAX filtering with no page reloads
import type { FilterOptions } from "@/lib/square/types";

interface Props {
  filterOptions: FilterOptions;
  totalProducts: number;
  filteredCount: number;
}

const { filterOptions, totalProducts, filteredCount } = Astro.props;

// Parse current filters from URL for server-side rendering
const currentParams = new URLSearchParams(Astro.url.search);
const currentBrands = currentParams.getAll("brands") || [];
const currentPageSize = currentParams.get("pageSize") || "24";

// Configuration for show more/less functionality
const DEFAULT_VISIBLE_BRANDS = 6;
const shouldShowToggle = filterOptions.brands.length > DEFAULT_VISIBLE_BRANDS;
---

<!-- Desktop Filter Sidebar -->
<div class="lg:block bg-surface-primary">
  <div class="hidden lg:block p-2 overflow-y-auto" id="desktop-filter-container">
    <!-- Results Count -->
    <div class="mb-4 pb-4 border-b-2 border-border-primary">
      <p class="text-lg text-content-body font-medium" id="results-counter">
        {filteredCount === totalProducts 
          ? `${totalProducts} products`
          : `${filteredCount} of ${totalProducts} products`
        }
      </p>
    </div>

    <!-- Brand Filter Section -->
    {
      filterOptions.brands.length > 0 && (
        <div class="mb-4">
          <div class="flex items-center justify-between mb-3">
            <h3 class="text-xl font-medium font-display text-content-heading">Brand</h3>
            {currentBrands.length > 0 && (
              <button
                type="button"
                data-clear-filters
                class="text-sm text-content-meta hover:text-content-emphasis transition-colors"
              >
                Clear
              </button>
            )}
          </div>

          <!-- Brand list with controlled visibility -->
          <div class="space-y-1" data-brand-list>
            {filterOptions.brands.map((brand, index) => {
              const isHidden = index >= DEFAULT_VISIBLE_BRANDS;
              return (
                <label
                  class={`flex items-center group cursor-pointer p-1 rounded-sm hover:bg-surface-secondary transition-colors ${isHidden ? "brand-extra-item hidden" : ""}`}
                >
                  <input
                    type="checkbox"
                    name="brands"
                    value={brand.name}
                    checked={currentBrands.includes(brand.name)}
                    data-filter-checkbox
                    class="elco-checkbox mr-2 w-4 h-4 rounded-sm border-2 border-ui-input-border text-ui-accent focus:ring-2 focus:ring-ui-accent focus:ring-offset-0"
                  />
                  <span class="flex-1 text-content-body group-hover:text-content-emphasis">
                    {brand.name}
                  </span>
                  <span class="text-sm text-content-meta mr-2">
                    ({brand.count})
                  </span>
                </label>
              );
            })}

            {shouldShowToggle && (
              <button
                type="button"
                id="show-more-toggle"
                class="w-full text-left text-sm text-ui-accent hover:text-ui-accent-hover transition-colors p-1 font-medium"
                data-collapsed-text={`+ Show ${filterOptions.brands.length - DEFAULT_VISIBLE_BRANDS} more`}
                data-expanded-text="- Show less"
              >
                + Show {filterOptions.brands.length - DEFAULT_VISIBLE_BRANDS} more
              </button>
            )}
          </div>
        </div>
      )
    }
  </div>
</div>

<!-- Mobile Filter Button -->
<button
  id="mobile-filter-toggle"
  class="lg:hidden fixed bottom-4 right-4 bg-ui-nav-surface text-ui-button-primary-text rounded-md flex flex-row gap-2 p-4 shadow-lg z-[250] transition-transform"
  aria-label="Open Filters"
>
  Filters
  <svg class="w-5 h-5" fill="none" stroke="currentColor" viewBox="0 0 24 24">
    <path
      stroke-linecap="round"
      stroke-linejoin="round"
      stroke-width="2"
      d="M3 4a1 1 0 011-1h16a1 1 0 011 1v2.586a1 1 0 01-.293.707l-6.414 6.414a1 1 0 00-.293.707V17l-4 4v-6.586a1 1 0 00-.293-.707L3.293 7.707A1 1 0 013 7V4z"
    ></path>
  </svg>
  {
    currentBrands.length > 0 && (
      <span class="absolute -top-1 -right-1 bg-ui-button-surface text-ui-button-text font-bold text-sm rounded-full min-w-[1.25rem] h-5 flex items-center justify-center px-1">
        {currentBrands.length}
      </span>
    )
  }
</button>

<!-- Mobile Drawer Overlay -->
<div
  id="mobile-filter-overlay"
  class="lg:hidden fixed inset-0 bg-surface-tertiary/80 dark:bg-surface-primary/80 backdrop-blur-sm z-40 transition-opacity duration-300 opacity-0 pointer-events-none"
>
</div>

<!-- Mobile Filter Drawer -->
<div
  id="mobile-filter-drawer"
  class="lg:hidden fixed bottom-0 left-0 right-0 bg-surface-secondary border-t border-ui-border z-[500] max-h-[80vh] overflow-y-auto transform translate-y-full transition-transform duration-300"
>
  <div class="p-4" id="mobile-filter-container">
    <!-- Mobile Header -->
    <div
      class="flex items-center justify-between mb-4 pb-4 border-b border-ui-border"
    >
      <h2 class="text-lg font-semibold text-content-heading">
        Filter Products
      </h2>
      <button
        type="button"
        id="mobile-filter-close"
        class="p-1 text-content-meta hover:text-content-emphasis"
        aria-label="Close Filters"
      >
        <svg
          class="w-6 h-6"
          fill="none"
          stroke="currentColor"
          viewBox="0 0 24 24"
        >
          <path
            stroke-linecap="round"
            stroke-linejoin="round"
            stroke-width="2"
            d="M6 18L18 6M6 6l12 12"></path>
        </svg>
      </button>
    </div>

    <!-- Results Count -->
    <div class="mb-4 p-3 bg-surface-tertiary rounded-sm">
      <p class="text-sm text-content-meta" id="mobile-results-counter">
        {filteredCount} of {totalProducts} products
      </p>
    </div>

    <!-- Mobile Brand Filter Section -->
    <div class="mb-6">
      <h3 class="text-base font-medium text-content-heading mb-3">Brand</h3>
      <div class="space-y-3 max-h-64 overflow-y-auto">
        {
          filterOptions.brands.map((brand) => (
            <label class="flex items-center justify-between group cursor-pointer p-3 rounded-sm hover:bg-surface-tertiary transition-colors">
              <div class="flex items-center">
                <input
                  type="checkbox"
                  name="brands"
                  value={brand.name}
                  checked={currentBrands.includes(brand.name)}
                  data-filter-checkbox
                  class="elco-checkbox mr-3 rounded-sm border-ui-input-border text-ui-accent focus:ring-ui-accent w-5 h-5"
                />
                <span class="text-content-body group-hover:text-content-emphasis">
                  {brand.name}
                </span>
              </div>
              <span class="text-sm text-content-meta">({brand.count})</span>
            </label>
          ))
        }
      </div>
    </div>

    <!-- Mobile Actions -->
    <div class="flex gap-3 pt-4 border-t border-ui-border">
      {
        currentBrands.length > 0 && (
          <button
            type="button"
            data-clear-filters-mobile
            class="flex-1 py-3 px-4 border border-ui-button-border text-ui-button-border rounded-sm hover:bg-ui-button-hover transition-colors text-center"
          >
            Clear Filters
          </button>
        )
      }
      <button
        type="button"
        id="apply-mobile-filters"
        class="flex-1 py-3 px-4 bg-ui-button-surface text-ui-button-text rounded-sm hover:bg-ui-button-primary-hover transition-colors font-medium"
      >
        Apply Filters
      </button>
    </div>
  </div>
</div>

<script>
  class AjaxFilters {
    private showMoreToggle: HTMLButtonElement | null;
    private isExpanded: boolean = false;
    private isLoading: boolean = false;
    private currentCategoryPath: string;

    constructor() {
      this.showMoreToggle = document.getElementById("show-more-toggle") as HTMLButtonElement;
      this.currentCategoryPath = window.location.pathname;
      
      this.setupAjaxFiltering();
      this.setupShowMoreToggle();
      this.setupMobileDrawer();
      this.setupClearButtons();
      this.setupAppliedFiltersAjax();
      this.initializeCollapsedState();
    }

    private initializeCollapsedState(): void {
      this.collapseFilters();
    }

    private setupAjaxFiltering(): void {
      // Desktop checkboxes
      const desktopCheckboxes = document.querySelectorAll('#desktop-filter-container [data-filter-checkbox]');
      desktopCheckboxes.forEach((checkbox) => {
        checkbox.addEventListener("change", () => {
          this.handleFilterChange();
        });
      });

      // Mobile checkboxes 
      const mobileCheckboxes = document.querySelectorAll('#mobile-filter-container [data-filter-checkbox]');
      mobileCheckboxes.forEach((checkbox) => {
        checkbox.addEventListener("change", () => {
          // For mobile, just update the apply button state
          this.updateMobileApplyButton();
        });
      });

      // Mobile apply button
      const applyButton = document.getElementById("apply-mobile-filters");
      applyButton?.addEventListener("click", () => {
        this.handleFilterChange();
        this.closeMobileDrawer();
      });
    }

    private async handleFilterChange(): Promise<void> {
      if (this.isLoading) return;

      this.isLoading = true;
      this.showLoadingState();

      try {
        const selectedBrands = this.getSelectedBrands();
        const newUrl = this.buildFilterUrl(selectedBrands);
        
        // Fetch filtered content
        const response = await fetch(newUrl.toString(), {
          headers: {
            'Accept': 'text/html',
            'X-Requested-With': 'XMLHttpRequest'
          }
        });

        if (!response.ok) {
          throw new Error(`HTTP ${response.status}`);
        }

        const html = await response.text();
        await this.updateContent(html);
        
        // Update URL without page reload
        history.pushState(null, '', newUrl);

      } catch (error) {
        console.error('Filter error:', error);
        this.showErrorState();
      } finally {
        this.isLoading = false;
        this.hideLoadingState();
      }
    }

    private getSelectedBrands(): string[] {
      const checkboxes = document.querySelectorAll('[data-filter-checkbox]:checked');
      return Array.from(checkboxes).map(cb => (cb as HTMLInputElement).value);
    }

    private buildFilterUrl(brands: string[]): URL {
      const url = new URL(window.location.href);
      url.search = '';
      
      const currentPageSize = new URLSearchParams(window.location.search).get("pageSize") || "24";
      if (currentPageSize !== "24") {
        url.searchParams.set("pageSize", currentPageSize);
      }

      brands.forEach(brand => {
        url.searchParams.append("brands", brand);
      });

      return url;
    }

    private async updateContent(html: string): Promise<void> {
      const parser = new DOMParser();
      const newDoc = parser.parseFromString(html, 'text/html');
      
      // Extract new product grid
      const newGrid = newDoc.querySelector('#filterable-product-grid');
      const currentGrid = document.querySelector('#filterable-product-grid');
      
      if (newGrid && currentGrid) {
        // Use your existing fade animation
        (currentGrid as HTMLElement).style.opacity = '0';
        
        await new Promise(resolve => setTimeout(resolve, 300));
        
        // Replace content
        currentGrid.innerHTML = newGrid.innerHTML;
        
        // Fade back in with your existing animation
        (currentGrid as HTMLElement).style.opacity = '1';
        
        // Update results counter
        this.updateResultsCounter(newDoc);
        
        // Update applied filters
        await this.updateAppliedFilters(newDoc);
      }
    }

    private updateResultsCounter(newDoc: Document): void {
      // Update desktop results counter
      const newCounter = newDoc.querySelector('#results-counter');
      const currentCounter = document.querySelector('#results-counter');
      
      if (newCounter && currentCounter) {
        currentCounter.textContent = newCounter.textContent;
      }
      
      // Update mobile results counter
      const newMobileCounter = newDoc.querySelector('#mobile-results-counter');
      const currentMobileCounter = document.querySelector('#mobile-results-counter');
      
      if (newMobileCounter && currentMobileCounter) {
        currentMobileCounter.textContent = newMobileCounter.textContent;
      }
      
      // Also update any other results counters on the page
      const allResultsElements = document.querySelectorAll('.text-lg.text-content-body.font-medium');
      const newResultsElements = newDoc.querySelectorAll('.text-lg.text-content-body.font-medium');
      
      allResultsElements.forEach((element, index) => {
        if (newResultsElements[index] && element.textContent?.includes('products')) {
          element.textContent = newResultsElements[index].textContent;
        }
      });
    }

    private async updateAppliedFilters(newDoc: Document): Promise<void> {
      // Update applied filters section
      const newAppliedFilters = newDoc.querySelector('.mb-1.p-2.bg-surface-primary');
      const currentAppliedFilters = document.querySelector('.mb-1.p-2.bg-surface-primary');
      
      if (newAppliedFilters && currentAppliedFilters) {
        currentAppliedFilters.innerHTML = newAppliedFilters.innerHTML;
      } else if (!newAppliedFilters && currentAppliedFilters) {
        // No applied filters in new content - remove the current ones
        currentAppliedFilters.remove();
      } else if (newAppliedFilters && !currentAppliedFilters) {
        // New applied filters but none currently - insert before product grid
        const grid = document.querySelector('#filterable-product-grid');
        if (grid) {
          grid.parentNode?.insertBefore(newAppliedFilters.cloneNode(true), grid);
        }
      }
    }

    private showLoadingState(): void {
      const resultsCounter = document.querySelector('#results-counter');
      if (resultsCounter && !resultsCounter.textContent?.includes("Filtering")) {
        resultsCounter.setAttribute('data-original-text', resultsCounter.textContent || '');
        resultsCounter.textContent = "Filtering...";
      }

      // Show your existing skeletons
      const grid = document.querySelector('#filterable-product-grid') as HTMLElement;
      if (grid) {
        grid.style.opacity = '0.6';
        grid.style.pointerEvents = 'none';
      }
    }

    private hideLoadingState(): void {
      const resultsCounter = document.querySelector('#results-counter');
      const originalText = resultsCounter?.getAttribute('data-original-text');
      if (originalText && resultsCounter) {
        resultsCounter.textContent = originalText;
        resultsCounter.removeAttribute('data-original-text');
      }

      const grid = document.querySelector('#filterable-product-grid') as HTMLElement;
      if (grid) {
        grid.style.pointerEvents = '';
      }
    }

    private setupAppliedFiltersAjax(): void {
      // Intercept applied filter links to use AJAX
      document.addEventListener('click', async (e) => {
        const target = e.target as HTMLElement;
        const link = target.closest('a[href*="category/"]') as HTMLAnchorElement;
        
        // Only handle applied filter links (they contain filter parameters)
        if (link && (link.href.includes('brands=') || link.href.includes('pageSize='))) {
          e.preventDefault();
          
          try {
            this.showLoadingState();
            
            const response = await fetch(link.href, {
              headers: {
                'Accept': 'text/html',
                'X-Requested-With': 'XMLHttpRequest'
              }
            });

            if (!response.ok) throw new Error(`HTTP ${response.status}`);

            const html = await response.text();
            await this.updateContent(html);
            
            // Update URL and checkboxes
            history.pushState(null, '', link.href);
            this.syncCheckboxesFromURL();
            
          } catch (error) {
            console.error('Applied filter error:', error);
            this.showErrorState();
          } finally {
            this.hideLoadingState();
          }
        }
      });
    }

    private syncCheckboxesFromURL(): void {
      const urlParams = new URLSearchParams(window.location.search);
      const activeBrands = urlParams.getAll('brands');
      
      // Update all checkboxes to match URL state
      const checkboxes = document.querySelectorAll('[data-filter-checkbox]');
      checkboxes.forEach(checkbox => {
        const input = checkbox as HTMLInputElement;
        input.checked = activeBrands.includes(input.value);
      });
    }

    private showErrorState(): void {
      const resultsCounter = document.querySelector('#results-counter');
      if (resultsCounter) {
        resultsCounter.textContent = "Error loading filters. Please try again.";
      }
    }

    private setupShowMoreToggle(): void {
      if (!this.showMoreToggle) return;

      this.showMoreToggle.addEventListener("click", (e) => {
        e.preventDefault();
        e.stopPropagation();

        if (this.isExpanded) {
          this.collapseFilters();
        } else {
          this.expandFilters();
        }
      });
    }

    private collapseFilters(): void {
      const extraItems = document.querySelectorAll(".brand-extra-item");
      const collapsedText = this.showMoreToggle?.dataset.collapsedText || "+ Show more";

      extraItems.forEach((item) => {
        (item as HTMLElement).classList.add("hidden");
      });

      if (this.showMoreToggle) {
        this.showMoreToggle.textContent = collapsedText;
      }

      this.isExpanded = false;
    }

    private expandFilters(): void {
      const extraItems = document.querySelectorAll(".brand-extra-item");
      const expandedText = this.showMoreToggle?.dataset.expandedText || "- Show less";

      extraItems.forEach((item) => {
        (item as HTMLElement).classList.remove("hidden");
      });

      if (this.showMoreToggle) {
        this.showMoreToggle.textContent = expandedText;
      }

      this.isExpanded = true;
    }

    private setupClearButtons(): void {
      const clearBtn = document.querySelector("[data-clear-filters]");
      clearBtn?.addEventListener("click", () => {
        this.clearAllFilters();
      });

      const clearBtnMobile = document.querySelector("[data-clear-filters-mobile]");
      clearBtnMobile?.addEventListener("click", () => {
        this.clearAllFilters();
      });
    }

    private async clearAllFilters(): Promise<void> {
      // Uncheck all checkboxes
      const checkboxes = document.querySelectorAll('[data-filter-checkbox]');
      checkboxes.forEach(cb => {
        (cb as HTMLInputElement).checked = false;
      });

      // Apply the clear
      await this.handleFilterChange();
    }

    private setupMobileDrawer(): void {
      const toggle = document.getElementById("mobile-filter-toggle");
      const drawer = document.getElementById("mobile-filter-drawer");
      const overlay = document.getElementById("mobile-filter-overlay");
      const close = document.getElementById("mobile-filter-close");

      toggle?.addEventListener("click", () => {
        this.openMobileDrawer();
      });

      overlay?.addEventListener("click", () => {
        this.closeMobileDrawer();
      });
      
      close?.addEventListener("click", () => {
        this.closeMobileDrawer();
      });
    }

    private openMobileDrawer(): void {
      const overlay = document.getElementById("mobile-filter-overlay");
      const drawer = document.getElementById("mobile-filter-drawer");
      
      overlay?.classList.remove("pointer-events-none", "opacity-0");
      drawer?.classList.remove("translate-y-full");
      document.body.style.overflow = "hidden";
    }

    private closeMobileDrawer(): void {
      const overlay = document.getElementById("mobile-filter-overlay");
      const drawer = document.getElementById("mobile-filter-drawer");
      
      overlay?.classList.add("opacity-0");
      drawer?.classList.add("translate-y-full");
      setTimeout(() => overlay?.classList.add("pointer-events-none"), 300);
      document.body.style.overflow = "";
    }

    private updateMobileApplyButton(): void {
      const applyButton = document.getElementById("apply-mobile-filters");
      const selectedCount = document.querySelectorAll('#mobile-filter-container [data-filter-checkbox]:checked').length;
      
      if (applyButton) {
        applyButton.textContent = selectedCount > 0 ? `Apply Filters (${selectedCount})` : "Apply Filters";
      }
    }
  }

  document.addEventListener("astro:page-load", () => {
    new AjaxFilters();
  });
</script>