---
// src/components/ProductFilters.astro - Enhanced with Phantom Click Prevention
import type { FilterOptions } from "@/lib/square/types";

interface Props {
  filterOptions: FilterOptions;
  totalProducts: number;
  filteredCount: number;
  categoryPath?: string;
}

const { filterOptions, totalProducts, filteredCount, categoryPath = "" } = Astro.props;

// Parse current filters from URL for server-side rendering
const currentParams = new URLSearchParams(Astro.url.search);
const currentBrands = currentParams.getAll("brands") || [];
const currentAvailability = currentParams.get("availability") === "true";
const currentPageSize = currentParams.get("pageSize") || "24";

// Configuration for show more/less functionality
const DEFAULT_VISIBLE_BRANDS = 6;
const shouldShowToggle = filterOptions.brands.length > DEFAULT_VISIBLE_BRANDS;

// FOUC Fix: Determine initial expanded state server-side
// Check if there are any selected brands beyond the default visible count
const hasSelectedBrandsBelow = currentBrands.some(brand => {
  const brandIndex = filterOptions.brands.findIndex(b => b.name === brand);
  return brandIndex >= DEFAULT_VISIBLE_BRANDS;
});

// Start expanded if user has selected brands that would be hidden
const shouldStartExpanded = hasSelectedBrandsBelow;
---

<style is:inline>
  /* Simple transitions only */
  .brand-filter-list {
    transition: none;
  }
  
  .product-card-wrapper[style*="display: none"] {
    display: none !important;
  }
  
  /* Disabled state styling for phantom click prevention */
  :disabled {
    opacity: 0.6;
    cursor: not-allowed;
    pointer-events: none;
  }
  
  /* Disabled button styling */
  button:disabled {
    opacity: 0.6;
    cursor: not-allowed;
    pointer-events: none;
  }
  
  /* Simple disabled container state */
  .filters-disabled {
    opacity: 0.6;
    pointer-events: none;
  }
</style>

<!-- Single Responsive Form Container -->
<div class="relative lg:block bg-(--surface-primary)">
  <!-- Mobile Filter Button -->
  <button
    id="mobile-filter-toggle"
    class="lg:hidden fixed bottom-4 right-4 bg-(--surface-tertiary) text-(--content-body) border border-(--border-tertiary) rounded-md flex flex-row gap-2 p-4 shadow-lg z-250"
    aria-label="Open Filters"
    disabled
  >
    Filters
    <svg class="w-5 h-5" fill="none" stroke="currentColor" viewBox="0 0 24 24">
      <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M3 4a1 1 0 011-1h16a1 1 0 011 1v2.586a1 1 0 01-.293.707l-6.414 6.414a1 1 0 00-.293.707V17l-4 4v-6.586a1 1 0 00-.293-.707L3.293 7.707A1 1 0 013 7V4z"></path>
    </svg>
    {currentBrands.length > 0 && (
      <span class="absolute -top-1 -right-1 bg-(--ui-button-surface) text-(--ui-button-text) font-bold text-sm rounded-full min-w-5 h-5 flex items-center justify-center px-1">
        {currentBrands.length}
      </span>
    )}
  </button>

  <!-- Mobile Overlay -->
  <div
    id="mobile-filter-overlay"
    class="lg:hidden fixed inset-0 bg-(--ui-modal-overlay)/80 backdrop-blur-sm z-40 opacity-0 pointer-events-none transition-opacity duration-300"
  ></div>

  <!-- Single Form - Desktop Static, Mobile Drawer -->
  <div
    id="filter-container"
    class="filters-disabled lg:static lg:transform-none lg:max-h-none fixed bottom-0 left-0 right-0 md:left-auto md:w-[28rem] lg:w-auto bg-(--surface-secondary) z-500 max-h-[80vh] overflow-y-auto transform translate-y-full lg:translate-y-0 opacity-0 lg:opacity-100 pointer-events-none lg:pointer-events-auto transition-all duration-300 lg:transition-none"
  >
    <form method="GET" action={categoryPath || ""} class="px-4 lg:p-2" id="filter-form">

      <!-- Mobile Header -->
      <div class="flex items-center justify-between mb-4 p-6 -mx-4 bg-(--surface-secondary) border border-b-(--border-tertiary) sticky top-0 z-50 lg:hidden">
        <h2 class="text-lg font-semibold text-(--content-heading)">Filter Products</h2>
        <button type="button" id="mobile-filter-close" class="p-1 text-(--content-meta) hover:text-(--content-emphasis)" aria-label="Close Filters">
          <svg class="w-6 h-6" fill="none" stroke="currentColor" viewBox="0 0 24 24">
            <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M6 18L18 6M6 6l12 12"></path>
          </svg>
        </button>
      </div>

      <!-- Results Count -->
      <div class="min-w-fit mt-2 mb-4">
        <div class="lg:hidden p-3 bg-(--surface-tertiary) rounded-sm">
          <p class="text-sm text-(--content-meta)" data-result-count>
            {filteredCount} of {totalProducts} products
          </p>
        </div>
        <div class="hidden lg:block">
          <p class="text-sm lg:text-base text-(--content-meta) font-medium" data-result-count>
            {filteredCount === totalProducts
              ? `${totalProducts} products`
              : `${filteredCount} of ${totalProducts} products`
            }
          </p>
        </div>
      </div>

      <!-- Brand Filter Section -->
      {filterOptions.brands.length > 0 && (
        <div class="mb-6 lg:mb-4">
          <div class="flex items-center justify-between mb-3">
            <h3 class="text-xl font-medium font-display text-(--content-heading)">Brand</h3>
            <button
              type="button"
              id="clear-brands-button"
              data-clear-filters
              disabled
              class="text-sm text-(--content-meta) hover:text-(--content-emphasis) transition-colors lg:mr-2"
              style={currentBrands.length === 0 ? "display: none;" : ""}
            >
              Clear ({currentBrands.length})
            </button>
          </div>

          <!-- Brand List with FOUC Fix -->
          <div class="space-y-3 lg:space-y-1 max-h-64 lg:max-h-none overflow-y-auto lg:overflow-visible brand-filter-list" data-brand-list>
            {filterOptions.brands.map((brand, index) => {
              const isHidden = index >= DEFAULT_VISIBLE_BRANDS;
              // FOUC Fix: Apply server-side visibility logic
              const serverHiddenClass = isHidden && !shouldStartExpanded ? "lg:hidden" : "";

              return (
                <label
                  class={`flex items-center justify-between group cursor-pointer p-3 lg:p-1 rounded-sm hover:bg-(--surface-tertiary) lg:hover:bg-(--surface-secondary) transition-colors ${isHidden ? `brand-extra-item ${serverHiddenClass}` : ""}`}
                >
                  <div class="flex items-center">
                    <input
                      type="checkbox"
                      name="brands"
                      value={brand.name}
                      checked={currentBrands.includes(brand.name)}
                      disabled
                      class="elco-checkbox mr-3 lg:mr-2 w-5 h-5 lg:w-4 lg:h-4 rounded-sm border-2 border-(--ui-input-border) text-ui-accent focus:ring-2 focus:ring-ui-accent focus:ring-offset-0"
                    />
                    <span class="text-(--content-body) group-hover:text-(--content-emphasis)">
                      {brand.name}
                    </span>
                  </div>
                  <span class="text-sm text-(--content-meta) lg:mr-2">({brand.count})</span>
                </label>
              );
            })}

            {shouldShowToggle && (
              <button
                type="button"
                id="show-more-toggle"
                class="hidden lg:block w-full text-left text-sm text-ui-accent hover:text-ui-accent-hover transition-colors p-1 font-medium"
                data-collapsed-text={`+ Show ${filterOptions.brands.length - DEFAULT_VISIBLE_BRANDS} more`}
                data-expanded-text="- Show less"
                data-initial-expanded={shouldStartExpanded.toString()}
              >
                {shouldStartExpanded 
                  ? "- Show less"
                  : `+ Show ${filterOptions.brands.length - DEFAULT_VISIBLE_BRANDS} more`
                }
              </button>
            )}
          </div>
        </div>
      )}

      <!-- Availability Filter Section -->
      <div class="mb-6 lg:mb-4">
        <h3 class="text-xl font-medium font-display text-(--content-heading) mb-3">Availability</h3>

        <label class="flex items-center group cursor-pointer p-3 lg:p-1 rounded-sm hover:bg-(--surface-tertiary) lg:hover:bg-(--surface-secondary) transition-colors">
          <input
            type="checkbox"
            name="availability"
            value="true"
            checked={currentAvailability}
            disabled
            class="elco-checkbox mr-3 lg:mr-2 w-5 h-5 lg:w-4 lg:h-4 rounded-sm border-2 border-(--ui-input-border) text-ui-accent focus:ring-2 focus:ring-ui-accent focus:ring-offset-0"
          />
          <span class="text-(--content-body) group-hover:text-(--content-emphasis)">
            In stock only
          </span>
        </label>
      </div>

      <!-- Mobile Actions -->
      <div class="flex gap-3 p-6 -mx-4 bg-(--surface-secondary) border-t-(--border-tertiary) sticky bottom-0 lg:hidden">
        {(currentBrands.length > 0 || currentAvailability) && (
          <button
            type="button"
            data-clear-filters-mobile
            disabled
            class="flex-1 py-3 px-4 border border-(--ui-button-border) text-ui-button-border rounded-sm hover:bg-ui-button-hover transition-colors text-center"
          >
            Clear Filters
          </button>
        )}
        <button
          type="submit"
          class="flex-1 py-3 px-4 bg-(--ui-button-surface) text-(--ui-button-text) rounded-sm hover:bg-ui-button-primary-hover transition-colors font-medium"
        >
          Apply Filters
        </button>
      </div>
    </form>
  </div>
</div>

<script>
  class StreamlinedFilterEngine {
  private products: any[] = [];
  private filteredProducts: any[] = [];
  private visibleProducts: any[] = [];
  private visibleCount: number = 0; // Will be set responsively in initializeProducts
  private infiniteScrollObserver: IntersectionObserver | null = null;
  
  constructor() {
    this.initializeProducts();
  }
    
  private initializeProducts(): void {
    const grid = document.getElementById("filterable-product-grid");
    
    // Use the correct data attributes set by ProductGrid
    const allProductsData = grid?.dataset.allProducts;
    const initialProductsData = grid?.dataset.initialProducts;
    
    if (!allProductsData && !initialProductsData) {
      console.warn("[StreamlinedFilterEngine] No product data found");
      return;
    }
    
    try {
      // Prefer allProducts for client-side filtering, fallback to initial products
      const productData = allProductsData || initialProductsData;
      if (!productData) {
        console.error("[StreamlinedFilterEngine] No valid product data available");
        return;
      }
      this.products = JSON.parse(productData);
      this.filteredProducts = [...this.products];
      
      // Set initial visible count responsively
      const initialBatchSize = this.getNextBatchSize() * 4; // Show ~4 rows initially
      this.visibleCount = Math.min(initialBatchSize, this.filteredProducts.length);
      this.visibleProducts = this.filteredProducts.slice(0, this.visibleCount);
      
      console.log(`[StreamlinedFilterEngine] Initialized with ${this.products.length} products, showing initial ${this.visibleCount} on ${this.calculateCardsPerRow()}-column grid`);
    } catch (error) {
      console.error("[StreamlinedFilterEngine] Failed to parse product data:", error);
    }
  }
    
  public applyFilters(criteria: any): void {
    // Simple, reliable filtering
    this.filteredProducts = this.products.filter(product => 
      this.matchesCriteria(product, criteria)
    );
    
    // Reset visible count and products for new filter - use responsive sizing
    const initialBatchSize = this.getNextBatchSize() * 4; // Show ~4 rows initially after filtering
    this.visibleCount = Math.min(initialBatchSize, this.filteredProducts.length);
    this.visibleProducts = this.filteredProducts.slice(0, this.visibleCount);
    
    // Simple DOM updates
    this.updateProductGrid();
    this.updateResultCount();
    this.updateAppliedFilters(criteria);
    this.updateClearButtonVisibility(criteria);
    this.updateNoResultsState();
    
    // Setup infinite scroll if needed
    this.setupInfiniteScroll();
    this.updateInfiniteScrollTrigger();
  }
  
  private matchesCriteria(product: any, criteria: any): boolean {
    // Brand filtering
    if (criteria.brands.length > 0 && !criteria.brands.includes(product.brand)) {
      return false;
    }
    
    // Availability filtering
    if (criteria.availability && product.inventoryStatus?.isOutOfStock) {
      return false;
    }
    
    return true;
  }
    
  private updateProductGrid(): void {
    const grid = document.getElementById("filterable-product-grid");
    if (!grid) return;
    
    const allWrappers = Array.from(grid.querySelectorAll('.product-card-wrapper'));
    const visibleProductIds = new Set(this.visibleProducts.map(p => p.id));

    // Get animation timing using fixed CSS parsing
    const { duration, staggerDelay } = this.getAnimationTiming();

    // Step 1: Exit all cards
    allWrappers.forEach((wrapper) => {
      wrapper.classList.remove('opacity-100');
      wrapper.classList.add('opacity-0');
    });

    // Step 2: Show/hide and animate visible cards
    setTimeout(() => {
      let visibleIndex = 0;
      
      allWrappers.forEach((wrapper) => {
        const productId = wrapper.getAttribute('data-product-id');
        const isVisible = visibleProductIds.has(productId);

        if (isVisible) {
          // Show card and animate in with stagger
          (wrapper as HTMLElement).style.display = '';
          
          setTimeout(() => {
            wrapper.classList.remove('opacity-0');
            wrapper.classList.add('opacity-100');
          }, visibleIndex * staggerDelay);
          
          visibleIndex++;
        } else {
          // Hide card completely
          (wrapper as HTMLElement).style.display = 'none';
        }
      });
      
    }, duration);
  }
  
  private updateResultCount(): void {
    const resultElements = document.querySelectorAll('[data-result-count]');
    resultElements.forEach(element => {
      const totalProducts = this.products.length;
      const filteredCount = this.filteredProducts.length;
      
      if (filteredCount === totalProducts) {
        element.textContent = `${totalProducts} products`;
      } else {
        element.textContent = `${filteredCount} of ${totalProducts} products`;
      }
    });
  }
  
  private updateNoResultsState(): void {
    const noResults = document.getElementById("no-results");
    const grid = document.getElementById("filterable-product-grid");
    
    if (this.filteredProducts.length === 0) {
      noResults?.classList.remove("hidden");
      grid?.classList.add("hidden");
    } else {
      noResults?.classList.add("hidden");
      grid?.classList.remove("hidden");
    }
  }
  
  // Responsive batch calculation based on current grid layout
  private calculateCardsPerRow(): number {
    const screenWidth = window.innerWidth;
    console.log(`[StreamlinedFilterEngine] Screen width: ${screenWidth}px`);
    
    if (screenWidth >= 1536) return 6; // 2xl
    if (screenWidth >= 1280) return 4; // xl  
    if (screenWidth >= 1024) return 3; // lg
    if (screenWidth >= 768) return 2;  // md
    return 2; // default
  }

  private getNextBatchSize(): number {
    const cardsPerRow = this.calculateCardsPerRow();
    const batchSize = cardsPerRow * 2; // Load 2 rows at a time for smooth experience
    console.log(`[StreamlinedFilterEngine] Calculated batch size: ${batchSize} (${cardsPerRow} cards per row √ó 2 rows)`);
    return batchSize;
  }

  // Fixed CSS parsing for animation timing
  private getAnimationTiming() {
    const style = getComputedStyle(document.documentElement);
    
    // Properly parse duration (handles "0.3s", "300ms", etc.)
    const durationStr = style.getPropertyValue('--card-transition-duration').trim();
    console.log(`[StreamlinedFilterEngine] CSS duration value: "${durationStr}"`);
    const duration = durationStr.includes('ms') 
      ? parseInt(durationStr.replace('ms', ''))
      : parseFloat(durationStr.replace('s', '')) * 1000;
    
    // Properly parse stagger delay (handles "50ms", "0ms", etc.)
    const staggerStr = style.getPropertyValue('--card-stagger-delay').trim();
    console.log(`[StreamlinedFilterEngine] CSS stagger value: "${staggerStr}"`);
    const staggerDelay = parseInt(staggerStr.replace('ms', '')) || 0;
    
    console.log(`[StreamlinedFilterEngine] Parsed timing - Duration: ${duration}ms, Stagger: ${staggerDelay}ms`);
    
    return {
      duration: duration || 300,
      staggerDelay: staggerDelay
    };
  }

  private hasMoreProducts(): boolean {
    const hasMore = this.visibleCount < this.filteredProducts.length;
    console.log(`[StreamlinedFilterEngine] hasMoreProducts: ${hasMore} (${this.visibleCount} < ${this.filteredProducts.length})`);
    return hasMore;
  }
  
  private loadMoreProducts(): void {
    const nextBatch = this.getNextBatchSize(); // Responsive batch size
    const previousVisibleCount = this.visibleCount;
    const newVisibleCount = Math.min(
      this.visibleCount + nextBatch, 
      this.filteredProducts.length
    );
    
    console.log(`[StreamlinedFilterEngine] Loading batch: ${previousVisibleCount} ‚Üí ${newVisibleCount} of ${this.filteredProducts.length} (${nextBatch} cards on ${this.calculateCardsPerRow()}-column grid)`);
    
    if (newVisibleCount === this.visibleCount) {
      console.log(`[StreamlinedFilterEngine] ‚ö†Ô∏è No more products to load`);
      return;
    }
    
    // Update visible products array
    this.visibleCount = newVisibleCount;
    this.visibleProducts = this.filteredProducts.slice(0, this.visibleCount);
    
    // Show newly loaded products with animation
    this.loadMoreProductsWithAnimation(previousVisibleCount, newVisibleCount);
    
    // Update infinite scroll trigger state
    this.updateInfiniteScrollTrigger();
    
    console.log(`[StreamlinedFilterEngine] ‚úÖ Successfully loaded: now showing ${this.visibleCount}/${this.filteredProducts.length}`);
  }
  
  private loadMoreProductsWithAnimation(previousCount: number, newCount: number): void {
    const grid = document.getElementById("filterable-product-grid");
    if (!grid) return;
    
    const allWrappers = Array.from(grid.querySelectorAll('.product-card-wrapper'));
    const newlyVisibleProducts = this.visibleProducts.slice(previousCount, newCount);
    
    // Get animation timing using fixed CSS parsing
    const { duration, staggerDelay } = this.getAnimationTiming();
    
    console.log(`[StreamlinedFilterEngine] Animating ${newlyVisibleProducts.length} newly loaded cards with ${staggerDelay}ms stagger`);
    
    // First, prepare all cards in initial state
    const wrappersToAnimate: HTMLElement[] = [];
    newlyVisibleProducts.forEach((product) => {
      const wrapper = allWrappers.find(w => w.getAttribute('data-product-id') === product.id) as HTMLElement;
      if (wrapper) {
        wrapper.classList.add('animating');
        wrapper.classList.remove('opacity-100');
        wrapper.classList.add('opacity-0');
        wrapper.style.display = '';
        wrappersToAnimate.push(wrapper);
      } else {
        console.warn(`[StreamlinedFilterEngine] Could not find wrapper for product ${product.id}`);
      }
    });
    
    console.log(`[StreamlinedFilterEngine] Found ${wrappersToAnimate.length} wrappers to animate`);
    
    // Then animate them with proper stagger using sequential timing
    wrappersToAnimate.forEach((wrapper, index) => {
      const animationDelay = index * staggerDelay;
      console.log(`[StreamlinedFilterEngine] Card ${index}: scheduling animation in ${animationDelay}ms`);
      
      setTimeout(() => {
        console.log(`[StreamlinedFilterEngine] Card ${index}: animating now`);
        wrapper.classList.remove('opacity-0');
        wrapper.classList.add('opacity-100');
        
        // Clean up animation state after transition completes
        setTimeout(() => {
          wrapper.classList.remove('animating');
        }, duration);
        
      }, animationDelay);
    });
  }
  
  private updateInfiniteScrollTrigger(): void {
    const trigger = document.getElementById("infinite-scroll-trigger") as HTMLElement;
    if (!trigger) return;
    
    const hasMore = this.hasMoreProducts();
    console.log(`[StreamlinedFilterEngine] Trigger update: hasMore=${hasMore}, visible=${this.visibleCount}/${this.filteredProducts.length}`);
    
    if (hasMore) {
      // Clear loading content and set to invisible trigger state
      trigger.innerHTML = '';
      trigger.style.display = "flex";
      trigger.style.visibility = "visible";
      trigger.style.height = "20px"; // Small invisible trigger
      
      console.log(`[StreamlinedFilterEngine] üìú Trigger cleared and ready for intersection`);
    } else {
      // All products loaded - hide trigger completely
      trigger.style.display = "none";
      trigger.style.visibility = "hidden";
      trigger.innerHTML = "";
      console.log(`[StreamlinedFilterEngine] ‚úÖ All products loaded - trigger hidden`);
    }
  }
  
  private setupInfiniteScroll(): void {
    const trigger = document.getElementById("infinite-scroll-trigger");
    if (!trigger) return;
    
    let isLoading = false;
    
    if (this.infiniteScrollObserver) {
      this.infiniteScrollObserver.disconnect();
    }
    
    this.infiniteScrollObserver = new IntersectionObserver((entries) => {
      entries.forEach(entry => {
        if (entry.isIntersecting && this.hasMoreProducts() && !isLoading) {
          isLoading = true;
          console.log(`[StreamlinedFilterEngine] üìú Loading more products...`);
          
          // Show loading state
          trigger.innerHTML = `
            <div class="col-span-full text-center py-8 flex flex-row gap-2 justify-center items-center my-4">
              <div class="inline-block animate-spin rounded-full h-4 w-4 border-b-2 border-(--content-heading)">
              </div>
              <p class="text-(--content-meta)">Loading more products...</p>
            </div>
          `;
          
          // Use requestAnimationFrame for smooth loading - no artificial delays
          requestAnimationFrame(() => {
            try {
              this.loadMoreProducts();
              isLoading = false;
              console.log(`[StreamlinedFilterEngine] ‚úÖ Products loaded successfully`);
            } catch (error) {
              console.error(`[StreamlinedFilterEngine] ‚ùå Loading failed:`, error);
              isLoading = false;
              this.updateInfiniteScrollTrigger(); // Reset trigger on error
            }
          });
        }
      });
    }, { 
      threshold: 0.1,
      rootMargin: "150px" // Larger margin for smoother fast scrolling
    });
    
    this.infiniteScrollObserver.observe(trigger);
  }
    
    private updateAppliedFilters(criteria: any): void {
      // Update AppliedFilters component for client-side filtering
      const appliedFiltersContainer = document.getElementById('applied-filters-container') as HTMLElement;
      const appliedFiltersContent = document.getElementById('applied-filters-content') as HTMLElement;
      
      if (!appliedFiltersContainer || !appliedFiltersContent) return;
      
      const hasFilters = criteria.brands.length > 0 || criteria.availability;
      
      if (!hasFilters) {
        // Use CSS Grid animation to hide
        appliedFiltersContainer.classList.remove('filters-open');
        // Clear content after animation completes
        setTimeout(() => {
          if (!appliedFiltersContainer.classList.contains('filters-open')) {
            appliedFiltersContent.innerHTML = '';
          }
        }, 300);
        return;
      }
      
      // Show container using CSS Grid animation and populate content
      appliedFiltersContent.innerHTML = '';
      appliedFiltersContainer.classList.add('filters-open');
      
      // Create filters wrapper
      const filtersWrapper = document.createElement('div');
      filtersWrapper.className = 'flex flex-wrap gap-2';
      
      // Add brand filters
      criteria.brands.forEach((brand: string) => {
        const filterTag = document.createElement('button');
        filterTag.className = 'inline-flex items-center px-2.5 py-1.5 text-sm border rounded-full bg-(--surface-primary) hover:bg-(--surface-tertiary) transition-colors text-(--ui-input-text) border-(--ui-input-border)/50 group';
        filterTag.innerHTML = `
          <span>${brand}</span>
          <svg class="w-3 h-3 ml-1 text-(--content-meta) group-hover:text-(--content-body)" fill="none" stroke="currentColor" viewBox="0 0 24 24">
            <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M6 18L18 6M6 6l12 12"></path>
          </svg>
        `;
        filterTag.addEventListener('click', () => {
          // Remove this brand and reapply filters
          const checkbox = document.querySelector(`input[name="brands"][value="${brand}"]`) as HTMLInputElement;
          if (checkbox) {
            checkbox.checked = false;
            checkbox.dispatchEvent(new Event('change', { bubbles: true }));
          }
        });
        filtersWrapper.appendChild(filterTag);
      });
      
      // Add availability filter
      if (criteria.availability) {
        const filterTag = document.createElement('button');
        filterTag.className = 'inline-flex items-center px-2.5 py-1.5 text-sm border rounded-full bg-(--state-success-surface) hover:bg-(--state-success-surface)/75 transition-colors text-(--state-success-text) border-(--state-success-text)/50 group';
        filterTag.innerHTML = `
          <span>In stock only</span>
          <svg class="w-3 h-3 ml-1 text-(--state-success-text)/70 group-hover:text-(--state-success-text)" fill="none" stroke="currentColor" viewBox="0 0 24 24">
            <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M6 18L18 6M6 6l12 12"></path>
          </svg>
        `;
        filterTag.addEventListener('click', () => {
          // Remove availability filter and reapply
          const checkbox = document.querySelector('input[name="availability"]') as HTMLInputElement;
          if (checkbox) {
            checkbox.checked = false;
            checkbox.dispatchEvent(new Event('change', { bubbles: true }));
          }
        });
        filtersWrapper.appendChild(filterTag);
      }
      
      // Add clear all button - SAME LOGIC AS ProductFilters Clear
      const clearAllButton = document.createElement('button');
      clearAllButton.className = 'text-sm text-(--content-meta) hover:text-(--content-emphasis) transition-colors text-nowrap';
      clearAllButton.textContent = 'Clear All';
      clearAllButton.addEventListener('click', () => {
        // Use exact same method as ProductFilters Clear button
        const responsiveFilters = (window as any).currentFilterInstance;
        if (responsiveFilters && responsiveFilters.clearAllFilters) {
          responsiveFilters.clearAllFilters();
        }
      });
      
      appliedFiltersContent.appendChild(filtersWrapper);
      appliedFiltersContent.appendChild(clearAllButton);
    }
    
    private updateClearButtonVisibility(criteria: any): void {
      const clearButton = document.getElementById('clear-brands-button') as HTMLElement;
      if (clearButton) {
        const hasFilters = criteria.brands.length > 0 || criteria.availability;
        const filterCount = criteria.brands.length + (criteria.availability ? 1 : 0);
        
        // Update both visibility and text content
        clearButton.style.display = hasFilters ? 'block' : 'none';
        clearButton.textContent = `Clear All`; // Simplified text
        
        // Alternative: Show count if preferred
        // clearButton.textContent = filterCount > 0 ? `Clear (${filterCount})` : 'Clear All';
      }
    }
    
    public destroy(): void {
      if (this.infiniteScrollObserver) {
        this.infiniteScrollObserver.disconnect();
      }
    }
    
    // Method for validation
    public getProductsCount(): number {
      return this.products ? this.products.length : 0;
    }
  }

  class ResponsiveFilters {
    private form: HTMLFormElement | null = null;
    private container: HTMLElement | null = null;
    private overlay: HTMLElement | null = null;
    private showMoreToggle: HTMLButtonElement | null = null;
    private isExpanded: boolean = false;
    private filterEngine: StreamlinedFilterEngine | null = null;

    constructor() {
      // Direct element assignment - no setTimeout delays
      this.form = document.getElementById("filter-form") as HTMLFormElement;
      this.container = document.getElementById("filter-container");
      this.overlay = document.getElementById("mobile-filter-overlay");
      this.showMoreToggle = document.getElementById("show-more-toggle") as HTMLButtonElement;
      
      if (!this.form) {
        console.warn("ProductFilters: Form element not found. Filters may not work correctly.");
        return;
      }
      
      // SOLUTION: Wait for ProductGrid with timeout fallback for slow networks
      let gridReadyFired = false;
      
      document.addEventListener('productGridReady', () => {
        if (!gridReadyFired) {
          gridReadyFired = true;
          this.enableFilterControls();
          this.initializeFilterEngine();
        }
      });
      
      // Fallback timeout for slow networks (3 seconds)
      setTimeout(() => {
        if (!gridReadyFired) {
          console.log('[ResponsiveFilters] ‚è∞ Grid ready timeout - enabling filters anyway');
          gridReadyFired = true;
          this.enableFilterControls();
          this.initializeFilterEngine();
        }
      }, 3000);
      
      this.setupEventListeners();
      this.initializeMenuState();
    }
    
    private enableFilterControls(): void {
      // Enable all form controls for phantom click prevention
      const checkboxes = document.querySelectorAll('input[type="checkbox"]') as NodeListOf<HTMLInputElement>;
      const clearButtons = document.querySelectorAll('[data-clear-filters], [data-clear-filters-mobile]') as NodeListOf<HTMLButtonElement>;
      const mobileToggle = document.getElementById('mobile-filter-toggle') as HTMLButtonElement;
      const filterContainer = document.getElementById('filter-container');
      
      // Enable checkboxes
      checkboxes.forEach(checkbox => {
        checkbox.disabled = false;
      });
      
      // Enable clear buttons
      clearButtons.forEach(button => {
        button.disabled = false;
      });
      
      // Enable mobile toggle
      if (mobileToggle) {
        mobileToggle.disabled = false;
      }
      
      // Remove disabled visual state
      if (filterContainer) {
        filterContainer.classList.remove('filters-disabled');
      }
      
      console.log('[ResponsiveFilters] ‚úÖ Filter controls enabled');
    }
    
    private initializeFilterEngine(): void {
      // Enable streamlined client-side filtering
      try {
        this.filterEngine = new StreamlinedFilterEngine();
        console.log('[ResponsiveFilters] ‚úÖ Streamlined filtering enabled');
        
      } catch (error) {
        console.error('[ResponsiveFilters] ‚ùå Filter engine initialization failed:', error);
        this.filterEngine = null;
      }
    }

    private setupEventListeners(): void {
      this.setupMobileDrawer();
      this.setupDesktopFiltering();
      this.setupShowMoreToggle();
      this.setupClearButtons();
    }

    private setupMobileDrawer(): void {
      const toggle = document.getElementById("mobile-filter-toggle");
      const close = document.getElementById("mobile-filter-close");

      toggle?.addEventListener("click", () => this.openMobileDrawer());
      close?.addEventListener("click", () => this.closeMobileDrawer());
      this.overlay?.addEventListener("click", () => this.closeMobileDrawer());
    }

    private openMobileDrawer(): void {
      this.overlay?.classList.remove("pointer-events-none", "opacity-0");
      this.container?.classList.remove("translate-y-full", "opacity-0", "pointer-events-none");
      document.body.style.overflow = "hidden";
    }

    private closeMobileDrawer(): void {
      this.overlay?.classList.add("opacity-0");
      this.container?.classList.add("translate-y-full", "opacity-0");
      
      // Use transitionend event instead of fixed timeout
      const handleTransitionEnd = () => {
        this.overlay?.classList.add("pointer-events-none");
        this.container?.classList.add("pointer-events-none");
        this.container?.removeEventListener('transitionend', handleTransitionEnd);
      };
      
      this.container?.addEventListener('transitionend', handleTransitionEnd);
      
      // Fallback timeout in case transitionend doesn't fire
      setTimeout(handleTransitionEnd, 350);
      
      document.body.style.overflow = "";
    }

    // ELIMINATES FOUT: No page reloads ever  
    // ELIMINATES PHANTOM CLICKS: Immediate interaction blocking
    private setupDesktopFiltering(): void {
      if (!this.form) return;

      const checkboxes = this.form.querySelectorAll('input[type="checkbox"]');
      
      checkboxes.forEach((checkbox) => {
        // Remove all existing event listeners by cloning the element
        const newCheckbox = checkbox.cloneNode(true) as HTMLInputElement;
        checkbox.parentNode?.replaceChild(newCheckbox, checkbox);
        
        newCheckbox.addEventListener("change", (event) => {
          console.log(`[ResponsiveFilters] Checkbox changed: ${(event.target as HTMLInputElement).name}=${(event.target as HTMLInputElement).value}, checked=${(event.target as HTMLInputElement).checked}`);
          
          if (window.innerWidth >= 1024 && this.filterEngine) {
            console.log('[ResponsiveFilters] üöÄ Using CLIENT-SIDE filtering');
            
            // PREVENT page reload completely
            event.preventDefault();
            event.stopPropagation();
            event.stopImmediatePropagation();
            
            // Get current filter criteria
            const criteria = this.buildFilterCriteria();
            
            // Apply filters immediately - no debouncing for simplicity
            this.filterEngine.applyFilters(criteria);
            
            // Save menu state
            sessionStorage.setItem("filter-menu-expanded", this.isExpanded.toString());
            
            return false; // Extra prevention
            
          } else {
            console.log('[ResponsiveFilters] üì± Using SERVER-SIDE filtering');
            // Mobile: allow normal form behavior - no preventDefault
            // Form will submit naturally when user clicks "Apply Filters"
            sessionStorage.setItem("filter-menu-expanded", this.isExpanded.toString());
            sessionStorage.setItem("filtering-in-progress", "true");
          }
        });
      });
      
      // ALSO prevent form submission at form level
      this.form.addEventListener('submit', (event) => {
        if (window.innerWidth >= 1024 && this.filterEngine) {
          event.preventDefault();
          event.stopPropagation();
          console.log('[ResponsiveFilters] Prevented form submission - using client-side filtering');
          return false;
        } else {
          // Mobile: trigger close animation before form submits
          event.preventDefault();
          
          // Wait for animation to complete using transitionend event
          const handleAnimationComplete = () => {
            this.container?.removeEventListener('transitionend', handleAnimationComplete);
            this.form?.submit();
          };
          
          this.container?.addEventListener('transitionend', handleAnimationComplete);
          
          // Fallback timeout in case transitionend doesn't fire
          const fallbackTimeout = setTimeout(() => {
            this.container?.removeEventListener('transitionend', handleAnimationComplete);
            this.form?.submit();
          }, 400);
          
          this.closeMobileDrawer();
        }
      });
    }
    
    // Build filter criteria for client-side engine  
    private buildFilterCriteria(): any {
      if (!this.form) return { brands: [], availability: false };
      
      // Re-query form to get current checkboxes (in case they were cloned)
      const formData = new FormData(this.form);
      const brands = formData.getAll('brands') as string[];
      const availability = formData.get('availability') === 'true';
      
      return { brands, availability };
    }

    private setupShowMoreToggle(): void {
      if (!this.showMoreToggle) return;

      this.showMoreToggle.addEventListener("click", (e) => {
        e.preventDefault();
        this.isExpanded ? this.collapseFilters() : this.expandFilters();
        sessionStorage.setItem("filter-menu-expanded", this.isExpanded.toString());
      });
    }

    private initializeMenuState(): void {
      const initialExpanded = this.showMoreToggle?.dataset.initialExpanded === "true";
      const wasExpanded = sessionStorage.getItem("filter-menu-expanded") === "true";
      const shouldExpand = sessionStorage.getItem("filter-menu-expanded") !== null ? wasExpanded : initialExpanded;

      this.isExpanded = shouldExpand;

      setTimeout(() => {
        const filterList = document.querySelector('.brand-filter-list') as HTMLElement;
        if (filterList) {
          filterList.style.transition = '';
        }
      }, 100);
    }

    private collapseFilters(): void {
      const extraItems = document.querySelectorAll(".brand-extra-item");
      const collapsedText = this.showMoreToggle?.dataset.collapsedText || "+ Show more";

      extraItems.forEach((item) => {
        const element = item as HTMLElement;
        element.classList.add("lg:hidden");
      });

      if (this.showMoreToggle) this.showMoreToggle.textContent = collapsedText;
      this.isExpanded = false;
    }

    private expandFilters(): void {
      const extraItems = document.querySelectorAll(".brand-extra-item");
      const expandedText = this.showMoreToggle?.dataset.expandedText || "- Show less";

      extraItems.forEach((item) => {
        const element = item as HTMLElement;
        element.classList.remove("lg:hidden");
      });

      if (this.showMoreToggle) this.showMoreToggle.textContent = expandedText;
      this.isExpanded = true;
    }

    private setupClearButtons(): void {
      const clearBtn = document.querySelector("[data-clear-filters]");
      const clearBtnMobile = document.querySelector("[data-clear-filters-mobile]");

      // UNIFIED: Both desktop and mobile clear buttons use same logic as AppliedFilters
      clearBtn?.addEventListener("click", () => {
      const filterInstance = (window as any).currentFilterInstance;
      if (filterInstance?.clearAllFilters) {
        filterInstance.clearAllFilters();
      }
    });
      clearBtnMobile?.addEventListener("click", () => {
        // Close mobile drawer first, then clear
        this.closeMobileDrawer();
        const filterInstance = (window as any).currentFilterInstance;
        if (filterInstance?.clearAllFilters) {
          filterInstance.clearAllFilters();
        }
      });
    }

    public clearAllFilters(): void {
      if (this.filterEngine) {
        // Clear checkboxes
        const checkboxes = this.form?.querySelectorAll('input[type="checkbox"]') as NodeListOf<HTMLInputElement>;
        checkboxes?.forEach(checkbox => checkbox.checked = false);
        
        // Apply filters immediately
        const criteria = this.buildFilterCriteria();
        this.filterEngine.applyFilters(criteria);
      } else {
        // Fallback to server-side
        const params = new URLSearchParams();
        this.navigateWithParams(params);
      }
    }

    private navigateWithParams(params: URLSearchParams): void {
      const queryString = params.toString();
      const basePath = window.location.pathname;
      const newUrl = `${basePath}${queryString ? "?" + queryString : ""}`;

      sessionStorage.setItem("filtering-in-progress", "true");
      window.location.href = newUrl;
    }

    // Cleanup method for navigation
    destroy(): void {
      document.body.style.overflow = "";
      
      if (this.filterEngine) {
        this.filterEngine.destroy();
        this.filterEngine = null;
      }
      
      // Clean up any processing states
      const filterContainer = document.getElementById("filter-container");
      filterContainer?.classList.remove("filters-processing", "filter-processing-indicator");
      
      // Remove any processing indicators
      const indicator = document.getElementById('filter-processing-indicator');
      if (indicator) {
        indicator.remove();
      }
    }
  }

  // Store instance for cleanup on navigation
  let currentInstance: ResponsiveFilters | null = null;

  // Clean initialization that works with Astro navigation
  function initializeFilters() {
    // Clean up previous instance
    if (currentInstance) {
      currentInstance.destroy();
    }
    
    // Create new instance
    currentInstance = new ResponsiveFilters();
    
    // Expose instance globally for AppliedFilters access
    (window as any).currentFilterInstance = currentInstance;
  }

  // Handle both initial load and Astro navigation
  document.addEventListener("astro:page-load", initializeFilters);
  
  // Cleanup on navigation away
  document.addEventListener("astro:before-preparation", () => {
    if (currentInstance) {
      currentInstance.destroy();
      currentInstance = null;
    }
  });

  // Initialize immediately if DOM is already ready
  if (document.readyState !== 'loading') {
    initializeFilters();
  }
</script>
