---
// src/components/ProductFilters.astro - Cleaned with restored pageSize input
import type { FilterOptions } from "@/lib/square/types";

interface Props {
  filterOptions: FilterOptions;
  totalProducts: number;
  filteredCount: number;
  categoryPath?: string;
}

const { filterOptions, totalProducts, filteredCount, categoryPath = "" } = Astro.props;

// Parse current filters from URL for server-side rendering
const currentParams = new URLSearchParams(Astro.url.search);
const currentBrands = currentParams.getAll("brands") || [];
const currentAvailability = currentParams.get("availability") === "true";

// Configuration for show more/less functionality
const DEFAULT_VISIBLE_BRANDS = 6;
const shouldShowToggle = filterOptions.brands.length > DEFAULT_VISIBLE_BRANDS;

// FOUC Fix: Determine initial expanded state server-side
// Check if there are any selected brands beyond the default visible count
const hasSelectedBrandsBelow = currentBrands.some(brand => {
  const brandIndex = filterOptions.brands.findIndex(b => b.name === brand);
  return brandIndex >= DEFAULT_VISIBLE_BRANDS;
});

// Start expanded if user has selected brands that would be hidden
const shouldStartExpanded = hasSelectedBrandsBelow;
---

<style is:inline>
  /* Simple transitions only */
  .brand-filter-list {
    transition: none;
  }
  
  .product-card-wrapper[style*="display: none"] {
    display: none !important;
  }
  
  /* Disabled state styling for phantom click prevention */
  :disabled {
    opacity: 0.6;
    cursor: not-allowed;
    pointer-events: none;
  }
  
  /* Disabled button styling */
  button:disabled {
    opacity: 0.6;
    cursor: not-allowed;
    pointer-events: none;
  }
  
  /* Simple disabled container state */
  .filters-disabled {
    opacity: 0.6;
    pointer-events: none;
  }
  
  /* PHASE 2: Enhanced mobile loading states */
  .mobile-filter-loading {
    position: fixed;
    inset: 0;
    background: rgba(0, 0, 0, 0.3);
    backdrop-filter: blur(4px);
    z-index: 60;
    display: flex;
    align-items: center;
    justify-content: center;
  }
  
  /* Enhanced View Transitions coordination */
  @media (max-width: 1023px) {
    /* Smooth drawer transitions for mobile */
    #filter-container {
      transform-origin: bottom;
      backface-visibility: hidden;
    }
    
    /* Optimize mobile View Transitions */
    html::view-transition-old(root),
    html::view-transition-new(root) {
      animation-duration: 0.2s;
    }
  }
  
  /* Respect reduced motion for View Transitions */
  @media (prefers-reduced-motion: reduce) {
    html::view-transition-old(root),
    html::view-transition-new(root) {
      animation: none !important;
    }
  }
</style>

<!-- Single Responsive Form Container -->
<div class="relative lg:block bg-(--surface-primary)">
  <!-- Mobile Filter Button -->
  <button
    id="mobile-filter-toggle"
    class="lg:hidden fixed bottom-4 right-4 bg-(--surface-tertiary) text-(--content-body) border border-(--border-tertiary) rounded-md flex flex-row gap-2 p-4 shadow-lg z-250"
    aria-label="Open Filters"
    disabled
  >
    Filters
    <svg class="w-5 h-5" fill="none" stroke="currentColor" viewBox="0 0 24 24">
      <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M3 4a1 1 0 011-1h16a1 1 0 011 1v2.586a1 1 0 01-.293.707l-6.414 6.414a1 1 0 00-.293.707V17l-4 4v-6.586a1 1 0 00-.293-.707L3.293 7.707A1 1 0 013 7V4z"></path>
    </svg>
    {currentBrands.length > 0 && (
      <span class="absolute -top-1 -right-1 bg-(--ui-button-surface) text-(--ui-button-text) font-bold text-sm rounded-full min-w-5 h-5 flex items-center justify-center px-1">
        {currentBrands.length}
      </span>
    )}
  </button>

  <!-- Mobile Overlay -->
  <div
    id="mobile-filter-overlay"
    class="lg:hidden fixed inset-0 bg-(--ui-modal-overlay)/80 backdrop-blur-sm z-40 opacity-0 pointer-events-none transition-opacity duration-300"
  ></div>

  <!-- Single Form - Desktop Static, Mobile Drawer -->
  <div
    id="filter-container"
    class="filters-disabled lg:static lg:transform-none lg:max-h-none fixed bottom-0 left-0 right-0 md:left-auto md:w-[28rem] lg:w-auto bg-(--surface-secondary) z-500 max-h-[80vh] overflow-y-auto transform translate-y-full lg:translate-y-0 opacity-0 lg:opacity-100 pointer-events-none lg:pointer-events-auto transition-all duration-300 lg:transition-none"
  >
    <form class="px-4 lg:p-2" id="filter-form">
      <!-- Mobile Header -->
      <div class="flex items-center justify-between mb-4 p-6 -mx-4 bg-(--surface-secondary) border border-b-(--border-tertiary) sticky top-0 z-50 lg:hidden">
        <h2 class="text-lg font-semibold text-(--content-heading)">Filter Products</h2>
        <button type="button" id="mobile-filter-close" class="p-1 text-(--content-meta) hover:text-(--content-emphasis)" aria-label="Close Filters">
          <svg class="w-6 h-6" fill="none" stroke="currentColor" viewBox="0 0 24 24">
            <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M6 18L18 6M6 6l12 12"></path>
          </svg>
        </button>
      </div>

      <!-- Results Count -->
      <div class="min-w-fit mt-2 mb-4">
        <div class="lg:hidden p-3 bg-(--surface-tertiary) rounded-sm">
          <p class="text-sm text-(--content-meta)" data-result-count>
            {filteredCount} of {totalProducts} products
          </p>
        </div>
        <div class="hidden lg:block">
          <p class="text-sm lg:text-base text-(--content-meta) font-medium" data-result-count>
            {filteredCount === totalProducts
              ? `${totalProducts} products`
              : `${filteredCount} of ${totalProducts} products`
            }
          </p>
        </div>
      </div>

      <!-- Brand Filter Section -->
      {filterOptions.brands.length > 0 && (
        <div class="mb-6 lg:mb-4">
          <div class="flex items-center justify-between mb-3">
            <h3 class="text-xl font-medium font-display text-(--content-heading)">Brand</h3>
            <button
              type="button"
              id="clear-brands-button"
              data-clear-filters
              disabled
              class="text-sm text-(--content-meta) hover:text-(--content-emphasis) transition-colors lg:mr-2"
              style={currentBrands.length === 0 ? "display: none;" : ""}
            >
              Clear ({currentBrands.length})
            </button>
          </div>

          <!-- Brand List with FOUC Fix -->
          <div class="space-y-3 lg:space-y-1 max-h-64 lg:max-h-none overflow-y-auto lg:overflow-visible brand-filter-list" data-brand-list>
            {filterOptions.brands.map((brand, index) => {
              const isHidden = index >= DEFAULT_VISIBLE_BRANDS;
              // FOUC Fix: Apply server-side visibility logic
              const serverHiddenClass = isHidden && !shouldStartExpanded ? "lg:hidden" : "";

              return (
                <label
                  class={`flex items-center justify-between group cursor-pointer p-3 lg:p-1 rounded-sm hover:bg-(--surface-tertiary) lg:hover:bg-(--surface-secondary) transition-colors ${isHidden ? `brand-extra-item ${serverHiddenClass}` : ""}`}
                >
                  <div class="flex items-center">
                    <input
                      type="checkbox"
                      name="brands"
                      value={brand.name}
                      checked={currentBrands.includes(brand.name)}
                      disabled
                      class="elco-checkbox mr-3 lg:mr-2 w-5 h-5 lg:w-4 lg:h-4 rounded-sm border-2 border-(--ui-input-border) text-ui-accent focus:ring-2 focus:ring-ui-accent focus:ring-offset-0"
                    />
                    <span class="text-(--content-body) group-hover:text-(--content-emphasis)">
                      {brand.name}
                    </span>
                  </div>
                  <span class="text-sm text-(--content-meta) lg:mr-2">({brand.count})</span>
                </label>
              );
            })}

            {shouldShowToggle && (
              <button
                type="button"
                id="show-more-toggle"
                class="hidden lg:block w-full text-left text-sm text-ui-accent hover:text-ui-accent-hover transition-colors p-1 font-medium"
                data-collapsed-text={`+ Show ${filterOptions.brands.length - DEFAULT_VISIBLE_BRANDS} more`}
                data-expanded-text="- Show less"
                data-initial-expanded={shouldStartExpanded.toString()}
              >
                {shouldStartExpanded 
                  ? "- Show less"
                  : `+ Show ${filterOptions.brands.length - DEFAULT_VISIBLE_BRANDS} more`
                }
              </button>
            )}
          </div>
        </div>
      )}

      <!-- Availability Filter Section -->
      <div class="mb-6 lg:mb-4">
        <h3 class="text-xl font-medium font-display text-(--content-heading) mb-3">Availability</h3>

        <label class="flex items-center group cursor-pointer p-3 lg:p-1 rounded-sm hover:bg-(--surface-tertiary) lg:hover:bg-(--surface-secondary) transition-colors">
          <input
            type="checkbox"
            name="availability"
            value="true"
            checked={currentAvailability}
            disabled
            class="elco-checkbox mr-3 lg:mr-2 w-5 h-5 lg:w-4 lg:h-4 rounded-sm border-2 border-(--ui-input-border) text-ui-accent focus:ring-2 focus:ring-ui-accent focus:ring-offset-0"
          />
          <span class="text-(--content-body) group-hover:text-(--content-emphasis)">
            In stock only
          </span>
        </label>
      </div>

      <!-- Mobile Actions -->
      <div class="flex gap-3 p-6 -mx-4 bg-(--surface-secondary) border-t-(--border-tertiary) sticky bottom-0 lg:hidden">
        {(currentBrands.length > 0 || currentAvailability) && (
          <button
            type="button"
            data-clear-filters-mobile
            disabled
            class="flex-1 py-3 px-4 border border-(--ui-button-border) text-ui-button-border rounded-sm hover:bg-ui-button-hover transition-colors text-center"
          >
            Clear Filters
          </button>
        )}
        <button
          type="submit"
          class="flex-1 py-3 px-4 bg-(--ui-button-surface) text-(--ui-button-text) rounded-sm hover:bg-ui-button-primary-hover transition-colors font-medium"
        >
          Apply Filters
        </button>
      </div>
    </form>
  </div>
</div>

<script>
  // HYBRID: Device-specific Filter Engine - Desktop client-side, Mobile server-side
  class StreamlinedFilterEngine {
  private products: any[] = [];
  private filteredProducts: any[] = [];
  
  constructor() {
    this.initializeProducts();
  }
    
  private initializeProducts(): void {
    const grid = document.getElementById("filterable-product-grid");
    
    // Use the correct data attributes set by ProductGrid
    const allProductsData = grid?.dataset.allProducts;
    const initialProductsData = grid?.dataset.initialProducts;
    
    console.log('[StreamlinedFilterEngine] üîç Data source investigation:', {
      hasAllProducts: !!allProductsData,
      hasInitialProducts: !!initialProductsData,
      allProductsLength: allProductsData ? JSON.parse(allProductsData).length : 0,
      initialProductsLength: initialProductsData ? JSON.parse(initialProductsData).length : 0
    });
    
    if (!allProductsData && !initialProductsData) {
      console.warn("[StreamlinedFilterEngine] No product data found");
      return;
    }
    
    try {
      // PREFER allProducts for client-side filtering, but validate it has content
      let productData = allProductsData;
      let dataSource = "allProducts";
      
      // Enhanced validation with better error handling
      if (!allProductsData) {
        console.log('[StreamlinedFilterEngine] ‚ö†Ô∏è allProducts data not available');
        productData = initialProductsData;
        dataSource = "initialProducts";
      } else {
        // Test parse allProducts to check if it's valid
        try {
          const testParse = JSON.parse(allProductsData);
          if (!Array.isArray(testParse) || testParse.length === 0) {
            console.log('[StreamlinedFilterEngine] ‚ö†Ô∏è allProducts data is empty array, falling back to initialProducts');
            productData = initialProductsData;
            dataSource = "initialProducts";
          }
        } catch (parseError) {
          console.error('[StreamlinedFilterEngine] ‚ùå allProducts JSON parse failed:', parseError);
          productData = initialProductsData;
          dataSource = "initialProducts";
        }
      }
      
      if (!productData) {
        console.error("[StreamlinedFilterEngine] ‚ùå No valid product data available from either source");
        return;
      }
      
      // Final parse with detailed error reporting
      this.products = JSON.parse(productData);
      
      if (!Array.isArray(this.products)) {
        console.error("[StreamlinedFilterEngine] ‚ùå Parsed data is not an array:", typeof this.products);
        return;
      }
      
      this.filteredProducts = [...this.products];
      
      console.log(`[StreamlinedFilterEngine] ‚úÖ Successfully initialized with ${this.products.length} products from ${dataSource}`);
      
      // DEBUG: Show sample product structure for troubleshooting
      if (this.products.length > 0) {
        console.log('[StreamlinedFilterEngine] üìã Sample product structure:', {
          id: this.products[0].id,
          brand: this.products[0].brand,
          name: this.products[0].name,
          hasInventoryStatus: !!this.products[0].inventoryStatus,
          allKeys: Object.keys(this.products[0])
        });
      } else {
        console.warn('[StreamlinedFilterEngine] ‚ö†Ô∏è No products in parsed array');
      }
    } catch (error) {
      console.error("[StreamlinedFilterEngine] ‚ùå Critical error during product data initialization:", error);
      console.log("[StreamlinedFilterEngine] üîç Debug info:", {
        allProductsDataType: typeof allProductsData,
        allProductsDataLength: allProductsData?.length,
        initialProductsDataType: typeof initialProductsData,
        initialProductsDataLength: initialProductsData?.length,
        gridElement: !!document.getElementById("filterable-product-grid")
      });
    }
  }
    
  public applyFilters(criteria: any): void {
    console.log('[StreamlinedFilterEngine] üîç Applying filters:', criteria);
    console.log('[StreamlinedFilterEngine] üìä Total products to filter:', this.products.length);
    
    // Simple, reliable filtering - NO infinite scroll logic
    this.filteredProducts = this.products.filter(product => 
      this.matchesCriteria(product, criteria)
    );
    
    console.log('[StreamlinedFilterEngine] ‚úÖ Filtered products:', this.filteredProducts.length);
    console.log('[StreamlinedFilterEngine] üìã Sample filtered products:', this.filteredProducts.slice(0, 3).map(p => ({ id: p.id, brand: p.brand, title: p.title })));
    
    // Simple DOM updates - ProductGrid handles its own infinite scroll
    this.updateProductGrid();
    this.updateResultCount();
    this.updateAppliedFilters(criteria);
    this.updateClearButtonVisibility(criteria);
    this.updateNoResultsState();
  }
  
  private matchesCriteria(product: any, criteria: any): boolean {
    // Debug first few products with enhanced information
    const productIndex = this.products.indexOf(product);
    if (productIndex < 3) {
      console.log(`[StreamlinedFilterEngine] üîç Filtering product ${productIndex}:`, {
        id: product.id,
        brand: product.brand,
        brandType: typeof product.brand,
        criteriaBrands: criteria.brands,
        criteriaAvailability: criteria.availability,
        isOutOfStock: product.inventoryStatus?.isOutOfStock,
        productKeys: Object.keys(product)
      });
    }
    
    // DEFENSIVE: Brand filtering with case handling and null checks
    if (criteria.brands.length > 0) {
      const productBrand = product.brand;
      
      // Handle missing or null brand
      if (!productBrand) {
        if (productIndex < 3) console.log(`[StreamlinedFilterEngine] ‚ùå Product ${productIndex} has no brand field`);
        return false;
      }
      
      // Check if product brand matches any of the selected brands (case-insensitive for safety)
      const brandMatches = criteria.brands.some((selectedBrand: string) => {
        const normalizedProductBrand = String(productBrand).trim();
        const normalizedSelectedBrand = String(selectedBrand).trim();
        return normalizedProductBrand === normalizedSelectedBrand;
      });
      
      if (!brandMatches) {
        if (productIndex < 3) {
          console.log(`[StreamlinedFilterEngine] ‚ùå Product ${productIndex} brand "${productBrand}" not in selected brands:`, criteria.brands);
        }
        return false;
      }
    }
    
    // DEFENSIVE: Availability filtering with null checks
    if (criteria.availability) {
      const inventoryStatus = product.inventoryStatus;
      const isOutOfStock = inventoryStatus?.isOutOfStock;
      
      if (productIndex < 3) {
        console.log(`[StreamlinedFilterEngine] üîç AVAILABILITY DEBUG Product ${productIndex}:`, {
          hasInventoryStatus: !!inventoryStatus,
          isOutOfStock: isOutOfStock,
          inventoryStatusKeys: inventoryStatus ? Object.keys(inventoryStatus) : 'none',
          productId: product.id
        });
      }
      
      if (isOutOfStock === true) {
        if (productIndex < 3) console.log(`[StreamlinedFilterEngine] ‚ùå Product ${productIndex} filtered out - out of stock`);
        return false;
      }
      
      // If inventory status is missing, assume in stock for now
      if (productIndex < 3 && !inventoryStatus) {
        console.log(`[StreamlinedFilterEngine] ‚ö†Ô∏è Product ${productIndex} missing inventory status - assuming in stock`);
      }
    }
    
    if (productIndex < 3) console.log(`[StreamlinedFilterEngine] ‚úÖ Product ${productIndex} matches all criteria`);
    return true;
  }
    
  private updateProductGrid(): void {
    const grid = document.getElementById("filterable-product-grid");
    if (!grid) {
      console.error('[StreamlinedFilterEngine] ‚ùå Product grid not found');
      return;
    }
    
    const allWrappers = Array.from(grid.querySelectorAll('.product-card-wrapper'));
    
    // DEFENSIVE: Create more robust ID matching 
    const visibleProductIds = new Set();
    this.filteredProducts.forEach(p => {
      // Add both string and number versions of ID to handle any format mismatches
      visibleProductIds.add(String(p.id));
      visibleProductIds.add(p.id);
    });
    
    console.log('[StreamlinedFilterEngine] üéØ DOM Update - Total cards:', allWrappers.length);
    console.log('[StreamlinedFilterEngine] üéØ DOM Update - Filtered products count:', this.filteredProducts.length);
    console.log('[StreamlinedFilterEngine] üéØ Visible product IDs (first 5):', Array.from(visibleProductIds).slice(0, 10));

    // DEBUG: Check first few DOM cards to see their IDs
    console.log('[StreamlinedFilterEngine] üîç First 3 DOM card IDs:', 
      allWrappers.slice(0, 3).map(w => w.getAttribute('data-product-id'))
    );

    // Get animation timing with row-based calculations
    const { duration, staggerDelay, rowStaggerDelay } = this.getAnimationTiming();

    // Helper function to calculate responsive grid
    function getCardsPerRow() {
      const width = window.innerWidth;
      if (width >= 1536) return 6; // 2xl:grid-cols-6
      if (width >= 1280) return 4; // xl:grid-cols-4
      if (width >= 1024) return 3; // lg:grid-cols-3
      if (width >= 768) return 2;  // md:grid-cols-2
      return 2; // fallback
    }

    // Step 1: Exit all cards
    allWrappers.forEach((wrapper) => {
      wrapper.classList.remove('opacity-100');
      wrapper.classList.add('opacity-0');
    });

    // Step 2: Show/hide and animate visible cards with row-based stagger
    setTimeout(() => {
      let visibleIndex = 0;
      let hiddenCount = 0;
      const cardsPerRow = getCardsPerRow();
      
      allWrappers.forEach((wrapper, domIndex) => {
        const productId = wrapper.getAttribute('data-product-id');
        
        // DEFENSIVE: Try multiple ID formats and handle missing IDs
        const isVisible = productId ? (
          visibleProductIds.has(productId) || 
          visibleProductIds.has(String(productId)) ||
          visibleProductIds.has(parseInt(productId))
        ) : false;
        
        // Enhanced debug for first few iterations
        if (domIndex < 5) {
          console.log(`[StreamlinedFilterEngine] üîç Card ${domIndex}: DOM ID="${productId}", visible=${isVisible}, type=${typeof productId}`);
        }

        if (isVisible) {
          // Show card and animate in with combined row + individual card stagger
          (wrapper as HTMLElement).style.display = '';
          (wrapper as HTMLElement).removeAttribute('data-filter-hidden');
          
          // FIXED: Don't interfere with infinite scroll state management
          // Only clear infinite scroll hidden if it was set by filtering, not by scroll logic
          const wasHiddenByScroll = (wrapper as HTMLElement).hasAttribute('data-infinite-scroll-hidden');
          if (!wasHiddenByScroll) {
            // This card was hidden by filtering, not by scroll, so it's safe to show
            (wrapper as HTMLElement).removeAttribute('data-infinite-scroll-hidden');
          }
          
          // Calculate both row index and individual stagger
          const rowIndex = Math.floor(visibleIndex / cardsPerRow);
          const cardInRow = visibleIndex % cardsPerRow;
          
          // Combined delay: row delay + individual card delay within row
          const baseRowDelay = rowIndex * rowStaggerDelay;
          const cardDelay = cardInRow * (staggerDelay / 1.2); // More pronounced individual stagger
          const totalDelay = baseRowDelay + cardDelay;
          
          setTimeout(() => {
            wrapper.classList.remove('opacity-0');
            wrapper.classList.add('opacity-100');
          }, totalDelay);
          
          visibleIndex++;
        } else {
          // Hide card and mark as filtered - preserve infinite scroll state
          (wrapper as HTMLElement).style.display = 'none';
          (wrapper as HTMLElement).setAttribute('data-filter-hidden', 'true');
          
          // FIXED: Don't modify infinite scroll attributes when filtering
          // Let infinite scroll manage its own state independently
          
          hiddenCount++;
        }
      });
      
      console.log(`[StreamlinedFilterEngine] ‚úÖ DOM update complete: ${visibleIndex} visible, ${hiddenCount} hidden`);
      
      // HYBRID: Only emit filtersApplied for desktop (where infinite scroll might need adjustment)
      const isDesktop = window.innerWidth >= 1024;
      if (isDesktop) {
        console.log('[StreamlinedFilterEngine] üñ•Ô∏è Desktop filtering complete - infinite scroll will be unaffected');
        // Note: We're not emitting filtersApplied anymore since infinite scroll is simpler
      } else {
        console.log('[StreamlinedFilterEngine] üì± Mobile filtering complete (this should not happen in hybrid mode)');
      }
      
    }, duration);
  }
  
  private updateResultCount(): void {
    const resultElements = document.querySelectorAll('[data-result-count]');
    resultElements.forEach(element => {
      const totalProducts = this.products.length;
      const filteredCount = this.filteredProducts.length;
      
      if (filteredCount === totalProducts) {
        element.textContent = `${totalProducts} products`;
      } else {
        element.textContent = `${filteredCount} of ${totalProducts} products`;
      }
    });
  }
  
  private updateNoResultsState(): void {
    const noResults = document.getElementById("no-results");
    const grid = document.getElementById("filterable-product-grid");
    
    if (this.filteredProducts.length === 0) {
      noResults?.classList.remove("hidden");
      grid?.classList.add("hidden");
    } else {
      noResults?.classList.add("hidden");
      grid?.classList.remove("hidden");
    }
  }

  // Enhanced CSS parsing for animation timing with row-based calculations
  private getAnimationTiming() {
    const style = getComputedStyle(document.documentElement);
    
    // Properly parse duration (handles "0.3s", "300ms", etc.)
    const durationStr = style.getPropertyValue('--card-transition-duration').trim();
    console.log(`[StreamlinedFilterEngine] CSS duration value: "${durationStr}"`);
    const duration = durationStr.includes('ms') 
      ? parseInt(durationStr.replace('ms', ''))
      : parseFloat(durationStr.replace('s', '')) * 1000;
    
    // Properly parse stagger delay (handles "50ms", "0ms", etc.)
    const staggerStr = style.getPropertyValue('--card-stagger-delay').trim();
    console.log(`[StreamlinedFilterEngine] CSS stagger value: "${staggerStr}"`);
    const staggerDelay = parseInt(staggerStr.replace('ms', '')) || 0;

    // Parse row stagger delay for row-based animations
    const rowStaggerStr = style.getPropertyValue('--row-stagger-delay').trim();
    console.log(`[StreamlinedFilterEngine] CSS row stagger value: "${rowStaggerStr}"`);
    const rowStaggerDelay = parseInt(rowStaggerStr.replace('ms', '')) || 100;
    
    console.log(`[StreamlinedFilterEngine] Parsed timing - Duration: ${duration}ms, Stagger: ${staggerDelay}ms, Row Stagger: ${rowStaggerDelay}ms`);
    
    return {
      duration: duration || 300,
      staggerDelay: staggerDelay,
      rowStaggerDelay: rowStaggerDelay
    };
  }
    
    private updateAppliedFilters(criteria: any): void {
      // Update AppliedFilters component for client-side filtering
      const appliedFiltersContainer = document.getElementById('applied-filters-container') as HTMLElement;
      const appliedFiltersContent = document.getElementById('applied-filters-content') as HTMLElement;
      
      if (!appliedFiltersContainer || !appliedFiltersContent) return;
      
      const hasFilters = criteria.brands.length > 0 || criteria.availability;
      
      if (!hasFilters) {
        // Use CSS Grid animation to hide
        appliedFiltersContainer.classList.remove('filters-open');
        // Clear content after animation completes
        setTimeout(() => {
          if (!appliedFiltersContainer.classList.contains('filters-open')) {
            appliedFiltersContent.innerHTML = '';
          }
        }, 300);
        return;
      }
      
      // Show container using CSS Grid animation and populate content
      appliedFiltersContent.innerHTML = '';
      appliedFiltersContainer.classList.add('filters-open');
      
      // Create filters wrapper
      const filtersWrapper = document.createElement('div');
      filtersWrapper.className = 'flex flex-wrap gap-2';
      
      // Add brand filters
      criteria.brands.forEach((brand: string) => {
        const filterTag = document.createElement('button');
        filterTag.className = 'inline-flex items-center px-2.5 py-1.5 text-sm border rounded-full bg-(--surface-primary) hover:bg-(--surface-tertiary) transition-colors text-(--ui-input-text) border-(--ui-input-border)/50 group';
        filterTag.innerHTML = `
          <span>${brand}</span>
          <svg class="w-3 h-3 ml-1 text-(--content-meta) group-hover:text-(--content-body)" fill="none" stroke="currentColor" viewBox="0 0 24 24">
            <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M6 18L18 6M6 6l12 12"></path>
          </svg>
        `;
        filterTag.addEventListener('click', () => {
          // Remove this brand and reapply filters
          const checkbox = document.querySelector(`input[name="brands"][value="${brand}"]`) as HTMLInputElement;
          if (checkbox) {
            checkbox.checked = false;
            checkbox.dispatchEvent(new Event('change', { bubbles: true }));
          }
        });
        filtersWrapper.appendChild(filterTag);
      });
      
      // Add availability filter
      if (criteria.availability) {
        const filterTag = document.createElement('button');
        filterTag.className = 'inline-flex items-center px-2.5 py-1.5 text-sm border rounded-full bg-(--state-success-surface) hover:bg-(--state-success-surface)/75 transition-colors text-(--state-success-text) border-(--state-success-text)/50 group';
        filterTag.innerHTML = `
          <span>In stock only</span>
          <svg class="w-3 h-3 ml-1 text-(--state-success-text)/70 group-hover:text-(--state-success-text)" fill="none" stroke="currentColor" viewBox="0 0 24 24">
            <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M6 18L18 6M6 6l12 12"></path>
          </svg>
        `;
        filterTag.addEventListener('click', () => {
          // Remove availability filter and reapply
          const checkbox = document.querySelector('input[name="availability"]') as HTMLInputElement;
          if (checkbox) {
            checkbox.checked = false;
            checkbox.dispatchEvent(new Event('change', { bubbles: true }));
          }
        });
        filtersWrapper.appendChild(filterTag);
      }
      
      // Add clear all button - SAME LOGIC AS ProductFilters Clear
      const clearAllButton = document.createElement('button');
      clearAllButton.className = 'text-sm text-(--content-meta) hover:text-(--content-emphasis) transition-colors text-nowrap';
      clearAllButton.textContent = 'Clear All';
      clearAllButton.addEventListener('click', () => {
        // Use exact same method as ProductFilters Clear button
        const responsiveFilters = (window as any).currentFilterInstance;
        if (responsiveFilters && responsiveFilters.clearAllFilters) {
          responsiveFilters.clearAllFilters();
        }
      });
      
      appliedFiltersContent.appendChild(filtersWrapper);
      appliedFiltersContent.appendChild(clearAllButton);
    }
    
    private updateClearButtonVisibility(criteria: any): void {
      const clearButton = document.getElementById('clear-brands-button') as HTMLElement;
      if (clearButton) {
        const hasFilters = criteria.brands.length > 0 || criteria.availability;
        const filterCount = criteria.brands.length + (criteria.availability ? 1 : 0);
        
        // Update both visibility and text content
        clearButton.style.display = hasFilters ? 'block' : 'none';
        clearButton.textContent = `Clear All`; // Simplified text
        
        // Alternative: Show count if preferred
        // clearButton.textContent = filterCount > 0 ? `Clear (${filterCount})` : 'Clear All';
      }
    }
    
    public destroy(): void {
      // No infinite scroll observer to clean up
    }
    
    // Method for validation
    public getProductsCount(): number {
      return this.products ? this.products.length : 0;
    }
  }

  class ResponsiveFilters {
    private form: HTMLFormElement | null = null;
    private container: HTMLElement | null = null;
    private overlay: HTMLElement | null = null;
    private showMoreToggle: HTMLButtonElement | null = null;
    private isExpanded: boolean = false;
    private filterEngine: StreamlinedFilterEngine | null = null;

    constructor() {
      // Direct element assignment
      this.form = document.getElementById("filter-form") as HTMLFormElement;
      this.container = document.getElementById("filter-container");
      this.overlay = document.getElementById("mobile-filter-overlay");
      this.showMoreToggle = document.getElementById("show-more-toggle") as HTMLButtonElement;
      
      if (!this.form) {
        console.warn("[ResponsiveFilters] Form element not found. Filters may not work correctly.");
        return;
      }
      
      // Initialize immediately with progressive enhancement
      this.setupEventListeners();
      this.initializeMenuState();
      this.setupViewTransitionsCoordination();
      
      // Initialize filter engine when ProductGrid is ready (with fallback)
      this.initializeWithGridReady();
    }
    
    private initializeWithGridReady(): void {
      let gridReady = false;
      
      const enableFiltering = () => {
        if (!gridReady) {
          // Enhanced grid detection with data validation
          const grid = document.getElementById("filterable-product-grid");
          const hasAllProducts = grid?.dataset.allProducts;
          const hasInitialProducts = grid?.dataset.initialProducts;
          
          if (grid && (hasAllProducts || hasInitialProducts)) {
            // Validate data is not just empty arrays
            let hasValidData = false;
            
            try {
              if (hasAllProducts) {
                const allProductsParsed = JSON.parse(hasAllProducts);
                if (Array.isArray(allProductsParsed) && allProductsParsed.length > 0) {
                  hasValidData = true;
                }
              }
              
              if (!hasValidData && hasInitialProducts) {
                const initialProductsParsed = JSON.parse(hasInitialProducts);
                if (Array.isArray(initialProductsParsed) && initialProductsParsed.length > 0) {
                  hasValidData = true;
                }
              }
            } catch (error) {
              console.error('[ResponsiveFilters] ‚ùå Error parsing grid data:', error);
            }
            
            if (hasValidData) {
              gridReady = true;
              console.log('[ResponsiveFilters] ‚úÖ Grid with valid data detected - enabling filters');
              this.enableFilterControls();
              this.initializeFilterEngine();
            } else {
              console.warn('[ResponsiveFilters] ‚ö†Ô∏è Grid found but data appears to be empty');
            }
          } else {
            console.log('[ResponsiveFilters] üîç Grid not ready yet - waiting...');
          }
        }
      };
      
      // Multiple detection methods for reliability
      document.addEventListener('productGridReady', enableFiltering);
      document.addEventListener('DOMContentLoaded', enableFiltering);
      
      // Immediate check in case we're already loaded
      if (document.readyState === 'complete' || document.readyState === 'interactive') {
        enableFiltering();
      }
      
      // Polling fallback for maximum reliability
      let attempts = 0;
      const maxAttempts = 50; // 5 seconds max
      const checkInterval = setInterval(() => {
        attempts++;
        if (!gridReady && attempts < maxAttempts) {
          enableFiltering();
        } else {
          clearInterval(checkInterval);
          if (!gridReady && attempts >= maxAttempts) {
            console.warn('[ResponsiveFilters] ‚ö†Ô∏è Grid detection timeout - filters may not work correctly');
          }
        }
      }, 100);
    }
    
    private enableFilterControls(): void {
      // Enable all form controls for phantom click prevention
      const checkboxes = document.querySelectorAll('input[type="checkbox"]') as NodeListOf<HTMLInputElement>;
      const clearButtons = document.querySelectorAll('[data-clear-filters], [data-clear-filters-mobile]') as NodeListOf<HTMLButtonElement>;
      const mobileToggle = document.getElementById('mobile-filter-toggle') as HTMLButtonElement;
      const filterContainer = document.getElementById('filter-container');
      
      // Enable checkboxes
      checkboxes.forEach(checkbox => {
        checkbox.disabled = false;
      });
      
      // Enable clear buttons
      clearButtons.forEach(button => {
        button.disabled = false;
      });
      
      // Enable mobile toggle
      if (mobileToggle) {
        mobileToggle.disabled = false;
      }
      
      // Remove disabled visual state
      if (filterContainer) {
        filterContainer.classList.remove('filters-disabled');
      }
      
      console.log('[ResponsiveFilters] ‚úÖ Filter controls enabled');
    }
    
    private initializeFilterEngine(): void {
      // HYBRID: Only initialize client-side filtering for desktop
      // OVERRIDE: Check for ?test-desktop=true in URL to force desktop behavior
      const urlParams = new URLSearchParams(window.location.search);
      const forceDesktop = urlParams.get('test-desktop') === 'true';
      
      const isDesktop = forceDesktop || window.innerWidth >= 1024;
      
      if (isDesktop) {
        try {
          this.filterEngine = new StreamlinedFilterEngine();
          console.log(`[ResponsiveFilters] üñ•Ô∏è Desktop: Client-side filtering engine enabled${forceDesktop ? ' (forced via URL)' : ''}`);
          
        } catch (error) {
          console.error('[ResponsiveFilters] ‚ùå Desktop filter engine initialization failed:', error);
          this.filterEngine = null;
        }
      } else {
        console.log('[ResponsiveFilters] üì± Mobile: Using server-side filtering - no client-side engine needed');
        this.filterEngine = null;
      }
    }

    private setupEventListeners(): void {
      this.setupMobileDrawer();
      this.setupHybridFiltering();
      this.setupShowMoreToggle();
      this.setupClearButtons();
    }

    private setupMobileDrawer(): void {
      const toggle = document.getElementById("mobile-filter-toggle");
      const close = document.getElementById("mobile-filter-close");

      toggle?.addEventListener("click", () => this.openMobileDrawer());
      close?.addEventListener("click", () => this.closeMobileDrawer());
      this.overlay?.addEventListener("click", () => this.closeMobileDrawer());
    }

    private openMobileDrawer(): void {
      this.overlay?.classList.remove("pointer-events-none", "opacity-0");
      this.container?.classList.remove("translate-y-full", "opacity-0", "pointer-events-none");
      document.body.style.overflow = "hidden";
    }

    private closeMobileDrawer(): void {
      this.overlay?.classList.add("opacity-0");
      this.container?.classList.add("translate-y-full", "opacity-0");
      
      // Use transitionend event instead of fixed timeout
      const handleTransitionEnd = () => {
        this.overlay?.classList.add("pointer-events-none");
        this.container?.classList.add("pointer-events-none");
        this.container?.removeEventListener('transitionend', handleTransitionEnd);
      };
      
      this.container?.addEventListener('transitionend', handleTransitionEnd);
      
      // Fallback timeout in case transitionend doesn't fire
      setTimeout(handleTransitionEnd, 350);
      
      document.body.style.overflow = "";
    }

    // HYBRID: Device-specific filtering approach  
    private setupHybridFiltering(): void {
      if (!this.form) return;

      const checkboxes = this.form.querySelectorAll('input[type="checkbox"]');
      
      checkboxes.forEach((checkbox) => {
        // Remove all existing event listeners by cloning the element
        const newCheckbox = checkbox.cloneNode(true) as HTMLInputElement;
        checkbox.parentNode?.replaceChild(newCheckbox, checkbox);
        
        newCheckbox.addEventListener("change", (event) => {
          // OVERRIDE: Add easy way to test desktop behavior 
          // Check for ?test-desktop=true in URL to force desktop behavior
          const urlParams = new URLSearchParams(window.location.search);
          const forceDesktop = urlParams.get('test-desktop') === 'true';
          
          const isMobile = !forceDesktop && window.innerWidth < 1024;
          
          console.log(`[ResponsiveFilters] Checkbox changed: ${(event.target as HTMLInputElement).name}=${(event.target as HTMLInputElement).value}, checked=${(event.target as HTMLInputElement).checked}, device=${isMobile ? 'mobile' : 'desktop'}${forceDesktop ? ' (forced)' : ''}`);
          
          if (isMobile) {
            // MOBILE: Allow natural form submission with View Transitions
            console.log('[ResponsiveFilters] üì± Mobile: Allowing natural form submission');
            sessionStorage.setItem("filter-menu-expanded", this.isExpanded.toString());
            sessionStorage.setItem("filtering-in-progress", "true");
            // Don't prevent - let form submit naturally
            return;
          } else {
            // DESKTOP: Use client-side filtering
            if (this.filterEngine) {
              console.log('[ResponsiveFilters] üñ•Ô∏è Desktop: Using CLIENT-SIDE filtering');
              
              // PREVENT form submission for desktop
              event.preventDefault();
              event.stopPropagation();
              event.stopImmediatePropagation();
              
              // Get current filter criteria and apply immediately
              const criteria = this.buildFilterCriteria();
              this.filterEngine.applyFilters(criteria);
              
              // Save menu state
              sessionStorage.setItem("filter-menu-expanded", this.isExpanded.toString());
              
              return false;
              
            } else {
              console.error('[ResponsiveFilters] ‚ùå Filter engine not available for desktop');
              // Fallback to server-side
              sessionStorage.setItem("filter-menu-expanded", this.isExpanded.toString());
              sessionStorage.setItem("filtering-in-progress", "true");
            }
          }
        });
      });
      
      // HYBRID: Form submission handling
      this.form.addEventListener('submit', (event) => {
        // OVERRIDE: Add easy way to test desktop behavior 
        const urlParams = new URLSearchParams(window.location.search);
        const forceDesktop = urlParams.get('test-desktop') === 'true';
        
        const isMobile = !forceDesktop && window.innerWidth < 1024;
        
        console.log('[ResponsiveFilters] üìù FORM SUBMISSION', {
          device: isMobile ? 'mobile' : 'desktop',
          screenWidth: window.innerWidth,
          filterEngineAvailable: !!this.filterEngine,
          forceDesktop: forceDesktop
        });
        
        if (isMobile) {
          // MOBILE: Server-side filtering with View Transitions
          console.log('[ResponsiveFilters] üì± Mobile: Using SERVER-SIDE filtering with View Transitions');
          
          // ENHANCED: Close drawer FIRST and wait for animation to complete
          // This ensures smooth View Transitions without visual conflicts
          if (this.container && this.overlay) {
            // Start closing drawer immediately
            this.closeMobileDrawer();
            
            // Add a small delay to let drawer animation start
            setTimeout(() => {
              // Save state for restoration after navigation
              sessionStorage.setItem("filter-menu-expanded", this.isExpanded.toString());
              sessionStorage.setItem("filtering-in-progress", "true");
              
              // Now allow form to submit naturally - Astro View Transitions will handle it
              // Don't prevent default - let Astro's router handle the smooth transition
            }, 50); // Small delay for animation start
          } else {
            // Fallback if elements not found
            sessionStorage.setItem("filter-menu-expanded", this.isExpanded.toString());
            sessionStorage.setItem("filtering-in-progress", "true");
          }
          
          // Let form submit naturally - View Transitions will handle smoothly
          return;
          
        } else {
          // DESKTOP: Client-side filtering
          event.preventDefault();
          event.stopPropagation();
          
          if (this.filterEngine) {
            console.log('[ResponsiveFilters] üñ•Ô∏è Desktop: Using CLIENT-SIDE filtering');
            
            // Get current filter criteria and apply immediately
            const criteria = this.buildFilterCriteria();
            console.log('[ResponsiveFilters] üîç Filter criteria:', criteria);
            this.filterEngine.applyFilters(criteria);
            
            // Save menu state
            sessionStorage.setItem("filter-menu-expanded", this.isExpanded.toString());
            
            console.log('[ResponsiveFilters] ‚úÖ Desktop client-side filtering complete');
          } else {
            console.error('[ResponsiveFilters] ‚ùå Filter engine not available for desktop');
            // Fallback: allow form submission
            sessionStorage.setItem("filtering-in-progress", "true");
            return;
          }
          
          return false;
        }
      });
    }
    
    // Build filter criteria for client-side engine  
    private buildFilterCriteria(): any {
      if (!this.form) return { brands: [], availability: false };
      
      // Re-query form to get current checkboxes (in case they were cloned)
      const formData = new FormData(this.form);
      const brands = formData.getAll('brands') as string[];
      const availability = formData.get('availability') === 'true';
      
      return { brands, availability };
    }

    private setupShowMoreToggle(): void {
      if (!this.showMoreToggle) return;

      this.showMoreToggle.addEventListener("click", (e) => {
        e.preventDefault();
        this.isExpanded ? this.collapseFilters() : this.expandFilters();
        sessionStorage.setItem("filter-menu-expanded", this.isExpanded.toString());
      });
    }

    private initializeMenuState(): void {
      const initialExpanded = this.showMoreToggle?.dataset.initialExpanded === "true";
      const wasExpanded = sessionStorage.getItem("filter-menu-expanded") === "true";
      const shouldExpand = sessionStorage.getItem("filter-menu-expanded") !== null ? wasExpanded : initialExpanded;

      this.isExpanded = shouldExpand;

      setTimeout(() => {
        const filterList = document.querySelector('.brand-filter-list') as HTMLElement;
        if (filterList) {
          filterList.style.transition = '';
        }
      }, 100);
    }

    private collapseFilters(): void {
      const extraItems = document.querySelectorAll(".brand-extra-item");
      const collapsedText = this.showMoreToggle?.dataset.collapsedText || "+ Show more";

      extraItems.forEach((item) => {
        const element = item as HTMLElement;
        element.classList.add("lg:hidden");
      });

      if (this.showMoreToggle) this.showMoreToggle.textContent = collapsedText;
      this.isExpanded = false;
    }

    private expandFilters(): void {
      const extraItems = document.querySelectorAll(".brand-extra-item");
      const expandedText = this.showMoreToggle?.dataset.expandedText || "- Show less";

      extraItems.forEach((item) => {
        const element = item as HTMLElement;
        element.classList.remove("lg:hidden");
      });

      if (this.showMoreToggle) this.showMoreToggle.textContent = expandedText;
      this.isExpanded = true;
    }

    private setupClearButtons(): void {
      const clearBtn = document.querySelector("[data-clear-filters]");
      const clearBtnMobile = document.querySelector("[data-clear-filters-mobile]");

      // UNIFIED: Both desktop and mobile clear buttons use same logic as AppliedFilters
      clearBtn?.addEventListener("click", () => {
      const filterInstance = (window as any).currentFilterInstance;
      if (filterInstance?.clearAllFilters) {
        filterInstance.clearAllFilters();
      }
    });
      clearBtnMobile?.addEventListener("click", () => {
        // Close mobile drawer first, then clear
        this.closeMobileDrawer();
        const filterInstance = (window as any).currentFilterInstance;
        if (filterInstance?.clearAllFilters) {
          filterInstance.clearAllFilters();
        }
      });
    }

    private setupViewTransitionsCoordination(): void {
      // HYBRID: Ensure mobile drawer closes before View Transitions navigation
      document.addEventListener('astro:before-preparation', () => {
        console.log('[ResponsiveFilters] üöÄ View Transitions preparation - ensuring mobile drawer is closed');
        
        // Force close mobile drawer before any navigation
        if (this.container && this.overlay) {
          this.container.classList.add("translate-y-full", "opacity-0", "pointer-events-none");
          this.overlay.classList.add("pointer-events-none", "opacity-0");
          document.body.style.overflow = "";
        }
        
        // Clean up session storage
        sessionStorage.removeItem("filtering-in-progress");
      });
    }

    public clearAllFilters(): void {
      console.log('[ResponsiveFilters] üßπ Clearing all filters');
      
      // OVERRIDE: Check for ?test-desktop=true in URL to force desktop behavior
      const urlParams = new URLSearchParams(window.location.search);
      const forceDesktop = urlParams.get('test-desktop') === 'true';
      
      const isMobile = !forceDesktop && window.innerWidth < 1024;
      
      if (isMobile) {
        // MOBILE: Use server-side approach - navigate to base URL
        console.log('[ResponsiveFilters] üì± Mobile: Clearing filters via server-side navigation');
        const basePath = window.location.pathname;
        
        // Close drawer first for smooth transition
        this.closeMobileDrawer();
        
        // Navigate to base URL (Astro View Transitions will handle smoothly)
        window.location.href = basePath;
        
      } else {
        // DESKTOP: Use client-side approach
        if (this.filterEngine) {
          console.log(`[ResponsiveFilters] üñ•Ô∏è Desktop: Clearing filters using client-side approach${forceDesktop ? ' (forced)' : ''}`);
          
          // Clear checkboxes
          const checkboxes = this.form?.querySelectorAll('input[type="checkbox"]') as NodeListOf<HTMLInputElement>;
          checkboxes?.forEach(checkbox => checkbox.checked = false);
          
          // Apply empty filter criteria immediately
          const criteria = this.buildFilterCriteria();
          this.filterEngine.applyFilters(criteria);
          
          console.log('[ResponsiveFilters] ‚úÖ Desktop filters cleared using client-side filtering');
        } else {
          console.error('[ResponsiveFilters] ‚ùå Filter engine not available for desktop - falling back to server-side');
          // Fallback: navigate to base URL
          const basePath = window.location.pathname;
          window.location.href = basePath;
        }
      }
    }

    // FIXED: Proper cleanup that restores initial drawer state
    destroy(): void {
      console.log('[ResponsiveFilters] üßπ Cleaning up');
      
      // Clean up DOM state
      document.body.style.overflow = "";
      
      // Clean up filter engine
      if (this.filterEngine) {
        this.filterEngine.destroy();
        this.filterEngine = null;
      }
      
      // FIXED: Reset mobile drawer to CLOSED state (not open)
      if (this.container) {
        // Ensure drawer is closed on mobile, visible on desktop
        this.container.classList.add("translate-y-full", "opacity-0", "pointer-events-none");
        this.container.classList.add("lg:translate-y-0", "lg:opacity-100", "lg:pointer-events-auto");
      }
      
      if (this.overlay) {
        // Ensure overlay is hidden
        this.overlay.classList.add("pointer-events-none", "opacity-0");
      }
      
      // Clean up session storage
      sessionStorage.removeItem("filtering-in-progress");
      
      console.log('[ResponsiveFilters] ‚úÖ Cleanup complete');
    }
  }

  // Store instance for cleanup on navigation
  let currentInstance: ResponsiveFilters | null = null;

  // Clean initialization that works with Astro navigation
  function initializeFilters() {
    // Clean up previous instance
    if (currentInstance) {
      currentInstance.destroy();
    }
    
    // Create new instance
    currentInstance = new ResponsiveFilters();
    
    // Expose instance globally for AppliedFilters access
    (window as any).currentFilterInstance = currentInstance;
    
    // DEBUGGING: Monitor all form submissions globally
    document.addEventListener('submit', (e) => {
      const target = e.target as HTMLElement;
      if (target?.id === 'filter-form') {
        console.log('[GLOBAL] üö® Form submission detected outside our handler!', {
          timestamp: Date.now(),
          target: e.target,
          defaultPrevented: e.defaultPrevented
        });
      }
    }, true); // Use capture to catch early
  }

  // Handle both initial load and Astro navigation
  document.addEventListener("astro:page-load", initializeFilters);
  
  // Enhanced Astro navigation cleanup with View Transitions support
  document.addEventListener("astro:before-preparation", () => {
    console.log('[ResponsiveFilters] üöÄ Enhanced Astro navigation cleanup');
    if (currentInstance) {
      currentInstance.destroy();
      currentInstance = null;
    }
    
    // Clean up any ongoing View Transitions
    sessionStorage.removeItem("filtering-in-progress");
  });

  // Initialize immediately if DOM is already ready
  if (document.readyState !== 'loading') {
    initializeFilters();
  }
</script>