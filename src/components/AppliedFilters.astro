---
// src/components/AppliedFilters.astro

export interface Props {
  classes?: string;
}

const { classes } = Astro.props;

// Parse current filters from URL
const currentParams = new URLSearchParams(Astro.url.search);
const currentBrands = currentParams.getAll("brands") || [];
const currentAvailability = currentParams.get("availability") === "true";

// Only show content if there are active filters
const hasActiveFilters = currentBrands.length > 0 || currentAvailability;
---

<style>
  .applied-filters-container {
    margin-bottom: 0.5rem;
    opacity: 1;
    transition: opacity 300ms ease;
  }

  .applied-filters-container.no-filters {
    opacity: 0;
    pointer-events: none;
  }
</style>

<div
  id="applied-filters-container"
  class:list={[
    "applied-filters-container px-2",
    classes,
    !hasActiveFilters ? "no-filters" : "",
  ]}
>
  <div class="flex flex-wrap items-center gap-3 my-2">
    {
      hasActiveFilters && (
        <>
          <div class="flex flex-wrap gap-2">
            {currentBrands.map((brand) => (
              <button
                type="button"
                data-remove-brand={brand}
                class="inline-flex items-center px-2.5 py-1.5 text-sm border rounded-full bg-(--surface-primary) hover:bg-(--surface-tertiary) transition-colors text-(--ui-input-text) border-(--ui-input-border)/50 group"
                title={`Remove ${brand} filter`}
              >
                <span>{brand}</span>
                <svg
                  class="w-3 h-3 ml-1 text-(--content-meta) group-hover:text-(--content-body)"
                  fill="none"
                  stroke="currentColor"
                  viewBox="0 0 24 24"
                >
                  <path
                    stroke-linecap="round"
                    stroke-linejoin="round"
                    stroke-width="2"
                    d="M6 18L18 6M6 6l12 12"
                  />
                </svg>
              </button>
            ))}
            {currentAvailability && (
              <button
                type="button"
                data-remove-availability
                class="inline-flex items-center px-2.5 py-1.5 text-sm border rounded-full bg-(--surface-primary) hover:bg-(--surface-tertiary) transition-colors text-(--ui-input-text) border-(--ui-input-border)/50 group"
                title="Remove availability filter"
              >
                <span>In stock only</span>
                <svg
                  class="w-3 h-3 ml-1 text-(--state-success-text)/70 group-hover:text-(--state-success-text)"
                  fill="none"
                  stroke="currentColor"
                  viewBox="0 0 24 24"
                >
                  <path
                    stroke-linecap="round"
                    stroke-linejoin="round"
                    stroke-width="2"
                    d="M6 18L18 6M6 6l12 12"
                  />
                </svg>
              </button>
            )}
          </div>
          <button
            type="button"
            data-clear-all-filters
            class="text-sm text-(--content-meta) hover:text-(--content-emphasis) transition-colors text-nowrap"
          >
            Clear All
          </button>
        </>
      )
    }
  </div>
</div>

<script>
  document.addEventListener("astro:page-load", () => {
    setupTimedAppearance();
    setupFilterHandlers();
  });

  function setupTimedAppearance() {
    const container = document.getElementById("applied-filters-container");
    if (!container) return;

    // Check if we have filters
    const urlParams = new URLSearchParams(window.location.search);
    const currentBrands = urlParams.getAll("brands") || [];
    const currentAvailability = urlParams.get("availability") === "true";
    const hasFilters = currentBrands.length > 0 || currentAvailability;

    // Only apply timing logic ONCE per session and only for first filter application
    const hasShownBefore =
      sessionStorage.getItem("appliedFiltersShown") === "true";

    if (
      hasFilters &&
      !hasShownBefore &&
      !container.classList.contains("no-filters")
    ) {
      // First time showing AppliedFilters in this session - apply timing
      container.style.visibility = "hidden";
      container.style.opacity = "0";

      // Shorter delay - just enough for ProductGrid to start settling
      setTimeout(() => {
        container.style.visibility = "visible";
        container.style.opacity = "1";
        container.style.transition = "opacity 200ms ease";
        sessionStorage.setItem("appliedFiltersShown", "true");
        // console.log(
        //   "[AppliedFilters] ⏰ First appearance with timing protection"
        // );
      }, 400); // Much shorter delay
    } else if (hasFilters) {
      // Already shown before or subsequent filters - appear immediately
      container.style.visibility = "visible";
      container.style.opacity = "1";
    }
  }

  function setupFilterHandlers() {
    // Individual brand removal
    document.querySelectorAll("[data-remove-brand]").forEach((btn) => {
      btn.addEventListener("click", (e) => {
        const target = e.currentTarget as HTMLElement;
        const brand = target?.dataset.removeBrand;
        if (brand) removeFilter("brand", brand);
      });
    });

    // Availability removal
    document
      .querySelector("[data-remove-availability]")
      ?.addEventListener("click", () => {
        removeFilter("availability");
      });

    // Clear All - use existing global system
    document
      .querySelector("[data-clear-all-filters]")
      ?.addEventListener("click", () => {
        const globalClearAll = (window as any).globalClearAllFilters;
        if (globalClearAll) {
          globalClearAll();
        } else {
          window.location.href = window.location.pathname;
        }
      });
  }

  function removeFilter(type: string, value: string | null = null) {
    const currentParams = new URLSearchParams(window.location.search);
    const currentBrands = currentParams.getAll("brands") || [];
    const currentAvailability = currentParams.get("availability") === "true";

    const params = new URLSearchParams();

    if (type === "brand" && value) {
      const otherBrands = currentBrands.filter((b) => b !== value);
      otherBrands.forEach((brand) => params.append("brands", brand));
      if (currentAvailability) params.set("availability", "true");
    } else if (type === "availability") {
      currentBrands.forEach((brand) => params.append("brands", brand));
    }

    const queryString = params.toString();
    const url = `${window.location.pathname}${queryString ? "?" + queryString : ""}`;
    window.location.href = url;
  }
</script>
