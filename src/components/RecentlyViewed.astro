---
// /src/components/RecentlyViewed.astro
interface Props {
  title?: string;
  currentProductId?: string;
}

const { title = "Recently Viewed", currentProductId } = Astro.props;
---

<section
  class="recently-viewed p-2"
  id="recently-viewed-section"
  style="display: none;"
  data-current-product-id={currentProductId}
>
  <h2
    class="text-2xl lg:text-3xl font-display font-bold p-2 text-(--content-heading)"
  >
    {title}
  </h2>

  <div
    id="recently-viewed-container"
    class="grid grid-cols-2 sm:grid-cols-3 lg:grid-cols-4 xl:grid-cols-6 gap-1"
  >
    <!-- Products will be inserted here by JavaScript -->
  </div>
</section>

<script>
  import { recentlyViewed } from "@/lib/product/recentlyViewed";
  import { MoneyUtils } from "@/lib/square/money";

  // Client-side image optimization matching EnhancedImageOptimizer
  function optimizeProductImage(src: string): string {
    if (!src) return src;

    try {
      if (src.includes("squarecdn.com")) {
        const url = new URL(src);
        url.searchParams.set("w", "400");
        url.searchParams.set("h", "400");
        url.searchParams.set("fit", "crop");

        // Format detection matching EnhancedImageOptimizer
        const canvas = document.createElement("canvas");
        if (canvas.toDataURL("image/avif").indexOf("data:image/avif") === 0) {
          url.searchParams.set("fm", "avif");
          url.searchParams.set("q", "65");
        } else if (canvas.toDataURL("image/webp").indexOf("data:image/webp") === 0) {
          url.searchParams.set("fm", "webp");
          url.searchParams.set("q", "85");
        } else {
          url.searchParams.set("fm", "jpg");
          url.searchParams.set("q", "90");
        }
        return url.toString();
      }

      // Non-Square images: use Netlify Image CDN
      if (src.startsWith("http")) {
        return `/.netlify/images?url=${encodeURIComponent(src)}&w=400&h=400&fit=cover&fm=avif&q=65`;
      }

      return src;
    } catch {
      return src;
    }
  }

  async function renderRecentlyViewed() {
    const section = document.getElementById("recently-viewed-section");
    const container = document.getElementById("recently-viewed-container");

    if (!section || !container) return;

    const currentProductId = section.getAttribute("data-current-product-id");
    const items = recentlyViewed
      .get(6)
      .filter((item) => item.id !== currentProductId);

    if (items.length === 0) {
      section.style.display = "none";
      return;
    }

    section.style.display = "block";

    // Fetch inventory for all items
    const inventoryMap = await fetchInventoryForItems(items);

    container.innerHTML = items
      .map((item) => {
        const formattedPrice = MoneyUtils.format(
          MoneyUtils.fromFloat(item.price)
        );
        const isOutOfStock = !inventoryMap[item.variationId];
        const optimizedImage = optimizeProductImage(item.image);

        return `
        <div class="group relative w-full h-full">
          <a
            href="${item.url}"
            data-astro-prefetch="viewport"
            class="grid grid-rows-[auto_1fr] gap-2 w-full h-full p-1 bg-(--ui-card-surface) text-(--ui-card-text) hover:bg-(--ui-card-surface-hover) transition-all duration-200 ${isOutOfStock ? "opacity-75" : ""}"
          >
            <div class="relative aspect-square overflow-hidden">
              <img
                src="${optimizedImage}"
                alt="${item.title}"
                class="object-cover w-full h-full lg:group-hover:scale-105 transition-all duration-300 ${isOutOfStock ? "opacity-50" : ""}"
                loading="lazy"
                width="400"
                height="400"
              />
              ${
                isOutOfStock
                  ? `<div class="absolute top-0 left-0 bg-state-error-surface text-state-error-text px-3 py-2 text-sm font-bold rounded-br-sm z-20">Sold Out</div>`
                  : ""
              }
            </div>

            <div class="grid px-1">
              <div class="self-start ${isOutOfStock ? "opacity-50" : ""}">
                ${
                  item.brand
                    ? `
                  <p class="text-xs uppercase text-(--content-meta) !mb-0">
                    ${item.brand}
                  </p>
                `
                    : ""
                }
                <p class="text-base text-(--product-heading) font-light leading-tight line-clamp-2 mb-1">
                  ${item.title}
                </p>
              </div>

              <div class="text-(--product-price) self-end mb-2 lg:mb-0 ${isOutOfStock ? "opacity-50" : ""}">
                <span class="font-display font-semibold text-3xl whitespace-nowrap">
                  ${formattedPrice}
                </span>
              </div>
            </div>
          </a>
        </div>
      `;
      })
      .join("");
  }

  /**
   * Fetch inventory for recently viewed items
   */
  async function fetchInventoryForItems(
    items: any[]
  ): Promise<Record<string, boolean>> {
    try {
      const variationIds = items.map((item) => item.variationId);

      const response = await fetch("/api/cart-inventory", {
        method: "POST",
        headers: {
          "Content-Type": "application/json",
        },
        body: JSON.stringify({ variationIds }),
      });

      if (!response.ok) {
        console.error("Failed to fetch inventory for recently viewed");
        // Default to in stock on error
        return Object.fromEntries(variationIds.map((id) => [id, true]));
      }

      const data = await response.json();

      if (!data.success || !data.inventory) {
        console.error("Invalid inventory response");
        return Object.fromEntries(variationIds.map((id) => [id, true]));
      }

      // Convert to boolean map: true if quantity > 0
      const inventoryMap: Record<string, boolean> = {};
      for (const id of variationIds) {
        inventoryMap[id] = (data.inventory[id] || 0) > 0;
      }

      return inventoryMap;
    } catch (error) {
      console.error("Error fetching inventory for recently viewed:", error);
      // Default to in stock on error
      return Object.fromEntries(items.map((item) => [item.variationId, true]));
    }
  }

  function initRecentlyViewed() {
    const section = document.getElementById("recently-viewed-section");
    if (section) {
      const variationData = document.getElementById(
        "variation-data"
      ) as HTMLInputElement;
      if (variationData?.value) {
        try {
          const data = JSON.parse(variationData.value);
          section.setAttribute("data-current-product-id", data.productId);
        } catch (e) {
          console.error("Failed to parse product data:", e);
        }
      }

      renderRecentlyViewed();
    }
  }

  if (document.readyState === "loading") {
    document.addEventListener("DOMContentLoaded", initRecentlyViewed);
  } else {
    initRecentlyViewed();
  }

  document.addEventListener("astro:page-load", initRecentlyViewed);
</script>
