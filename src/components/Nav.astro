---
// src/components/Nav.astro - Enhanced with strategic prefetching and product filtering
import { siteConfig } from "@/lib/site-config";
import type { CategoryHierarchy } from "@/lib/square/types";
import { fetchCategoryHierarchyWithProducts } from "@/lib/square/categoryUtils";
import { Icon } from "astro-icon/components";

const { contact, social } = siteConfig;

let categoryHierarchy: CategoryHierarchy[];
try {
  // Use product-filtered category fetching to only show categories with products
  categoryHierarchy = await fetchCategoryHierarchyWithProducts();
} catch (error) {
  console.warn("Category fetch failed:", error);
  categoryHierarchy = [];
}

// Determine prefetch strategy for categories
function getPrefetchStrategyForCategory(categoryName: string): string {
  const highPriorityCategories = ["Decks", "Apparel", "Skateboards", "Trucks"];
  const mediumPriorityCategories = ["Wheels", "Bearings", "Hardware"];

  if (highPriorityCategories.includes(categoryName)) {
    return "hover"; // Prefetch on hover for popular categories
  } else if (mediumPriorityCategories.includes(categoryName)) {
    return "tap"; // Prefetch on interaction for medium priority
  }

  return "hover"; // Default hover strategy
}

// Static navigation items with prefetch configuration
const staticNavItems = [
  {
    category: {
      id: "the-shop",
      name: "The Shop",
      slug: "the-shop",
      isTopLevel: true,
      parentCategoryId: undefined,
      rootCategoryId: undefined,
    },
    subcategories: [],
    prefetchStrategy: "viewport", // High priority - prefetch when visible
  },
  {
    category: {
      id: "news",
      name: "News",
      slug: "news",
      isTopLevel: true,
      parentCategoryId: undefined,
      rootCategoryId: undefined,
    },
    subcategories: [],
    prefetchStrategy: "viewport", // High priority - prefetch when visible
  },
];

// Enhanced navigation items with prefetch strategies
const navItems = [
  staticNavItems[0], // "The Shop" first
  ...categoryHierarchy.map((item) => ({
    ...item,
    // Assign prefetch strategy based on category importance
    prefetchStrategy: getPrefetchStrategyForCategory(item.category.name),
  })),
  staticNavItems[1], // "News" last
];

// Get current path for context-aware prefetching
const currentPath = Astro.url.pathname;
const isProductPage = currentPath.includes("/product/");
const isCategoryPage = currentPath.includes("/category/");
---

<!-- Skip to content link -->
<a
  href="#main-content"
  class="skip-link font-bold bg-(--surface-secondary) border border-(--border-primary) rounded absolute left-2 -top-16 focus-visible:top-2 p-2 z-50 transition-all"
  >Skip to main content</a
>

<nav
  class="flex flex-col lg:flex-row w-full lg:gap-2 justify-center border-4 border-(--border-secondary) lg:border-0 bg-(--surface-secondary) lg:relative inset-0 top-12 lg:top-auto fixed -translate-x-full lg:translate-x-0 transition-transform duration-400 ease-in-out z-40 [&.nav-open]:translate-x-0 overflow-y-auto lg:overflow-visible"
  role="navigation"
  aria-label="Main navigation"
  data-nav-context={JSON.stringify({
    currentPath,
    isProductPage,
    isCategoryPage,
  })}
>
  {
    navItems.map((item, index) => (
      <div class="category-group relative flex flex-col lg:flex-row group transition-all">
        <a
          href={
            item.category.id === "the-shop"
              ? "/the-shop"
              : item.category.id === "news"
                ? "/news"
                : `/category/${item.category.slug}`
          }
          class="nav-item text-5xl lg:text-xl xl:text-2xl font-semibold font-display self-start lg:self-center items-center flex flex-row leading-none p-2 lg:p-4 text-(--ui-nav-text) transition-all duration-300 ease-in-out relative hover:text-ui-nav-hover before:absolute before:top-0 before:left-0 before:w-full before:h-0.5 before:bg-(--ui-nav-hover) before:transform before:scale-x-0 before:origin-right before:transition-transform before:duration-300 before:ease-in-out hover:before:scale-x-100 hover:before:origin-left nav-link"
          style={`--item-index: ${index};`}
          data-has-children={item.subcategories.length > 0}
          data-category-name={item.category.name}
          data-prefetch-strategy={item.prefetchStrategy || "hover"}
          data-astro-prefetch={item.prefetchStrategy || "hover"}
          aria-expanded={item.subcategories.length > 0 ? "false" : undefined}
          aria-haspopup={item.subcategories.length > 0 ? "menu" : undefined}
        >
          {item.category.name}
          {item.subcategories.length > 0 && (
            <span class="dropdown-indicator block ml-1 transition-transform duration-200">
              <svg
                xmlns="http://www.w3.org/2000/svg"
                width="12"
                height="12"
                viewBox="0 0 24 24"
                fill="none"
                stroke="currentColor"
                stroke-width="2"
                stroke-linecap="round"
                stroke-linejoin="round"
                class="hidden lg:block h-8 w-8 lg:h-4 lg:w-4 transform lg:group-hover:rotate-180"
                aria-hidden="true"
              >
                <polyline points="6 9 12 15 18 9" />
              </svg>

              <svg
                xmlns="http://www.w3.org/2000/svg"
                width="24"
                height="24"
                viewBox="0 0 48 48"
                fill="none"
                stroke="currentColor"
                stroke-width="4"
                stroke-linecap="round"
                stroke-linejoin="round"
                class="lg:hidden mobile-caret"
                aria-hidden="true"
              >
                <polyline points="12 18 24 30 36 18" />
              </svg>
            </span>
          )}
        </a>

        {/* Enhanced dropdown menu with prefetching */}
        {item.subcategories.length > 0 && (
          <div class="dropdown-menu lg:hidden lg:group-hover:block absolute left-0 top-full z-50 min-w-[200px] origin-top lg:opacity-100 lg:transition-none">
            <div class="bg-(--ui-nav-surface) border border-(--ui-nav-border)/20 shadow-lg rounded-sm p-1 overflow-hidden">
              {item.subcategories.map((subcategory) => (
                <a
                  href={
                    item.category.id === "the-shop"
                      ? `/the-shop/${subcategory.slug}`
                      : `/category/${item.category.slug}/${subcategory.slug}`
                  }
                  class="block p-2 text-2xl lg:text-base text-(--ui-nav-text) hover:text-(--ui-nav-text) before:absolute before:top-0 before:left-0 before:w-full before:h-full before:bg-(--ui-nav-hover)/20 before:transform before:scale-x-0 before:origin-right before:transition-transform before:duration-300 before:ease-in-out hover:before:scale-x-100 hover:before:origin-left relative"
                  data-astro-prefetch="hover"
                  data-subcategory={subcategory.name}
                >
                  {subcategory.name}
                </a>
              ))}
            </div>
          </div>
        )}
      </div>
    ))
  }

  {/* Mobile footer with preconnect optimization */}
  <div
    class="flex flex-col gap-2 p-4 pt-12 border-t-4 border-(--border-secondary) mt-6 lg:hidden nav-link"
    style="--item-index: 6;"
  >
    <address
      class="flex flex-col text-lg gap-2 uppercase not-italic text-(--ui-nav-text)"
    >
      <span class="font-semibold">{siteConfig.name}</span>
      <span>{contact.address.street}</span>
      <span class="mb-1"
        >{contact.address.city}, {contact.address.state}
        {contact.address.zip}</span
      >
      <a href={`tel:${contact.phone.number}`} class="py-2 self-start">
        {contact.phone.display}
      </a>
      <a href={`mailto:${contact.email}`} class="py-2 self-start">
        {contact.email}
      </a>
    </address>

    <ul class="inline-flex flex-row gap-4 mt-4">
      {
        social.map((item) => (
          <li>
            <a
              href={item.url}
              aria-label={item.platform}
              class="text-(--ui-nav-text) hover:text-ui-nav-hover"
              target="_blank"
              rel="noopener"
            >
              <Icon name={item.icon} class="w-8 h-auto" />
            </a>
          </li>
        ))
      }
    </ul>
  </div>
</nav>

<style>
  nav {
    view-transition-name: nav;
  }

  /* Screen reader only class for accessibility */
  .sr-only {
    position: absolute;
    width: 1px;
    height: 1px;
    padding: 0;
    margin: -1px;
    overflow: hidden;
    clip: rect(0, 0, 0, 0);
    white-space: nowrap;
    border: 0;
  }

  /* Mobile animations - optimized for performance */
  @media (max-width: 1024px) {
    .nav-link {
      opacity: 0;
      transform: translate3d(2rem, 0, 0);
      will-change: opacity, transform;
    }

    nav.nav-open .nav-link {
      animation: slideIn 0.4s cubic-bezier(0.4, 0, 0.2, 1) forwards;
      animation-delay: calc(var(--item-index) * 0.08s);
    }

    .dropdown-menu {
      position: static;
      max-height: 0;
      opacity: 0;
      transform: translate3d(0, -10px, 0);
      transition: all 0.25s cubic-bezier(0.4, 0, 0.2, 1);
      overflow: hidden;
      background-color: rgba(var(--ui-nav-hover-rgb, 255, 255, 255), 0.05);
      border-left: 2px solid rgba(var(--ui-nav-border-rgb, 255, 255, 255), 0.1);
      padding-left: 0.5rem;
      border-radius: 0 0 4px 4px;
      contain: layout style;
    }

    .dropdown-menu > div {
      background: transparent;
      border: none;
      box-shadow: none;
      padding: 0.5rem 0;
    }

    .category-group.open .dropdown-menu {
      display: block;
      max-height: 500px;
      opacity: 1;
      transform: translate3d(0, 0, 0);
    }

    .category-group.open .mobile-caret {
      transform: rotate(180deg);
    }

    @keyframes slideIn {
      to {
        opacity: 1;
        transform: translate3d(0, 0, 0);
      }
    }
  }

  /* Desktop optimizations */
  @media (min-width: 1025px) {
    .dropdown-menu {
      contain: layout style;
    }
  }

  /* Accessibility: Reduce motion */
  @media (prefers-reduced-motion: reduce) {
    .nav-link,
    .dropdown-menu,
    .mobile-caret {
      animation: none !important;
      transition: none !important;
    }

    nav.nav-open .nav-link {
      opacity: 1;
      transform: translate3d(0, 0, 0);
    }
  }

  /* Focus styles for better accessibility */
  .nav-item:focus-visible {
    outline: 2px solid var(--ui-focus-color, #0066cc);
    outline-offset: 2px;
    border-radius: 2px;
  }

  .skip-link:focus {
    z-index: 9999;
  }
</style>

<script>
  import {
    getNavigationContext,
    prefetchHighPriorityTargets,
  } from "@/lib/square/navigationUtils";

  interface NavElementData {
    link: HTMLElement;
    dropdown: HTMLElement;
    index: number;
    isOpen: boolean;
    prefetchStrategy: string;
    categoryName: string;
  }

  class OptimizedNavigationController {
    private navElements: Map<Element, NavElementData> = new Map();
    private isAnimating: boolean = false;
    private focusTimeout: number | null = null;
    private resizeObserver: ResizeObserver | null = null;
    private abortController: AbortController = new AbortController();

    constructor() {
      this.init();
    }

    private init(): void {
      this.cacheElements();
      this.setupEventDelegation();
      this.setupResizeObserver();
      this.initializePrefetching();
      this.enhanceAccessibility();
    }

    private initializePrefetching(): void {
      const context = getNavigationContext();
      prefetchHighPriorityTargets(context);

      if (import.meta.env.DEV) {
        console.log("[Navigation] Prefetch initialized for context:", context);
      }
    }

    private enhanceAccessibility(): void {
      const nav = document.querySelector("nav");
      if (!nav) return;

      // Enhance skip link functionality
      const skipLink = document.querySelector(
        ".skip-link"
      ) as HTMLAnchorElement;
      if (skipLink) {
        skipLink.addEventListener(
          "click",
          (e) => {
            e.preventDefault();
            const mainContent = document.getElementById("main-content");
            if (mainContent) {
              mainContent.focus();
              mainContent.scrollIntoView({
                behavior: "smooth",
                block: "start",
              });
            }
          },
          { signal: this.abortController.signal }
        );
      }

      // Add live region for screen reader announcements
      const liveRegion = document.createElement("div");
      liveRegion.setAttribute("aria-live", "polite");
      liveRegion.setAttribute("aria-atomic", "true");
      liveRegion.className = "sr-only";
      liveRegion.id = "nav-announcements";
      document.body.appendChild(liveRegion);
    }

    private announceToScreenReader(message: string): void {
      const liveRegion = document.getElementById("nav-announcements");
      if (liveRegion) {
        liveRegion.textContent = message;
        setTimeout(() => (liveRegion.textContent = ""), 1000);
      }
    }

    private cacheElements(): void {
      const categoryGroups = document.querySelectorAll(".category-group");

      categoryGroups.forEach((group: Element, index: number) => {
        const link = group.querySelector(".nav-item") as HTMLElement;
        const dropdown = group.querySelector(".dropdown-menu") as HTMLElement;
        const hasChildren = link?.getAttribute("data-has-children") === "true";

        if (hasChildren && link && dropdown) {
          const prefetchStrategy =
            link.getAttribute("data-prefetch-strategy") || "hover";
          const categoryName =
            link.getAttribute("data-category-name") || "Unknown";

          this.navElements.set(group, {
            link,
            dropdown,
            index,
            isOpen: false,
            prefetchStrategy,
            categoryName,
          });

          // Optimize for touch devices
          if ("ontouchstart" in window) {
            link.style.cursor = "pointer";
            dropdown.style.contain = "layout style";
          }
        }
      });
    }

    private setupEventDelegation(): void {
      const nav = document.querySelector("nav");
      if (!nav) return;

      // Use single event listener with delegation for better performance
      nav.addEventListener("click", this.handleClick.bind(this), {
        passive: false,
        signal: this.abortController.signal,
      });

      nav.addEventListener("focusout", this.handleFocusOut.bind(this), {
        passive: true,
        signal: this.abortController.signal,
      });

      // Optimized touch handling for mobile
      nav.addEventListener("touchstart", this.handleTouchStart.bind(this), {
        passive: true,
        signal: this.abortController.signal,
      });

      // Keyboard navigation enhancements
      nav.addEventListener("keydown", this.handleKeydown.bind(this), {
        signal: this.abortController.signal,
      });
    }

    private handleClick(event: Event): void {
      if (this.isAnimating) {
        event.preventDefault();
        return;
      }

      const target = event.target as HTMLElement;
      const clickedLink = target.closest(".nav-item") as HTMLAnchorElement;
      if (!clickedLink) return;

      const group = clickedLink.closest(".category-group");
      if (!group) return;

      const elementData = this.navElements.get(group);

      if (!elementData || window.innerWidth > 1024) return;

      event.preventDefault();
      this.toggleDropdown(group, elementData);
    }

    private handleKeydown(event: KeyboardEvent): void {
      const target = event.target as HTMLElement;
      const navItem = target.closest(".nav-item") as HTMLElement;

      if (!navItem) return;

      switch (event.key) {
        case "Enter":
        case " ":
          if (navItem.getAttribute("aria-haspopup") === "menu") {
            event.preventDefault();
            navItem.click();
          }
          break;
        case "Escape":
          this.closeAllDropdowns();
          this.announceToScreenReader("All menus closed");
          break;
        case "ArrowDown":
          if (navItem.getAttribute("aria-expanded") === "true") {
            event.preventDefault();
            this.focusFirstDropdownItem(navItem);
          }
          break;
      }
    }

    private focusFirstDropdownItem(navItem: HTMLElement): void {
      const group = navItem.closest(".category-group");
      const dropdown = group?.querySelector(".dropdown-menu");
      const firstLink = dropdown?.querySelector("a") as HTMLElement;
      if (firstLink) {
        firstLink.focus();
      }
    }

    private toggleDropdown(group: Element, elementData: NavElementData): void {
      // Use requestAnimationFrame for smooth animations
      requestAnimationFrame(() => {
        this.isAnimating = true;

        this.closeOtherDropdowns(group);

        const wasOpen = elementData.isOpen;
        this.setDropdownState(group, elementData, !wasOpen);

        // Announce state change for screen readers
        const action = wasOpen ? "collapsed" : "expanded";
        this.announceToScreenReader(
          `${elementData.categoryName} menu ${action}`
        );

        // Use shorter animation timeout for better responsiveness
        setTimeout(() => {
          this.isAnimating = false;
        }, 200);
      });
    }

    private closeOtherDropdowns(excludeGroup: Element): void {
      const updates: (() => void)[] = [];

      this.navElements.forEach(
        (elementData: NavElementData, group: Element) => {
          if (group !== excludeGroup && elementData.isOpen) {
            updates.push(() =>
              this.setDropdownState(group, elementData, false)
            );
          }
        }
      );

      if (updates.length) {
        requestAnimationFrame(() => {
          updates.forEach((update) => update());
        });
      }
    }

    private setDropdownState(
      group: Element,
      elementData: NavElementData,
      isOpen: boolean
    ): void {
      elementData.isOpen = isOpen;
      const { link, dropdown } = elementData;

      // Batch DOM updates for better performance
      requestAnimationFrame(() => {
        if (isOpen) {
          group.classList.add("open");
          link.setAttribute("aria-expanded", "true");
          (dropdown as HTMLElement).style.contain = "layout style";
        } else {
          group.classList.remove("open");
          link.setAttribute("aria-expanded", "false");
          (dropdown as HTMLElement).style.contain = "";
        }
      });
    }

    private handleFocusOut(event: Event): void {
      if (this.focusTimeout) {
        clearTimeout(this.focusTimeout);
      }

      this.focusTimeout = window.setTimeout(() => {
        const nav = event.currentTarget as HTMLElement;
        if (nav && !nav.contains(document.activeElement)) {
          this.closeAllDropdowns();
        }
      }, 0);
    }

    private handleTouchStart(event: Event): void {
      const target = event.target as HTMLElement;
      const group = target.closest(".category-group");
      if (group && this.navElements.has(group)) {
        // Optimize for touch by preparing for animation
        (group as HTMLElement).style.willChange = "transform";

        // Clean up after interaction
        setTimeout(() => {
          (group as HTMLElement).style.willChange = "auto";
        }, 300);
      }
    }

    private closeAllDropdowns(): void {
      requestAnimationFrame(() => {
        this.navElements.forEach(
          (elementData: NavElementData, group: Element) => {
            if (elementData.isOpen) {
              this.setDropdownState(group, elementData, false);
            }
          }
        );
      });
    }

    private setupResizeObserver(): void {
      // Use ResizeObserver for better performance than resize events
      this.resizeObserver = new ResizeObserver((entries) => {
        for (const entry of entries) {
          if (entry.contentRect.width > 1024) {
            this.closeAllDropdowns();
          }
        }
      });

      this.resizeObserver.observe(document.documentElement);
    }

    public destroy(): void {
      if (this.focusTimeout) {
        clearTimeout(this.focusTimeout);
      }

      if (this.resizeObserver) {
        this.resizeObserver.disconnect();
      }

      this.abortController.abort();
      this.navElements.clear();

      // Clean up live region
      const liveRegion = document.getElementById("nav-announcements");
      if (liveRegion) {
        liveRegion.remove();
      }
    }
  }

  function initializeOptimizedNavigation(): OptimizedNavigationController {
    const navController = new OptimizedNavigationController();

    if (import.meta.env.DEV) {
      console.log("[Navigation] Optimized navigation controller initialized");
    }

    return navController;
  }

  // Keep existing Astro page transition handling
  let navController: OptimizedNavigationController | null = null;

  document.addEventListener("astro:before-swap", () => {
    if (navController) {
      navController.destroy();
      navController = null;
    }
  });

  document.addEventListener("astro:after-swap", () => {
    navController = initializeOptimizedNavigation();
  });

  // Initial load
  if (document.readyState === "loading") {
    document.addEventListener("DOMContentLoaded", () => {
      navController = initializeOptimizedNavigation();
    });
  } else {
    navController = initializeOptimizedNavigation();
  }
</script>
