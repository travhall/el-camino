---
// src/components/FilterableProductGrid.astro - PHASE 2: PAGINATION MODE SUPPORT
import ProductCard from "./ProductCard.astro";
import type { Product } from "@/lib/square/types";

interface Props {
  products: Product[];
  paginationMode?: boolean; // NEW: Enable server-side pagination behavior
  categoryPath?: string; // NEW: Base path for pagination redirects
}

const { products, paginationMode = false, categoryPath = "" } = Astro.props;
---

<div
  id="filterable-product-grid"
  class="grid grid-cols-2 md:grid-cols-3 lg:grid-cols-4 xl:grid-cols-5 gap-1 transition-opacity duration-300"
  data-products={JSON.stringify(products)}
  data-pagination-mode={paginationMode}
  data-category-path={categoryPath}
>
  {
    products.map((product, index) => (
      <div
        class="product-card-wrapper grid"
        data-product-id={product.id}
        data-brand={product.brand || ""}
      >
        <ProductCard product={product} priority={index < 8} />
      </div>
    ))
  }
</div>

<!-- No Results State (only shown in client-side mode) -->
<div
  id="no-results"
  class={`${paginationMode ? "hidden" : ""} justify-center items-center col-span-full py-16 text-center`}
>
  <div class="text-center">
    <div class="text-6xl mb-4 opacity-20">üîç</div>
    <h2 class="text-2xl font-display font-bold text-content-heading mb-2">
      No products found
    </h2>
    <p class="text-content-meta mb-6 max-w-md">
      Try adjusting your filters or browse all products.
    </p>
    <button
      id="clear-filters-cta"
      class="px-6 py-2 bg-ui-button-surface text-ui-button-text border border-ui-button-border rounded hover:bg-ui-button-hover transition-colors"
    >
      Clear Filters
    </button>
  </div>
</div>

<script>
  import {
    filterProducts,
    parseFiltersFromURL,
    updateURLWithFilters,
    updateURLWithFiltersResetPage,
    hasActiveFilters,
    clearAllFilters,
  } from "@/lib/square/filterUtils";
  import type { Product, ProductFilters } from "@/lib/square/types";

  class FilterableProductGrid {
    private grid: HTMLElement;
    private noResults: HTMLElement;
    private allProducts: Product[];
    private productWrappers: HTMLElement[];
    private isFiltering = false;
    private paginationMode: boolean;
    private categoryPath: string;

    constructor() {
      this.grid = document.getElementById("filterable-product-grid")!;
      this.noResults = document.getElementById("no-results")!;

      // Parse configuration from data attributes
      this.allProducts = JSON.parse(this.grid.dataset.products || "[]");
      this.paginationMode = this.grid.dataset.paginationMode === "true";
      this.categoryPath = this.grid.dataset.categoryPath || "";

      // Get all product wrapper elements
      this.productWrappers = Array.from(
        this.grid.querySelectorAll(".product-card-wrapper")
      );

      console.log(
        `[FilterableProductGrid] Mode: ${this.paginationMode ? "pagination" : "client-side"}`
      );

      this.setupEventListeners();

      // Only handle initial filters in client-side mode
      if (!this.paginationMode) {
        this.handleInitialFilters();
      }
    }

    private setupEventListeners(): void {
      // Listen for filter changes from ProductFilters component
      window.addEventListener(
        "filtersChanged",
        this.handleFiltersChanged.bind(this) as EventListener
      );

      // Clear filters CTA (only relevant in client-side mode)
      document
        .getElementById("clear-filters-cta")
        ?.addEventListener("click", () => {
          this.clearAllFilters();
        });
    }

    private handleInitialFilters(): void {
      // Only apply initial filters in client-side mode
      if (this.paginationMode) return;

      const params = new URLSearchParams(window.location.search);
      const filters = parseFiltersFromURL(params);

      if (hasActiveFilters(filters)) {
        this.applyFilters(filters);
      }
    }

    private handleFiltersChanged(event: CustomEvent): void {
      const { filters } = event.detail;

      if (this.paginationMode) {
        // Only redirect if filters actually changed from URL state
        const currentParams = new URLSearchParams(window.location.search);
        const currentFiltersFromURL = parseFiltersFromURL(currentParams);

        // Compare current filters to what's in URL
        const filtersChanged =
          JSON.stringify(filters) !== JSON.stringify(currentFiltersFromURL);

        if (filtersChanged) {
          // PAGINATION MODE: Redirect to page 1 with new filters
          this.redirectWithFilters(filters);
        }
        // If filters haven't changed, do nothing (don't redirect)
      } else {
        // CLIENT-SIDE MODE: Apply filters immediately
        this.applyFilters(filters);
      }
    }

    private redirectWithFilters(filters: ProductFilters): void {
      console.log("[FilterableProductGrid] Redirecting with filters:", filters);

      // Show loading state
      this.grid.style.opacity = "0.6";

      // Update URL and navigate (will trigger page reload)
      updateURLWithFiltersResetPage(filters);

      // Fallback: if URL update doesn't trigger navigation, reload manually
      setTimeout(() => {
        if (this.grid.style.opacity === "0.6") {
          window.location.href = window.location.href;
        }
      }, 100);
    }

    private applyFilters(filters: ProductFilters): void {
      // Only used in client-side mode
      if (this.paginationMode || this.isFiltering) return;

      this.isFiltering = true;

      console.log(
        "[FilterableProductGrid] Applying client-side filters:",
        filters
      );

      // Add loading state
      this.grid.style.opacity = "0.6";

      // Use requestAnimationFrame for smooth transitions
      requestAnimationFrame(() => {
        const filteredProducts = filterProducts(this.allProducts, filters);
        const filteredIds = new Set(filteredProducts.map((p) => p.id));

        console.log(
          "[FilterableProductGrid] Showing products:",
          filteredProducts.length
        );

        this.updateGrid(filteredIds);
        this.updateCounts(filteredProducts.length);

        // Remove loading state
        this.grid.style.opacity = "1";
        this.isFiltering = false;
      });
    }

    private updateGrid(visibleProductIds: Set<string>): void {
      console.log("[FilterableProductGrid] Updating grid visibility");

      let visibleCount = 0;

      // Show/hide existing product wrappers instead of recreating HTML
      this.productWrappers.forEach((wrapper) => {
        const productId = wrapper.dataset.productId;

        if (visibleProductIds.has(productId!)) {
          wrapper.style.display = "";
          wrapper.classList.remove("hidden");
          visibleCount++;
        } else {
          wrapper.style.display = "none";
          wrapper.classList.add("hidden");
        }
      });

      // Show/hide no results (only in client-side mode)
      if (!this.paginationMode) {
        if (visibleCount === 0) {
          this.noResults.style.display = "flex";
          this.noResults.classList.remove("hidden");
          this.noResults.classList.add("flex", "flex-col");
        } else {
          this.noResults.style.display = "none";
          this.noResults.classList.add("hidden");
          this.noResults.classList.remove("flex", "flex-col");
        }
      }
    }

    private updateCounts(filteredCount: number): void {
      // Update desktop count
      const desktopCount = document.getElementById("filtered-count");
      if (desktopCount) {
        desktopCount.textContent = filteredCount.toString();
      }

      // Update mobile count
      const mobileCount = document.getElementById("mobile-filtered-count");
      if (mobileCount) {
        mobileCount.textContent = filteredCount.toString();
      }
    }

    private clearAllFilters(): void {
      const emptyFilters = clearAllFilters();

      if (this.paginationMode) {
        // Redirect to category root
        window.location.href = this.categoryPath;
      } else {
        // Update URL and apply filters
        updateURLWithFilters(emptyFilters);
        this.applyFilters(emptyFilters);

        // Dispatch event to sync filter UI
        window.dispatchEvent(new CustomEvent("clearAllFilters"));
      }
    }
  }

  // Initialize on page load
  document.addEventListener("astro:page-load", () => {
    new FilterableProductGrid();
  });
</script>
