---
// src/components/FilterableProductGrid.astro
import ProductCard from "./ProductCard.astro";
import ProductCardSkeleton from "./ProductCardSkeleton.astro";
import type { Product } from "@/lib/square/types";

interface Props {
  products: Product[];
  paginationMode?: boolean;
  categoryPath?: string;
}

const { products, paginationMode = false, categoryPath = "" } = Astro.props;
---

<div
  id="filterable-product-grid"
  class="grid md:grid-cols-2 lg:grid-cols-3 xl:grid-cols-4 2xl:grid-cols-6 gap-1 transition-all duration-300"
  data-products={JSON.stringify(products)}
  data-pagination-mode={paginationMode}
  data-category-path={categoryPath}
>
  {
    products.map((product, index) => (
      <div
        class="product-card-wrapper grid"
        data-product-id={product.id}
        data-brand={product.brand || ""}
      >
        <ProductCard product={product} priority={index < 8} />
      </div>
    ))
  }
</div>

<!-- Enhanced Loading Overlay -->
<div
  id="filter-loading-overlay"
  class="hidden fixed inset-0 bg-surface-primary/60 backdrop-blur-sm z-40 flex items-center justify-center"
>
  <div
    class="bg-surface-secondary rounded-lg p-6 shadow-lg flex items-center space-x-3"
  >
    <div
      class="animate-spin rounded-full h-5 w-5 border-2 border-ui-accent border-t-transparent"
    >
    </div>
    <span class="text-content-body font-medium">Applying filters...</span>
  </div>
</div>

<!-- Product Grid Loading Skeleton -->
<div
  id="product-grid-skeleton"
  class="hidden grid-cols-2 md:grid-cols-2 lg:grid-cols-3 xl:grid-cols-4 2xl:grid-cols-6 gap-1"
>
  {
    Array.from({ length: 12 }, (_, i) => (
      <ProductCardSkeleton priority={i < 8} />
    ))
  }
</div>

<!-- No Results State (for client-side mode only) -->
<div
  id="no-results"
  class={`${paginationMode ? "hidden" : "flex flex-col"} justify-center items-center col-span-full py-16 text-center`}
>
  <div class="text-center">
    <div class="text-6xl mb-4 opacity-20">üîç</div>
    <h2 class="text-2xl font-display font-bold text-content-heading mb-2">
      No products found
    </h2>
    <p class="text-content-meta mb-6 max-w-md">
      Try adjusting your filters or browse all products.
    </p>
    <button
      id="clear-filters-cta"
      class="px-6 py-2 bg-ui-button-surface text-ui-button-text border border-ui-button-border rounded hover:bg-ui-button-hover transition-colors"
    >
      Clear Filters
    </button>
  </div>
</div>

<script>
  import {
    filterProducts,
    parseFiltersFromURL,
    updateURLWithFilters,
    updateURLWithFiltersResetPage,
    hasActiveFilters,
    clearAllFilters,
  } from "@/lib/square/filterUtils";
  import type { Product, ProductFilters } from "@/lib/square/types";

  // Replace the class properties and constructor in FilterableProductGrid.astro:

  class FilterableProductGrid {
    private grid: HTMLElement | null;
    private noResults!: HTMLElement;
    private loadingOverlay!: HTMLElement;
    private skeleton!: HTMLElement;
    private allProducts!: Product[];
    private productWrappers!: HTMLElement[];
    private isFiltering = false;
    private paginationMode!: boolean;
    private categoryPath!: string;

    constructor() {
      this.grid = document.getElementById("filterable-product-grid");

      // Exit early if component doesn't exist on this page
      if (!this.grid) {
        console.log("[FilterableProductGrid] Component not found on this page");
        return;
      }

      this.noResults = document.getElementById("no-results")!;
      this.loadingOverlay = document.getElementById("filter-loading-overlay")!;
      this.skeleton = document.getElementById("product-grid-skeleton")!;

      // Parse configuration from data attributes
      this.allProducts = JSON.parse(this.grid.dataset.products || "[]");
      this.paginationMode = this.grid.dataset.paginationMode === "true";
      this.categoryPath = this.grid.dataset.categoryPath || "";

      this.productWrappers = Array.from(
        this.grid.querySelectorAll(".product-card-wrapper")
      );

      console.log(
        `[FilterableProductGrid] Mode: ${this.paginationMode ? "server-first" : "client-side"}`
      );

      this.setupEventListeners();

      // Only handle initial filters in client-side mode
      if (!this.paginationMode) {
        this.handleInitialFilters();
      }
    }

    // Add null check to methods that use this.grid:
    private fadeOutUnmatchedProducts(filters: ProductFilters): void {
      if (!this.grid) return;

      const filteredProducts = filterProducts(this.allProducts, filters);
      const visibleIds = new Set(filteredProducts.map((p) => p.id));

      this.productWrappers.forEach((wrapper) => {
        const productId = wrapper.dataset.productId;

        if (visibleIds.has(productId!)) {
          wrapper.style.opacity = "1";
          wrapper.style.transform = "scale(1)";
        } else {
          wrapper.style.opacity = "0.3";
          wrapper.style.transform = "scale(0.95)";
        }
      });

      this.updateCounts(filteredProducts.length);
    }

    private showFilteringFeedback(): void {
      if (!this.grid) return;

      this.grid.style.opacity = "0.8";
      this.grid.style.pointerEvents = "none";
    }

    private showFullPageLoading(): void {
      if (!this.grid) return;

      this.loadingOverlay.classList.remove("hidden");
      this.grid.style.opacity = "0.3";
    }

    private hideLoadingStates(): void {
      if (!this.grid) return;

      this.loadingOverlay.classList.add("hidden");
      this.grid.style.opacity = "1";
      this.grid.style.pointerEvents = "auto";
      this.isFiltering = false;

      this.productWrappers.forEach((wrapper) => {
        wrapper.style.opacity = "1";
        wrapper.style.transform = "scale(1)";
      });
    }

    private applyFilters(filters: ProductFilters): void {
      if (!this.grid || this.paginationMode || this.isFiltering) return;

      this.isFiltering = true;
      console.log("[FilterableProductGrid] Client-side filtering:", filters);

      this.grid.style.opacity = "0.6";

      requestAnimationFrame(() => {
        const filteredProducts = filterProducts(this.allProducts, filters);
        const filteredIds = new Set(filteredProducts.map((p) => p.id));

        this.updateGrid(filteredIds);
        this.updateCounts(filteredProducts.length);

        if (this.grid) {
          this.grid.style.opacity = "1";
        }
        this.isFiltering = false;
      });
    }

    private setupEventListeners(): void {
      // Listen for filter changes from ProductFilters component
      window.addEventListener(
        "filtersChanged",
        this.handleFiltersChanged.bind(this) as EventListener
      );

      // Clear filters CTA
      document
        .getElementById("clear-filters-cta")
        ?.addEventListener("click", () => {
          this.clearAllFilters();
        });

      // Handle navigation completion (Astro page loads)
      document.addEventListener("astro:page-load", () => {
        this.hideLoadingStates();
      });
    }

    private handleInitialFilters(): void {
      if (this.paginationMode) return;

      const params = new URLSearchParams(window.location.search);
      const filters = parseFiltersFromURL(params);

      if (hasActiveFilters(filters)) {
        this.applyFilters(filters);
      }
    }

    private handleFiltersChanged(event: CustomEvent): void {
      const { filters } = event.detail;

      if (this.isFiltering) return;

      if (this.paginationMode) {
        this.applyFiltersServerFirst(filters);
      } else {
        this.applyFilters(filters);
      }
    }

    private applyFiltersServerFirst(filters: ProductFilters): void {
      if (this.isFiltering) return;
      this.isFiltering = true;

      console.log("[FilterableProductGrid] Server-first filtering:", filters);

      this.showOptimisticUpdate(filters);

      setTimeout(() => {
        updateURLWithFiltersResetPage(filters);

        setTimeout(() => {
          if (this.isFiltering) {
            window.location.href = window.location.href;
          }
        }, 150);
      }, 50);
    }

    private showOptimisticUpdate(filters: ProductFilters): void {
      if (hasActiveFilters(filters)) {
        const predictedResults = filterProducts(this.allProducts, filters);

        if (predictedResults.length > 0) {
          this.fadeOutUnmatchedProducts(filters);
          this.showFilteringFeedback();
        } else {
          this.showFullPageLoading();
        }
      } else {
        this.showAllProducts();
        this.showFilteringFeedback();
      }
    }

    private showAllProducts(): void {
      this.productWrappers.forEach((wrapper) => {
        wrapper.style.opacity = "1";
        wrapper.style.transform = "scale(1)";
      });
      this.updateCounts(this.allProducts.length);
    }

    private updateGrid(visibleProductIds: Set<string>): void {
      let visibleCount = 0;

      this.productWrappers.forEach((wrapper) => {
        const productId = wrapper.dataset.productId;

        if (visibleProductIds.has(productId!)) {
          wrapper.style.display = "";
          wrapper.classList.remove("hidden");
          visibleCount++;
        } else {
          wrapper.style.display = "none";
          wrapper.classList.add("hidden");
        }
      });

      if (!this.paginationMode) {
        if (visibleCount === 0) {
          this.noResults.style.display = "flex";
          this.noResults.classList.remove("hidden");
          this.noResults.classList.add("flex", "flex-col");
        } else {
          this.noResults.style.display = "none";
          this.noResults.classList.add("hidden");
          this.noResults.classList.remove("flex", "flex-col");
        }
      }
    }

    private updateCounts(filteredCount: number): void {
      const desktopCount = document.getElementById("filtered-count");
      if (desktopCount) {
        desktopCount.textContent = filteredCount.toString();
      }

      const mobileCount = document.getElementById("mobile-filtered-count");
      if (mobileCount) {
        mobileCount.textContent = filteredCount.toString();
      }
    }

    private clearAllFilters(): void {
      const emptyFilters = clearAllFilters();

      if (this.paginationMode) {
        this.showOptimisticUpdate(emptyFilters);
        setTimeout(() => {
          window.location.href = this.categoryPath;
        }, 50);
      } else {
        updateURLWithFilters(emptyFilters);
        this.applyFilters(emptyFilters);

        window.dispatchEvent(new CustomEvent("clearAllFilters"));
      }
    }
  }

  // Initialize on page load
  document.addEventListener("astro:page-load", () => {
    new FilterableProductGrid();
  });
</script>

<style>
  /* Smooth transitions for optimistic updates */
  .product-card-wrapper {
    transition:
      opacity 0.2s ease,
      transform 0.2s ease;
  }

  #filterable-product-grid {
    transition: opacity 0.3s ease;
  }

  /* Loading animation */
  @keyframes pulse {
    0%,
    100% {
      opacity: 1;
    }
    50% {
      opacity: 0.5;
    }
  }

  .animate-pulse {
    animation: pulse 2s cubic-bezier(0.4, 0, 0.6, 1) infinite;
  }

  /* Spinner animation */
  @keyframes spin {
    to {
      transform: rotate(360deg);
    }
  }

  .animate-spin {
    animation: spin 1s linear infinite;
  }

  /* Better product card transitions */
  .product-card-wrapper {
    transition:
      opacity 0.25s cubic-bezier(0.4, 0, 0.2, 1),
      transform 0.25s cubic-bezier(0.4, 0, 0.2, 1);
    will-change: opacity, transform;
  }

  /* Reduce motion for accessibility */
  @media (prefers-reduced-motion: reduce) {
    .product-card-wrapper {
      transition: none;
    }
  }
</style>
