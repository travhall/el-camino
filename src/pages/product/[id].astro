---
import Layout from "@/layouts/Layout.astro";
import Button from "@/components/Button.astro";
import { fetchProduct } from "@/lib/square/client";
import { MoneyUtils } from "@/lib/square/money";
import { checkBulkInventory } from "@/lib/square/inventory";
import {
  createInitialSelectionState,
  getAttributeDisplayName,
} from "@/lib/square/variationParser";
import { fetchProducts } from "@/lib/square/client";
import {
  extractIdFromSlug,
  createSlug,
  getVariationFromVariantParam,
  createSEOTitle,
  createSlugMapping,
} from "@/lib/square/slugUtils";

// Get the slug from URL params (note: still called 'id' because file is [id].astro)
const { id: slug } = Astro.params;
const variantParam = Astro.url.searchParams.get("variant");

if (!slug) {
  return Astro.redirect("/404");
}

// Create slug mapping (in production, this should be cached/built at build time)
const allProducts = await fetchProducts();
const slugMapping = createSlugMapping(allProducts);

// Get Square ID from slug
const id = extractIdFromSlug(slug, slugMapping);

if (!id) {
  console.error(`No ID found for slug: ${slug}`);
  return Astro.redirect("/404");
}

// Fetch product data
const product = await fetchProduct(id);
if (!product) {
  console.error(`Product not found for ID: ${id}`);
  return Astro.redirect("/404");
}

// Handle old ID-only URLs - redirect to new format
if (slug === id) {
  const productSlug = createSlug(product.title);
  return Astro.redirect(`/product/${productSlug}`, 301);
}

// Handle variant parameter
if (variantParam && product.variations) {
  const targetVariation = getVariationFromVariantParam(product, variantParam);

  if (targetVariation) {
    // Update product with selected variant
    product.selectedVariationId = targetVariation.variationId;
    product.price = targetVariation.price;
    if (targetVariation.image) {
      product.image = targetVariation.image;
    }
  } else {
    // Invalid variant parameter - redirect to base product
    const baseSlug = createSlug(product.title);
    return Astro.redirect(`/product/${baseSlug}`, 301);
  }
}

if (!product) {
  return Astro.redirect("/404");
}

// Set default variation ID and prepare for inventory checking
let defaultVariationId = product.variationId;
let variations = product.variations || [];
let inventoryMap: Record<string, number> = {};

// Check inventory for all variations at once
if (variations.length > 0) {
  try {
    // Get all variation IDs for batch inventory check
    const variationIds = variations.map((v) => v.variationId);

    // Get inventory for all variations in a single request
    inventoryMap = await checkBulkInventory(variationIds);

    // Update variation data with inventory information
    variations = variations.map((v) => ({
      ...v,
      inStock: (inventoryMap[v.variationId] || 0) > 0,
      quantity: inventoryMap[v.variationId] || 0,
    }));

    // Check if default variation is in stock
    const defaultIsInStock = (inventoryMap[defaultVariationId] || 0) > 0;

    // If default is out of stock, find first in-stock variation
    if (!defaultIsInStock && variations.length > 0) {
      const firstInStockVariation = variations.find((v) => v.inStock);
      if (firstInStockVariation) {
        defaultVariationId = firstInStockVariation.variationId;
        // Use variation-specific image if available
        if (firstInStockVariation.image) {
          product.image = firstInStockVariation.image;
        }
      }
    }
  } catch (err) {
    console.error(
      `Inventory check error: ${err instanceof Error ? err.message : String(err)}`
    );
    // Default to allowing purchases if inventory check fails
    variations = variations.map((v) => ({
      ...v,
      inStock: true,
      quantity: 999,
    }));
  }
} else {
  // Single variation product - mark as in stock by default
  const quantity = inventoryMap[product.variationId] || 999;
  variations = [
    {
      id: product.variationId,
      variationId: product.variationId,
      name: product.title,
      price: product.price,
      inStock: quantity > 0,
      quantity: quantity,
      attributes: {}, // Add empty attributes for consistency
    },
  ];
}

// Create initial selection state using the parser
const selectionState = createInitialSelectionState(variations);
const availableAttributes = selectionState.availableAttributes;
const attributeTypes = Object.keys(availableAttributes);

// Find selected variation
const selectedVariation =
  variations.find((v) => v.variationId === defaultVariationId) || variations[0];
const selectedVariationInStock = selectedVariation?.inStock || false;
const selectedVariationQuantity = selectedVariation?.quantity || 0;
const formattedPrice = MoneyUtils.format(
  MoneyUtils.fromFloat(selectedVariation?.price || product.price)
);

// Check if we have multiple variations
const hasMultipleVariations = variations.length > 1;

// Set product metadata
const pageTitle = product.title;
const selectedVariationForSEO =
  variantParam && product.variations
    ? product.variations.find(
        (v) => v.variationId === product.selectedVariationId
      )
    : undefined;
const fullTitle = createSEOTitle(product, selectedVariationForSEO);
const unitDisplay = selectedVariation?.unit || product.unit || "";
---

<Layout title={fullTitle}>
  <section class="p-4 sm:p-6 lg:p-8 relative">
    <div
      class="lg:grid lg:grid-cols-2 lg:gap-x-8 xl:gap-x-12 2xl:gap-x-16 items-start"
    >
      <!-- Product Image -->
      <div
        class="aspect-square border-4 border-surface-secondary overflow-hidden bg-surface-secondary relative"
      >
        <img
          id="product-image"
          src={product.image}
          alt={product.title}
          class={`w-full h-full object-cover ${!selectedVariationInStock ? "opacity-50" : ""}`}
          loading="eager"
          fetchpriority="high"
          onerror="this.src='/images/placeholder.png'"
        />

        {/* Out of stock overlay */}
        {
          !selectedVariationInStock && (
            <div
              id="stock-overlay"
              class="absolute top-0 left-0 bg-state-error-surface text-state-error-text px-3 py-2 text-md font-bold rounded-sm"
            >
              Sold Out
            </div>
          )
        }
      </div>

      <!-- Product Info -->
      <div class="product-info mt-10 lg:mt-0">
        <h1
          class="flex flex-col font-display font-bold text-4xl lg:text-5xl xl:text-6xl 2xl:text-7xl leading-[0.8] text-content-heading text-balance"
        >
          <!-- Brand display -->
          {
            product.brand && (
              <span class="text-xl font-normal uppercase -mb-1">
                {product.brand}
              </span>
            )
          }
          {product.title}
        </h1>

        <!-- Price Display -->
        <div class="mt-2">
          <p
            id="price-display"
            class="text-3xl lg:text-4xl xl:text-5xl font-display font-bold text-content-emphasis mb-2"
          >
            {formattedPrice}
            {/* Unit display */}
            {
              unitDisplay && (
                <span class="text-xl" id="unit-display">
                  {unitDisplay}
                </span>
              )
            }
          </p>
          <small class="italic"
            >Shipping &amp; taxes are calculated at checkout</small
          >
        </div>

        <!-- Product Description -->
        {
          product.description && (
            <div class="mt-6 max-w-[54ch]">
              <p class="text-base text-content-body text-balance">
                {product.description}
              </p>
            </div>
          )
        }

        <!-- Dynamic Attribute Selectors -->
        {
          hasMultipleVariations &&
            attributeTypes
              .filter(
                (attributeType) =>
                  availableAttributes[attributeType]?.length > 1
              )
              .map((attributeType) => {
                const attributeValues = availableAttributes[attributeType];
                const displayName = getAttributeDisplayName(attributeType);

                return (
                  <div class="mt-6">
                    <h3 class="text-sm font-medium text-content-heading mb-2">
                      {displayName}
                    </h3>
                    <div class="flex flex-wrap gap-2">
                      {attributeValues.map((value) => {
                        const isAvailable = variations.some((variation) => {
                          if (!variation.attributes || !variation.inStock)
                            return false;
                          return variation.attributes[attributeType] === value;
                        });

                        return (
                          <button
                            type="button"
                            data-attribute-type={attributeType}
                            data-attribute-value={value}
                            class:list={[
                              "px-4 py-2 border rounded attribute-button",
                              "bg-ui-input-surface text-ui-input-text border-ui-input-border/50",
                              !isAvailable && "opacity-50",
                            ]}
                            disabled={!isAvailable}
                          >
                            {value}
                          </button>
                        );
                      })}
                    </div>
                  </div>
                );
              })
        }

        <!-- Single attribute display (when not varying) -->
        {
          attributeTypes
            .filter(
              (attributeType) =>
                availableAttributes[attributeType]?.length === 1
            )
            .map((attributeType) => {
              const attributeValues = availableAttributes[attributeType];
              const displayName = getAttributeDisplayName(attributeType);

              return (
                <div class="mt-4">
                  <h3 class="text-sm font-medium text-content-heading mb-2">
                    {displayName}
                  </h3>
                  <div class="inline-block px-4 py-2 bg-ui-button-surface text-ui-button-text border-ui-button-border/50 rounded">
                    {attributeValues[0]}
                  </div>
                </div>
              );
            })
        }

        <!-- Fallback: Standard Variation Selection (for variations that don't have structured attributes) -->
        {
          hasMultipleVariations && attributeTypes.length === 0 && (
            <div class="mt-6">
              <h3 class="text-sm font-medium text-content-heading mb-2">
                Options
              </h3>
              <div id="variation-buttons" class="flex flex-wrap gap-2">
                {variations.map((variation) => (
                  <button
                    type="button"
                    data-variation-id={variation.variationId}
                    data-price={variation.price}
                    data-name={variation.name}
                    data-quantity={variation.quantity}
                    data-in-stock={variation.inStock ? "true" : "false"}
                    data-image={variation.image || ""}
                    data-unit={variation.unit || ""}
                    class:list={[
                      "px-4 py-2 border rounded",
                      variation.variationId === defaultVariationId
                        ? "bg-ui-button-surface text-ui-button-text border-ui-button-border/50"
                        : "bg-ui-input-surface text-ui-input-text border-ui-input-border/50",
                      !variation.inStock && "opacity-50",
                    ]}
                    disabled={!variation.inStock}
                  >
                    {variation.name}
                  </button>
                ))}
              </div>
            </div>
          )
        }

        <!-- Quantity Input -->
        <div class="mt-6">
          <div class="flex flex-col space-y-2 items-start">
            <label for="quantity-input" class="text-sm font-medium"
              >Quantity</label
            >
            <div
              class="flex border border-ui-input-border/50 rounded-md overflow-hidden"
            >
              <button
                type="button"
                id="decrease-quantity"
                class="w-10 h-10 flex items-center justify-center border-r border-ui-input-border/50 bg-ui-input-surface text-ui-input-text"
                disabled={true}
              >
                -
              </button>
              <input
                type="number"
                id="quantity-input"
                min="1"
                max={selectedVariationQuantity}
                value="1"
                class="w-14 h-10 text-center bg-ui-input-surface text-ui-input-text [appearance:textfield] [&::-webkit-outer-spin-button]:appearance-none [&::-webkit-inner-spin-button]:appearance-none"
              />
              <button
                type="button"
                id="increase-quantity"
                class="w-10 h-10 flex items-center justify-center border-l border-ui-input-border/50 bg-ui-input-surface text-ui-input-text"
                disabled={selectedVariationQuantity <= 1}
              >
                +
              </button>
            </div>
            <div id="availability-indicator" class="text-sm">
              <span class="text-content-meta" id="remaining-count">
                {selectedVariationQuantity} available
              </span>
              <span id="cart-quantity" class="ml-1 hidden">
                ( 0 in cart )
              </span>
            </div>
          </div>
        </div>

        <!-- Hidden data for JavaScript -->
        <input
          type="hidden"
          id="variation-data"
          value={JSON.stringify({
            variations: variations,
            availableAttributes: availableAttributes,
            selectedVariationId: defaultVariationId,
            productId: product.id,
          })}
        />

        <!-- Cart Status Indicator -->
        <div class="mt-2">
          <span
            id="cart-status"
            class="text-sm font-medium text-state-info-text bg-state-info-surface px-2 py-1 rounded hidden"
          ></span>
        </div>

        <!-- Add to Cart Button -->
        <div class="mt-4">
          <Button
            type="button"
            variant="primary"
            size="lg"
            classes={`w-full md:w-auto ${!selectedVariationInStock ? "opacity-50 cursor-not-allowed" : ""}`}
            data-product={JSON.stringify({
              id: product.id,
              catalogObjectId: product.catalogObjectId,
              variationId: defaultVariationId,
              title: product.title,
              price: selectedVariation?.price || product.price,
              image: product.image,
              unit: unitDisplay,
              variationName: selectedVariation?.name || "",
            })}
            id="add-to-cart-button"
            disabled={!selectedVariationInStock}
          >
            {selectedVariationInStock ? "Add to Cart" : "Sold Out"}
          </Button>
        </div>

        <!-- Store Information -->
        <div
          class="text-sm flex flex-col mt-8 space-y-1 ps-4 py-2 border-l-2 border-ui-nav-border"
        >
          <p class="italic">Available for pick up at El Camino</p>
          <a href="#" class="underline font-bold hover:no-underline mb-2"
            >Store Location &amp; Hours</a
          >
        </div>
      </div>
    </div>
  </section>
</Layout>

<script>
  import { cart } from "@/lib/cart";
  import { MoneyUtils } from "@/lib/square/money";
  import { findVariationByAttributes } from "@/lib/square/variationParser";
  import type { ProductData } from "@/lib/square/types";
  import {
    ProductAvailabilityState,
    getButtonText,
    isButtonDisabled,
    getDefaultQuantity,
    getMaxQuantity,
    isQuantityInputDisabled,
  } from "@/lib/square/types";
  import { createVariantSlug } from "@/lib/square/slugUtils";

  // Global declarations
  declare global {
    interface Window {
      cart: typeof cart;
      showNotification: (
        message: string,
        type?: "success" | "error" | "info",
        duration?: number
      ) => void;
    }
  }

  let isProcessing = false;
  let selectedAttributes: Record<string, string> = {};
  let currentVariation: any = null;
  let variations: any[] = [];
  let availableAttributes: Record<string, string[]> = {};
  let productId = "";

  /**
   * Central availability update function - replaces all the scattered updates
   */
  function updateProductAvailability(
    variationId: string,
    totalInventory: number
  ): void {
    console.log(
      `Updating availability for ${productId}:${variationId}, inventory: ${totalInventory}`
    );

    // Get current availability info from cart
    const availabilityInfo = cart.getProductAvailability(
      productId,
      variationId,
      totalInventory
    );
    console.log("Availability info:", availabilityInfo);

    // Update all UI elements with centralized logic
    updateQuantityControls(availabilityInfo);
    updateAddToCartButton(availabilityInfo);
    updateStatusMessaging(availabilityInfo);
    updateImageOverlay(availabilityInfo);
    updateInventoryDisplay(availabilityInfo);
  }

  /**
   * Update quantity input and controls
   */
  function updateQuantityControls(info: any): void {
    const quantityInput = document.getElementById(
      "quantity-input"
    ) as HTMLInputElement;
    const decreaseButton = document.getElementById(
      "decrease-quantity"
    ) as HTMLButtonElement;
    const increaseButton = document.getElementById(
      "increase-quantity"
    ) as HTMLButtonElement;

    if (!quantityInput) return;

    // Set default quantity (1 for available, 0 for unavailable)
    const defaultQty = getDefaultQuantity(info.state);
    quantityInput.value = defaultQty.toString();

    // Set max to remaining (not total)
    const maxQty = getMaxQuantity(info);
    quantityInput.max = maxQty.toString();

    // Enable/disable based on state
    const isDisabled = isQuantityInputDisabled(info.state);
    quantityInput.disabled = isDisabled;

    // Update buttons
    if (decreaseButton) {
      decreaseButton.disabled = isDisabled || defaultQty <= 1;
    }
    if (increaseButton) {
      increaseButton.disabled = isDisabled || defaultQty >= maxQty;
    }

    console.log(
      `Quantity controls updated: default=${defaultQty}, max=${maxQty}, disabled=${isDisabled}`
    );
  }

  /**
   * Update add to cart button
   */
  function updateAddToCartButton(info: any): void {
    const addToCartBtn = document.getElementById(
      "add-to-cart-button"
    ) as HTMLButtonElement;
    if (!addToCartBtn) return;

    // Update button text using centralized helper
    addToCartBtn.textContent = getButtonText(info.state);

    // Update disabled state
    const shouldDisable = isButtonDisabled(info.state);
    addToCartBtn.disabled = shouldDisable;

    // Update visual feedback
    if (shouldDisable) {
      addToCartBtn.classList.add("opacity-50");
    } else {
      addToCartBtn.classList.remove("opacity-50");
    }

    console.log(
      `Button updated: text="${getButtonText(info.state)}", disabled=${shouldDisable}`
    );
  }

  /**
   * Update status messaging - ONLY show when out of stock
   */
  function updateStatusMessaging(info: any): void {
    const inventoryStatus = document.getElementById("inventory-status");
    if (!inventoryStatus) return;

    // ONLY show message when truly out of stock
    if (info.state === ProductAvailabilityState.OUT_OF_STOCK) {
      inventoryStatus.innerHTML = `
        <p class="mt-2 text-state-error-surface text-md font-bold inline-block">
          Out of Stock
        </p>
      `;
    } else {
      // Clear the status for all other states (available, all in cart)
      inventoryStatus.innerHTML = "";
    }

    // console.log(
    //   `Status updated: ${info.state === ProductAvailabilityState.OUT_OF_STOCK ? "Out of Stock" : "No message"} (${info.state})`
    // );
  }

  /**
   * Update image overlay (only show for true out of stock)
   */
  function updateImageOverlay(info: any): void {
    const stockOverlay = document.getElementById("stock-overlay");
    const productImage = document.getElementById("product-image");
    const imageContainer = productImage?.parentElement;

    // Remove existing overlay
    if (stockOverlay) {
      stockOverlay.remove();
    }

    // Only add overlay for true out of stock (not "all in cart")
    if (
      info.state === ProductAvailabilityState.OUT_OF_STOCK &&
      imageContainer
    ) {
      const overlay = document.createElement("div");
      overlay.id = "stock-overlay";
      overlay.className =
        "absolute top-0 left-0 bg-state-error-surface text-state-error-text px-3 py-2 text-md font-bold rounded-sm";
      overlay.textContent = "Out of Stock";
      imageContainer.appendChild(overlay);

      // Dim image
      if (productImage) {
        productImage.classList.add("opacity-50");
      }
    } else if (productImage) {
      // Remove dimming for available/all-in-cart states
      productImage.classList.remove("opacity-50");
    }
  }

  /**
   * Update remaining/cart quantity displays
   */
  function updateInventoryDisplay(info: any): void {
    // Update remaining count (just the number)
    const remainingElement = document.getElementById("remaining-count");
    if (remainingElement) {
      remainingElement.textContent = `${info.remaining} available`;
    }

    // Update cart quantity display
    const cartQuantityElement = document.getElementById("cart-quantity");
    if (cartQuantityElement) {
      if (info.inCart > 0) {
        cartQuantityElement.textContent = `( ${info.inCart} in cart )`;
        cartQuantityElement.classList.remove("hidden");
      } else {
        cartQuantityElement.classList.add("hidden");
      }
    }
  }

  /**
   * Initialize data from hidden input
   */
  function initializeData() {
    const dataInput = document.getElementById(
      "variation-data"
    ) as HTMLInputElement;
    if (!dataInput?.value) return false;

    try {
      const data = JSON.parse(dataInput.value);
      variations = data.variations || [];
      availableAttributes = data.availableAttributes || {};
      productId = data.productId || "";

      // Find current variation and set initial attributes
      currentVariation = variations.find(
        (v) => v.variationId === data.selectedVariationId
      );
      if (currentVariation?.attributes) {
        selectedAttributes = { ...currentVariation.attributes };
      }

      return true;
    } catch (error) {
      console.error("Error parsing variation data:", error);
      return false;
    }
  }

  /**
   * Find matching variation based on selected attributes
   */
  function findMatchingVariation() {
    return findVariationByAttributes(variations, selectedAttributes);
  }

  /**
   * Update product UI based on selected variation
   */
  function updateProductUI(variation: any) {
    if (!variation) return;

    currentVariation = variation;
    updateVariantUrl(variation);
    const { variationId, name, price, quantity, image, unit } = variation;

    // Use our centralized availability system
    updateProductAvailability(variationId, quantity || 0);

    // Update price display
    const priceElement = document.getElementById("price-display");
    if (priceElement) {
      const formattedPrice = MoneyUtils.format(MoneyUtils.fromFloat(price));
      if (unit) {
        priceElement.innerHTML = `${formattedPrice} <span class="text-xl">${unit}</span>`;
      } else {
        priceElement.textContent = formattedPrice;
      }
    }

    // Update image if variation has its own
    if (image) {
      const productImage = document.getElementById(
        "product-image"
      ) as HTMLImageElement;
      if (productImage) {
        productImage.src = image;
      }
    }

    // Update product data in button
    const addToCartButton = document.getElementById(
      "add-to-cart-button"
    ) as HTMLButtonElement;
    if (addToCartButton?.dataset.product) {
      try {
        const productData = JSON.parse(
          addToCartButton.dataset.product
        ) as ProductData;
        productData.variationId = variationId;
        productData.variationName = name;
        productData.price = price;
        if (unit) productData.unit = unit;
        addToCartButton.dataset.product = JSON.stringify(productData);
      } catch (e) {
        console.error("Error updating product data:", e);
      }
    }
  }

  /**
   * Update URL when variants are selected
   */
  function updateVariantUrl(selectedVariation: any): void {
    const baseUrl = window.location.pathname.split("?")[0];

    if (selectedVariation.name) {
      const variantSlug = createVariantSlug(selectedVariation.name);
      const newUrl = `${baseUrl}?variant=${variantSlug}`;
      window.history.pushState({}, "", newUrl);
    }
  }

  /**
   * Update attribute button states
   */
  function updateAttributeButtonStates() {
    Object.keys(availableAttributes).forEach((attributeType) => {
      const buttons = document.querySelectorAll(
        `[data-attribute-type="${attributeType}"]`
      );

      buttons.forEach((button) => {
        const btn = button as HTMLButtonElement;
        const value = btn.dataset.attributeValue;
        if (!value) return;

        // Check if this value is available with current other selections
        const testAttributes = {
          ...selectedAttributes,
          [attributeType]: value,
        };
        const matchingVariation = findVariationByAttributes(
          variations,
          testAttributes
        );

        // Use our availability system to check if this variation can be added to cart
        const isAvailable =
          matchingVariation?.inStock &&
          cart.canAddToCart(
            productId,
            matchingVariation.variationId,
            matchingVariation.quantity || 0
          );

        // Update button state
        // btn.disabled = !isAvailable;
        if (!isAvailable) {
          btn.classList.add("opacity-50");
        } else {
          btn.classList.remove("opacity-50");
        }

        // Update selected state
        const isSelected = selectedAttributes[attributeType] === value;
        if (isSelected) {
          btn.classList.remove(
            "bg-ui-input-surface",
            "text-ui-input-text",
            "border-ui-input-border/50"
          );
          btn.classList.add(
            "bg-ui-button-surface",
            "text-ui-button-text",
            "border-ui-button-border/50"
          );
        } else {
          btn.classList.add(
            "bg-ui-input-surface",
            "text-ui-input-text",
            "border-ui-input-border/50"
          );
          btn.classList.remove(
            "bg-ui-button-surface",
            "text-ui-button-text",
            "border-ui-button-border/50"
          );
        }
      });
    });
  }

  function showOutOfStockState(attributes: Record<string, string>) {
    // Update price display (keep current price)
    const priceElement = document.getElementById("price-display");
    if (priceElement && currentVariation) {
      const formattedPrice = MoneyUtils.format(
        MoneyUtils.fromFloat(currentVariation.price)
      );
      priceElement.textContent = formattedPrice;
    }

    // Force out-of-stock UI using our centralized system
    updateProductAvailability("out-of-stock", 0);
  }

  /**
   * Handle attribute selection
   */
  function handleAttributeSelection(attributeType: string, value: string) {
    selectedAttributes[attributeType] = value;
    const matchingVariation = findMatchingVariation();

    if (matchingVariation) {
      updateProductUI(matchingVariation);
    } else {
      // No exact match - show as out of stock
      showOutOfStockState(selectedAttributes);
    }
    updateAttributeButtonStates();
  }

  /**
   * Setup attribute buttons
   */
  function setupAttributeButtons() {
    const attributeButtons = document.querySelectorAll(".attribute-button");
    attributeButtons.forEach((button) => {
      button.addEventListener("click", (e) => {
        const btn = e.currentTarget as HTMLButtonElement;
        if (btn.disabled) return;

        const attributeType = btn.dataset.attributeType;
        const attributeValue = btn.dataset.attributeValue;

        if (attributeType && attributeValue) {
          handleAttributeSelection(attributeType, attributeValue);
        }
      });
    });
  }

  /**
   * Setup quantity controls with fixed increment behavior
   */
  function setupQuantityControls() {
    const quantityInput = document.getElementById(
      "quantity-input"
    ) as HTMLInputElement;
    const decreaseButton = document.getElementById(
      "decrease-quantity"
    ) as HTMLButtonElement;
    const increaseButton = document.getElementById(
      "increase-quantity"
    ) as HTMLButtonElement;

    if (!quantityInput || !decreaseButton || !increaseButton) return;

    // Fixed increment - adds 1, not jump to max
    increaseButton.addEventListener("click", () => {
      const currentValue = parseInt(quantityInput.value, 10) || 0;
      const maxValue = parseInt(quantityInput.max, 10) || 0;

      if (currentValue < maxValue) {
        quantityInput.value = String(currentValue + 1);
        // Update button states
        decreaseButton.disabled = false;
        increaseButton.disabled = currentValue + 1 >= maxValue;
      }
    });

    decreaseButton.addEventListener("click", () => {
      const currentValue = parseInt(quantityInput.value, 10) || 0;
      if (currentValue > 1) {
        quantityInput.value = String(currentValue - 1);
        // Update button states
        increaseButton.disabled = false;
        decreaseButton.disabled = currentValue - 1 <= 1;
      }
    });

    quantityInput.addEventListener("change", () => {
      let value = parseInt(quantityInput.value, 10);
      const max = parseInt(quantityInput.max, 10) || 0;

      if (isNaN(value) || value < 1) value = 1;
      else if (value > max) value = max;

      quantityInput.value = String(value);

      // Update button states
      decreaseButton.disabled = value <= 1;
      increaseButton.disabled = value >= max;
    });
  }

  /**
   * Setup add to cart handler with availability checking
   */
  function setupAddToCartHandler() {
    const button = document.getElementById("add-to-cart-button");
    if (!button) return;

    const newButton = button.cloneNode(true) as HTMLElement;
    button.parentNode?.replaceChild(newButton, button);

    newButton.addEventListener("click", async () => {
      const btnElement = newButton as HTMLButtonElement;
      if (btnElement.disabled || isProcessing) return;

      isProcessing = true;
      const originalText = btnElement.textContent || "Add to Cart";
      btnElement.textContent = "Adding...";

      try {
        const productData = btnElement.dataset.product;
        if (!productData) throw new Error("No product data found");

        const product = JSON.parse(productData);
        const quantityInput = document.getElementById(
          "quantity-input"
        ) as HTMLInputElement;
        const quantity = quantityInput ? parseInt(quantityInput.value, 10) : 1;

        if (isNaN(quantity) || quantity < 1) {
          window.showNotification("Please enter a valid quantity", "error");
          return;
        }

        // Use cart's canAddToCart method
        const totalAvailable = currentVariation?.quantity || 0;
        if (
          !cart.canAddToCart(
            productId,
            product.variationId,
            totalAvailable,
            quantity
          )
        ) {
          window.showNotification("Cannot add that quantity to cart", "error");
          return;
        }

        product.quantity = quantity;
        const result = await cart.addItem(product);

        if (result.success) {
          window.showNotification(
            result.message || `Added ${quantity} to cart`,
            "success"
          );

          // Reset quantity to 1
          if (quantityInput) quantityInput.value = "1";

          // Update availability display
          if (currentVariation) {
            updateProductAvailability(
              currentVariation.variationId,
              currentVariation.quantity || 0
            );
          }
        } else {
          window.showNotification(
            result.message || "Failed to add to cart",
            "error"
          );
        }
      } catch (error) {
        console.error("Error adding to cart:", error);
        window.showNotification("Failed to add to cart", "error");
      } finally {
        isProcessing = false;
        btnElement.textContent = originalText;
      }
    });
  }

  /**
   * Setup fallback variation buttons
   */
  function setupFallbackVariationButtons() {
    const variationButtons = document.querySelectorAll("[data-variation-id]");
    variationButtons.forEach((button) => {
      button.addEventListener("click", () => {
        const btn = button as HTMLButtonElement;
        if (btn.disabled) return;

        const variationId = btn.dataset.variationId;
        const variation = variations.find((v) => v.variationId === variationId);

        if (variation) {
          updateProductUI(variation);

          // Update button styles
          variationButtons.forEach((b) => {
            b.classList.remove(
              "bg-ui-button-surface",
              "text-ui-button-text",
              "border-ui-button-border/50"
            );
            b.classList.add(
              "bg-ui-input-surface",
              "text-ui-input-text",
              "border-ui-input-border/50"
            );
          });

          button.classList.add(
            "bg-ui-button-surface",
            "text-ui-button-text",
            "border-ui-button-border/50"
          );
          button.classList.remove(
            "bg-ui-input-surface",
            "text-ui-input-text",
            "border-ui-input-border/50"
          );
        }
      });
    });
  }

  /**
   * Listen for cart changes
   */
  function setupCartEventListeners() {
    window.addEventListener("cartUpdated", () => {
      if (currentVariation) {
        updateProductAvailability(
          currentVariation.variationId,
          currentVariation.quantity || 0
        );

        // If current variant is now unavailable, switch to first available
        const availabilityInfo = cart.getProductAvailability(
          productId,
          currentVariation.variationId,
          currentVariation.quantity || 0
        );

        if (availabilityInfo.state === ProductAvailabilityState.OUT_OF_STOCK) {
          const firstAvailable = variations.find((v) =>
            cart.canAddToCart(productId, v.variationId, v.quantity || 0)
          );
          if (firstAvailable) {
            updateProductUI(firstAvailable);
          }
        }

        updateAttributeButtonStates();
      }
    });
  }

  /**
   * Initialize everything on page load
   */
  document.addEventListener("astro:page-load", () => {
    if (!initializeData()) {
      console.error("Failed to initialize variation data");
      return;
    }

    setupAttributeButtons();
    setupQuantityControls();
    setupFallbackVariationButtons();
    setupAddToCartHandler();
    setupCartEventListeners();

    // NEW: Check if current variant is available after cart loads
    if (currentVariation) {
      const availabilityInfo = cart.getProductAvailability(
        productId,
        currentVariation.variationId,
        currentVariation.quantity || 0
      );

      // If current variant unavailable, switch to first available
      if (availabilityInfo.state === ProductAvailabilityState.OUT_OF_STOCK) {
        const firstAvailable = variations.find((v) => {
          const info = cart.getProductAvailability(
            productId,
            v.variationId,
            v.quantity || 0
          );
          return info.state === ProductAvailabilityState.AVAILABLE;
        });

        if (firstAvailable) {
          currentVariation = firstAvailable;
        }
      }

      // Always update URL with variant (including default)
      updateVariantUrl(currentVariation);
      updateProductAvailability(
        currentVariation.variationId,
        currentVariation.quantity || 0
      );
    }

    updateAttributeButtonStates();
  });
</script>
